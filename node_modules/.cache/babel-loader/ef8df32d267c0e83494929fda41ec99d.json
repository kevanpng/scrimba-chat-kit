{"ast":null,"code":"/** @license React v16.0.0\n * react-dom.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function () {\n    'use strict';\n\n    var react = require('react');\n\n    var invariant = require('fbjs/lib/invariant');\n\n    var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\n\n    var _assign = require('object-assign');\n\n    var EventListener = require('fbjs/lib/EventListener');\n\n    var require$$0 = require('fbjs/lib/warning');\n\n    var hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');\n\n    var emptyFunction = require('fbjs/lib/emptyFunction');\n\n    var camelizeStyleName = require('fbjs/lib/camelizeStyleName');\n\n    var performanceNow = require('fbjs/lib/performanceNow');\n\n    var propTypes = require('prop-types');\n\n    var emptyObject = require('fbjs/lib/emptyObject');\n\n    var checkPropTypes = require('prop-types/checkPropTypes');\n\n    var shallowEqual = require('fbjs/lib/shallowEqual');\n\n    var containsNode = require('fbjs/lib/containsNode');\n\n    var focusNode = require('fbjs/lib/focusNode');\n\n    var getActiveElement = require('fbjs/lib/getActiveElement');\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule reactProdInvariant\n     * \n     */\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule checkReact\n     * \n     */\n\n\n    !react ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule DOMNamespaces\n     */\n\n    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    var MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    var Namespaces = {\n      html: HTML_NAMESPACE,\n      mathml: MATH_NAMESPACE,\n      svg: SVG_NAMESPACE\n    }; // Assumes there is no parent namespace.\n\n    function getIntrinsicNamespace(type) {\n      switch (type) {\n        case 'svg':\n          return SVG_NAMESPACE;\n\n        case 'math':\n          return MATH_NAMESPACE;\n\n        default:\n          return HTML_NAMESPACE;\n      }\n    }\n\n    function getChildNamespace$1(parentNamespace, type) {\n      if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {\n        // No (or default) parent namespace: potential entry point.\n        return getIntrinsicNamespace(type);\n      }\n\n      if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {\n        // We're leaving SVG.\n        return HTML_NAMESPACE;\n      } // By default, pass namespace below.\n\n\n      return parentNamespace;\n    }\n\n    var Namespaces_1 = Namespaces;\n    var getIntrinsicNamespace_1 = getIntrinsicNamespace;\n    var getChildNamespace_1 = getChildNamespace$1;\n    var DOMNamespaces = {\n      Namespaces: Namespaces_1,\n      getIntrinsicNamespace: getIntrinsicNamespace_1,\n      getChildNamespace: getChildNamespace_1\n    };\n    /**\n     * Injectable ordering of event plugins.\n     */\n\n    var eventPluginOrder = null;\n    /**\n     * Injectable mapping from names to event plugin modules.\n     */\n\n    var namesToPlugins = {};\n    /**\n     * Recomputes the plugin list using the injected plugins and plugin ordering.\n     *\n     * @private\n     */\n\n    function recomputePluginOrdering() {\n      if (!eventPluginOrder) {\n        // Wait until an `eventPluginOrder` is injected.\n        return;\n      }\n\n      for (var pluginName in namesToPlugins) {\n        var pluginModule = namesToPlugins[pluginName];\n        var pluginIndex = eventPluginOrder.indexOf(pluginName);\n        !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;\n\n        if (EventPluginRegistry.plugins[pluginIndex]) {\n          continue;\n        }\n\n        !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;\n        EventPluginRegistry.plugins[pluginIndex] = pluginModule;\n        var publishedEvents = pluginModule.eventTypes;\n\n        for (var eventName in publishedEvents) {\n          !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;\n        }\n      }\n    }\n    /**\n     * Publishes an event so that it can be dispatched by the supplied plugin.\n     *\n     * @param {object} dispatchConfig Dispatch configuration for the event.\n     * @param {object} PluginModule Plugin publishing the event.\n     * @return {boolean} True if the event was successfully published.\n     * @private\n     */\n\n\n    function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n      !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;\n      EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;\n      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n\n      if (phasedRegistrationNames) {\n        for (var phaseName in phasedRegistrationNames) {\n          if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n            var phasedRegistrationName = phasedRegistrationNames[phaseName];\n            publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\n          }\n        }\n\n        return true;\n      } else if (dispatchConfig.registrationName) {\n        publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Publishes a registration name that is used to identify dispatched events.\n     *\n     * @param {string} registrationName Registration name to add.\n     * @param {object} PluginModule Plugin publishing the event.\n     * @private\n     */\n\n\n    function publishRegistrationName(registrationName, pluginModule, eventName) {\n      !!EventPluginRegistry.registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;\n      EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;\n      EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\n      {\n        var lowerCasedName = registrationName.toLowerCase();\n        EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;\n\n        if (registrationName === 'onDoubleClick') {\n          EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;\n        }\n      }\n    }\n    /**\n     * Registers plugins so that they can extract and dispatch events.\n     *\n     * @see {EventPluginHub}\n     */\n\n\n    var EventPluginRegistry = {\n      /**\n       * Ordered list of injected plugins.\n       */\n      plugins: [],\n\n      /**\n       * Mapping from event name to dispatch config\n       */\n      eventNameDispatchConfigs: {},\n\n      /**\n       * Mapping from registration name to plugin module\n       */\n      registrationNameModules: {},\n\n      /**\n       * Mapping from registration name to event name\n       */\n      registrationNameDependencies: {},\n\n      /**\n       * Mapping from lowercase registration names to the properly cased version,\n       * used to warn in the case of missing event handlers. Available\n       * only in true.\n       * @type {Object}\n       */\n      possibleRegistrationNames: {},\n      // Trust the developer to only use possibleRegistrationNames in true\n\n      /**\n       * Injects an ordering of plugins (by plugin name). This allows the ordering\n       * to be decoupled from injection of the actual plugins so that ordering is\n       * always deterministic regardless of packaging, on-the-fly injection, etc.\n       *\n       * @param {array} InjectedEventPluginOrder\n       * @internal\n       * @see {EventPluginHub.injection.injectEventPluginOrder}\n       */\n      injectEventPluginOrder: function injectEventPluginOrder(injectedEventPluginOrder) {\n        !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0; // Clone the ordering so it cannot be dynamically mutated.\n\n        eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n        recomputePluginOrdering();\n      },\n\n      /**\n       * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n       * in the ordering injected by `injectEventPluginOrder`.\n       *\n       * Plugins can be injected as part of page initialization or on-the-fly.\n       *\n       * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n       * @internal\n       * @see {EventPluginHub.injection.injectEventPluginsByName}\n       */\n      injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {\n        var isOrderingDirty = false;\n\n        for (var pluginName in injectedNamesToPlugins) {\n          if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n            continue;\n          }\n\n          var pluginModule = injectedNamesToPlugins[pluginName];\n\n          if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\n            !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;\n            namesToPlugins[pluginName] = pluginModule;\n            isOrderingDirty = true;\n          }\n        }\n\n        if (isOrderingDirty) {\n          recomputePluginOrdering();\n        }\n      }\n    };\n    var EventPluginRegistry_1 = EventPluginRegistry; // These attributes should be all lowercase to allow for\n    // case insensitive checks\n\n    var RESERVED_PROPS = {\n      children: true,\n      dangerouslySetInnerHTML: true,\n      autoFocus: true,\n      defaultValue: true,\n      defaultChecked: true,\n      innerHTML: true,\n      suppressContentEditableWarning: true,\n      style: true\n    };\n\n    function checkMask(value, bitmask) {\n      return (value & bitmask) === bitmask;\n    }\n\n    var DOMPropertyInjection = {\n      /**\n       * Mapping from normalized, camelcased property names to a configuration that\n       * specifies how the associated DOM property should be accessed or rendered.\n       */\n      MUST_USE_PROPERTY: 0x1,\n      HAS_BOOLEAN_VALUE: 0x4,\n      HAS_NUMERIC_VALUE: 0x8,\n      HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,\n      HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,\n      HAS_STRING_BOOLEAN_VALUE: 0x40,\n\n      /**\n       * Inject some specialized knowledge about the DOM. This takes a config object\n       * with the following properties:\n       *\n       * Properties: object mapping DOM property name to one of the\n       * DOMPropertyInjection constants or null. If your attribute isn't in here,\n       * it won't get written to the DOM.\n       *\n       * DOMAttributeNames: object mapping React attribute name to the DOM\n       * attribute name. Attribute names not specified use the **lowercase**\n       * normalized name.\n       *\n       * DOMAttributeNamespaces: object mapping React attribute name to the DOM\n       * attribute namespace URL. (Attribute names not specified use no namespace.)\n       *\n       * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.\n       * Property names not specified use the normalized name.\n       *\n       * DOMMutationMethods: Properties that require special mutation methods. If\n       * `value` is undefined, the mutation method should unset the property.\n       *\n       * @param {object} domPropertyConfig the config as described above.\n       */\n      injectDOMPropertyConfig: function injectDOMPropertyConfig(domPropertyConfig) {\n        var Injection = DOMPropertyInjection;\n        var Properties = domPropertyConfig.Properties || {};\n        var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};\n        var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};\n        var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};\n\n        for (var propName in Properties) {\n          !!DOMProperty.properties.hasOwnProperty(propName) ? invariant(false, 'injectDOMPropertyConfig(...): You\\'re trying to inject DOM property \\'%s\\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : void 0;\n          var lowerCased = propName.toLowerCase();\n          var propConfig = Properties[propName];\n          var propertyInfo = {\n            attributeName: lowerCased,\n            attributeNamespace: null,\n            propertyName: propName,\n            mutationMethod: null,\n            mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),\n            hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),\n            hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),\n            hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),\n            hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE),\n            hasStringBooleanValue: checkMask(propConfig, Injection.HAS_STRING_BOOLEAN_VALUE)\n          };\n          !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : void 0;\n\n          if (DOMAttributeNames.hasOwnProperty(propName)) {\n            var attributeName = DOMAttributeNames[propName];\n            propertyInfo.attributeName = attributeName;\n          }\n\n          if (DOMAttributeNamespaces.hasOwnProperty(propName)) {\n            propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];\n          }\n\n          if (DOMMutationMethods.hasOwnProperty(propName)) {\n            propertyInfo.mutationMethod = DOMMutationMethods[propName];\n          } // Downcase references to whitelist properties to check for membership\n          // without case-sensitivity. This allows the whitelist to pick up\n          // `allowfullscreen`, which should be written using the property configuration\n          // for `allowFullscreen`\n\n\n          DOMProperty.properties[propName] = propertyInfo;\n        }\n      }\n    };\n    /* eslint-disable max-len */\n\n    var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n    /* eslint-enable max-len */\n\n    /**\n     * DOMProperty exports lookup objects that can be used like functions:\n     *\n     *   > DOMProperty.isValid['id']\n     *   true\n     *   > DOMProperty.isValid['foobar']\n     *   undefined\n     *\n     * Although this may be confusing, it performs better in general.\n     *\n     * @see http://jsperf.com/key-exists\n     * @see http://jsperf.com/key-missing\n     */\n\n    var DOMProperty = {\n      ID_ATTRIBUTE_NAME: 'data-reactid',\n      ROOT_ATTRIBUTE_NAME: 'data-reactroot',\n      ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,\n      ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\",\n\n      /**\n       * Map from property \"standard name\" to an object with info about how to set\n       * the property in the DOM. Each object contains:\n       *\n       * attributeName:\n       *   Used when rendering markup or with `*Attribute()`.\n       * attributeNamespace\n       * propertyName:\n       *   Used on DOM node instances. (This includes properties that mutate due to\n       *   external factors.)\n       * mutationMethod:\n       *   If non-null, used instead of the property or `setAttribute()` after\n       *   initial render.\n       * mustUseProperty:\n       *   Whether the property must be accessed and mutated as an object property.\n       * hasBooleanValue:\n       *   Whether the property should be removed when set to a falsey value.\n       * hasNumericValue:\n       *   Whether the property must be numeric or parse as a numeric and should be\n       *   removed when set to a falsey value.\n       * hasPositiveNumericValue:\n       *   Whether the property must be positive numeric or parse as a positive\n       *   numeric and should be removed when set to a falsey value.\n       * hasOverloadedBooleanValue:\n       *   Whether the property can be used as a flag as well as with a value.\n       *   Removed when strictly equal to false; present without a value when\n       *   strictly equal to true; present with a value otherwise.\n       */\n      properties: {},\n\n      /**\n       * Checks whether a property name is a writeable attribute.\n       * @method\n       */\n      shouldSetAttribute: function shouldSetAttribute(name, value) {\n        if (DOMProperty.isReservedProp(name)) {\n          return false;\n        }\n\n        if ((name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {\n          return false;\n        }\n\n        if (value === null) {\n          return true;\n        }\n\n        switch (typeof value) {\n          case 'boolean':\n            return DOMProperty.shouldAttributeAcceptBooleanValue(name);\n\n          case 'undefined':\n          case 'number':\n          case 'string':\n          case 'object':\n            return true;\n\n          default:\n            // function, symbol\n            return false;\n        }\n      },\n      getPropertyInfo: function getPropertyInfo(name) {\n        return DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;\n      },\n      shouldAttributeAcceptBooleanValue: function shouldAttributeAcceptBooleanValue(name) {\n        if (DOMProperty.isReservedProp(name)) {\n          return true;\n        }\n\n        var propertyInfo = DOMProperty.getPropertyInfo(name);\n\n        if (propertyInfo) {\n          return propertyInfo.hasBooleanValue || propertyInfo.hasStringBooleanValue || propertyInfo.hasOverloadedBooleanValue;\n        }\n\n        var prefix = name.toLowerCase().slice(0, 5);\n        return prefix === 'data-' || prefix === 'aria-';\n      },\n\n      /**\n       * Checks to see if a property name is within the list of properties\n       * reserved for internal React operations. These properties should\n       * not be set on an HTML element.\n       *\n       * @private\n       * @param {string} name\n       * @return {boolean} If the name is within reserved props\n       */\n      isReservedProp: function isReservedProp(name) {\n        return RESERVED_PROPS.hasOwnProperty(name);\n      },\n      injection: DOMPropertyInjection\n    };\n    var DOMProperty_1 = DOMProperty;\n    /**\n     * Copyright (c) 2015-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule ReactDOMComponentFlags\n     */\n\n    var ReactDOMComponentFlags = {\n      hasCachedChildNodes: 1 << 0\n    };\n    var ReactDOMComponentFlags_1 = ReactDOMComponentFlags;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule ReactTypeOfWork\n     * \n     */\n\n    var ReactTypeOfWork = {\n      IndeterminateComponent: 0,\n      // Before we know whether it is functional or class\n      FunctionalComponent: 1,\n      ClassComponent: 2,\n      HostRoot: 3,\n      // Root of a host tree. Could be nested inside another node.\n      HostPortal: 4,\n      // A subtree. Could be an entry point to a different renderer.\n      HostComponent: 5,\n      HostText: 6,\n      CoroutineComponent: 7,\n      CoroutineHandlerPhase: 8,\n      YieldComponent: 9,\n      Fragment: 10\n    };\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule HTMLNodeType\n     */\n\n    /**\n     * HTML nodeType values that represent the type of the node\n     */\n\n    var HTMLNodeType = {\n      ELEMENT_NODE: 1,\n      TEXT_NODE: 3,\n      COMMENT_NODE: 8,\n      DOCUMENT_NODE: 9,\n      DOCUMENT_FRAGMENT_NODE: 11\n    };\n    var HTMLNodeType_1 = HTMLNodeType;\n    var HostComponent = ReactTypeOfWork.HostComponent;\n    var HostText = ReactTypeOfWork.HostText;\n    var ELEMENT_NODE$1 = HTMLNodeType_1.ELEMENT_NODE;\n    var COMMENT_NODE$1 = HTMLNodeType_1.COMMENT_NODE;\n    var ATTR_NAME = DOMProperty_1.ID_ATTRIBUTE_NAME;\n    var Flags = ReactDOMComponentFlags_1;\n    var randomKey = Math.random().toString(36).slice(2);\n    var internalInstanceKey = '__reactInternalInstance$' + randomKey;\n    var internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\n    /**\n     * Check if a given node should be cached.\n     */\n\n    function shouldPrecacheNode(node, nodeID) {\n      return node.nodeType === ELEMENT_NODE$1 && node.getAttribute(ATTR_NAME) === '' + nodeID || node.nodeType === COMMENT_NODE$1 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === COMMENT_NODE$1 && node.nodeValue === ' react-empty: ' + nodeID + ' ';\n    }\n    /**\n     * Drill down (through composites and empty components) until we get a host or\n     * host text component.\n     *\n     * This is pretty polymorphic but unavoidable with the current structure we have\n     * for `_renderedChildren`.\n     */\n\n\n    function getRenderedHostOrTextFromComponent(component) {\n      var rendered;\n\n      while (rendered = component._renderedComponent) {\n        component = rendered;\n      }\n\n      return component;\n    }\n    /**\n     * Populate `_hostNode` on the rendered host/text component with the given\n     * DOM node. The passed `inst` can be a composite.\n     */\n\n\n    function precacheNode(inst, node) {\n      var hostInst = getRenderedHostOrTextFromComponent(inst);\n      hostInst._hostNode = node;\n      node[internalInstanceKey] = hostInst;\n    }\n\n    function precacheFiberNode$1(hostInst, node) {\n      node[internalInstanceKey] = hostInst;\n    }\n\n    function uncacheNode(inst) {\n      var node = inst._hostNode;\n\n      if (node) {\n        delete node[internalInstanceKey];\n        inst._hostNode = null;\n      }\n    }\n    /**\n     * Populate `_hostNode` on each child of `inst`, assuming that the children\n     * match up with the DOM (element) children of `node`.\n     *\n     * We cache entire levels at once to avoid an n^2 problem where we access the\n     * children of a node sequentially and have to walk from the start to our target\n     * node every time.\n     *\n     * Since we update `_renderedChildren` and the actual DOM at (slightly)\n     * different times, we could race here and see a newer `_renderedChildren` than\n     * the DOM nodes we see. To avoid this, ReactMultiChild calls\n     * `prepareToManageChildren` before we change `_renderedChildren`, at which\n     * time the container's child nodes are always cached (until it unmounts).\n     */\n\n\n    function precacheChildNodes(inst, node) {\n      if (inst._flags & Flags.hasCachedChildNodes) {\n        return;\n      }\n\n      var children = inst._renderedChildren;\n      var childNode = node.firstChild;\n\n      outer: for (var name in children) {\n        if (!children.hasOwnProperty(name)) {\n          continue;\n        }\n\n        var childInst = children[name];\n\n        var childID = getRenderedHostOrTextFromComponent(childInst)._domID;\n\n        if (childID === 0) {\n          // We're currently unmounting this child in ReactMultiChild; skip it.\n          continue;\n        } // We assume the child nodes are in the same order as the child instances.\n\n\n        for (; childNode !== null; childNode = childNode.nextSibling) {\n          if (shouldPrecacheNode(childNode, childID)) {\n            precacheNode(childInst, childNode);\n            continue outer;\n          }\n        } // We reached the end of the DOM children without finding an ID match.\n\n\n        invariant(false, 'Unable to find element with ID %s.', childID);\n      }\n\n      inst._flags |= Flags.hasCachedChildNodes;\n    }\n    /**\n     * Given a DOM node, return the closest ReactDOMComponent or\n     * ReactDOMTextComponent instance ancestor.\n     */\n\n\n    function getClosestInstanceFromNode(node) {\n      if (node[internalInstanceKey]) {\n        return node[internalInstanceKey];\n      } // Walk up the tree until we find an ancestor whose instance we have cached.\n\n\n      var parents = [];\n\n      while (!node[internalInstanceKey]) {\n        parents.push(node);\n\n        if (node.parentNode) {\n          node = node.parentNode;\n        } else {\n          // Top of the tree. This node must not be part of a React tree (or is\n          // unmounted, potentially).\n          return null;\n        }\n      }\n\n      var closest;\n      var inst = node[internalInstanceKey];\n\n      if (inst.tag === HostComponent || inst.tag === HostText) {\n        // In Fiber, this will always be the deepest root.\n        return inst;\n      }\n\n      for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {\n        closest = inst;\n\n        if (parents.length) {\n          precacheChildNodes(inst, node);\n        }\n      }\n\n      return closest;\n    }\n    /**\n     * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n     * instance, or null if the node was not rendered by this React.\n     */\n\n\n    function getInstanceFromNode(node) {\n      var inst = node[internalInstanceKey];\n\n      if (inst) {\n        if (inst.tag === HostComponent || inst.tag === HostText) {\n          return inst;\n        } else if (inst._hostNode === node) {\n          return inst;\n        } else {\n          return null;\n        }\n      }\n\n      inst = getClosestInstanceFromNode(node);\n\n      if (inst != null && inst._hostNode === node) {\n        return inst;\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n     * DOM node.\n     */\n\n\n    function getNodeFromInstance(inst) {\n      if (inst.tag === HostComponent || inst.tag === HostText) {\n        // In Fiber this, is just the state node right now. We assume it will be\n        // a host component or host text.\n        return inst.stateNode;\n      } // Without this first invariant, passing a non-DOM-component triggers the next\n      // invariant for a missing parent, which is super confusing.\n\n\n      !(inst._hostNode !== undefined) ? invariant(false, 'getNodeFromInstance: Invalid argument.') : void 0;\n\n      if (inst._hostNode) {\n        return inst._hostNode;\n      } // Walk up the tree until we find an ancestor whose DOM node we have cached.\n\n\n      var parents = [];\n\n      while (!inst._hostNode) {\n        parents.push(inst);\n        !inst._hostParent ? invariant(false, 'React DOM tree root should always have a node reference.') : void 0;\n        inst = inst._hostParent;\n      } // Now parents contains each ancestor that does *not* have a cached native\n      // node, and `inst` is the deepest ancestor that does.\n\n\n      for (; parents.length; inst = parents.pop()) {\n        precacheChildNodes(inst, inst._hostNode);\n      }\n\n      return inst._hostNode;\n    }\n\n    function getFiberCurrentPropsFromNode(node) {\n      return node[internalEventHandlersKey] || null;\n    }\n\n    function updateFiberProps$1(node, props) {\n      node[internalEventHandlersKey] = props;\n    }\n\n    var ReactDOMComponentTree = {\n      getClosestInstanceFromNode: getClosestInstanceFromNode,\n      getInstanceFromNode: getInstanceFromNode,\n      getNodeFromInstance: getNodeFromInstance,\n      precacheChildNodes: precacheChildNodes,\n      precacheNode: precacheNode,\n      uncacheNode: uncacheNode,\n      precacheFiberNode: precacheFiberNode$1,\n      getFiberCurrentPropsFromNode: getFiberCurrentPropsFromNode,\n      updateFiberProps: updateFiberProps$1\n    };\n    var ReactDOMComponentTree_1 = ReactDOMComponentTree;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule ReactInstanceMap\n     */\n\n    /**\n     * `ReactInstanceMap` maintains a mapping from a public facing stateful\n     * instance (key) and the internal representation (value). This allows public\n     * methods to accept the user facing instance as an argument and map them back\n     * to internal methods.\n     */\n    // TODO: Replace this with ES6: var ReactInstanceMap = new Map();\n\n    var ReactInstanceMap = {\n      /**\n       * This API should be called `delete` but we'd have to make sure to always\n       * transform these to strings for IE support. When this transform is fully\n       * supported we can rename it.\n       */\n      remove: function remove(key) {\n        key._reactInternalFiber = undefined;\n      },\n      get: function get(key) {\n        return key._reactInternalFiber;\n      },\n      has: function has(key) {\n        return key._reactInternalFiber !== undefined;\n      },\n      set: function set(key, value) {\n        key._reactInternalFiber = value;\n      }\n    };\n    var ReactInstanceMap_1 = ReactInstanceMap;\n    var ReactInternals = react.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    var ReactGlobalSharedState = {\n      ReactCurrentOwner: ReactInternals.ReactCurrentOwner\n    };\n    {\n      _assign(ReactGlobalSharedState, {\n        ReactComponentTreeHook: ReactInternals.ReactComponentTreeHook,\n        ReactDebugCurrentFrame: ReactInternals.ReactDebugCurrentFrame\n      });\n    }\n    var ReactGlobalSharedState_1 = ReactGlobalSharedState;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule getComponentName\n     * \n     */\n\n    function getComponentName(instanceOrFiber) {\n      if (typeof instanceOrFiber.getName === 'function') {\n        // Stack reconciler\n        var instance = instanceOrFiber;\n        return instance.getName();\n      }\n\n      if (typeof instanceOrFiber.tag === 'number') {\n        // Fiber reconciler\n        var fiber = instanceOrFiber;\n        var type = fiber.type;\n\n        if (typeof type === 'string') {\n          return type;\n        }\n\n        if (typeof type === 'function') {\n          return type.displayName || type.name;\n        }\n      }\n\n      return null;\n    }\n\n    var getComponentName_1 = getComponentName;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule ReactTypeOfSideEffect\n     * \n     */\n\n    var ReactTypeOfSideEffect = {\n      // Don't change these two values:\n      NoEffect: 0,\n      //           0b00000000\n      PerformedWork: 1,\n      //      0b00000001\n      // You can change the rest (and add more).\n      Placement: 2,\n      //          0b00000010\n      Update: 4,\n      //             0b00000100\n      PlacementAndUpdate: 6,\n      // 0b00000110\n      Deletion: 8,\n      //           0b00001000\n      ContentReset: 16,\n      //      0b00010000\n      Callback: 32,\n      //          0b00100000\n      Err: 64,\n      //               0b01000000\n      Ref: 128\n    };\n    var ReactCurrentOwner = ReactGlobalSharedState_1.ReactCurrentOwner;\n    {\n      var warning$1 = require$$0;\n    }\n    var ClassComponent = ReactTypeOfWork.ClassComponent;\n    var HostComponent$1 = ReactTypeOfWork.HostComponent;\n    var HostRoot$1 = ReactTypeOfWork.HostRoot;\n    var HostPortal = ReactTypeOfWork.HostPortal;\n    var HostText$1 = ReactTypeOfWork.HostText;\n    var NoEffect = ReactTypeOfSideEffect.NoEffect;\n    var Placement = ReactTypeOfSideEffect.Placement;\n    var MOUNTING = 1;\n    var MOUNTED = 2;\n    var UNMOUNTED = 3;\n\n    function isFiberMountedImpl(fiber) {\n      var node = fiber;\n\n      if (!fiber.alternate) {\n        // If there is no alternate, this might be a new tree that isn't inserted\n        // yet. If it is, then it will have a pending insertion effect on it.\n        if ((node.effectTag & Placement) !== NoEffect) {\n          return MOUNTING;\n        }\n\n        while (node['return']) {\n          node = node['return'];\n\n          if ((node.effectTag & Placement) !== NoEffect) {\n            return MOUNTING;\n          }\n        }\n      } else {\n        while (node['return']) {\n          node = node['return'];\n        }\n      }\n\n      if (node.tag === HostRoot$1) {\n        // TODO: Check if this was a nested HostRoot when used with\n        // renderContainerIntoSubtree.\n        return MOUNTED;\n      } // If we didn't hit the root, that means that we're in an disconnected tree\n      // that has been unmounted.\n\n\n      return UNMOUNTED;\n    }\n\n    var isFiberMounted = function isFiberMounted(fiber) {\n      return isFiberMountedImpl(fiber) === MOUNTED;\n    };\n\n    var isMounted = function isMounted(component) {\n      {\n        var owner = ReactCurrentOwner.current;\n\n        if (owner !== null && owner.tag === ClassComponent) {\n          var ownerFiber = owner;\n          var instance = ownerFiber.stateNode;\n          warning$1(instance._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName_1(ownerFiber) || 'A component');\n          instance._warnedAboutRefsInRender = true;\n        }\n      }\n      var fiber = ReactInstanceMap_1.get(component);\n\n      if (!fiber) {\n        return false;\n      }\n\n      return isFiberMountedImpl(fiber) === MOUNTED;\n    };\n\n    function assertIsMounted(fiber) {\n      !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    }\n\n    function findCurrentFiberUsingSlowPath(fiber) {\n      var alternate = fiber.alternate;\n\n      if (!alternate) {\n        // If there is no alternate, then we only need to check if it is mounted.\n        var state = isFiberMountedImpl(fiber);\n        !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n\n        if (state === MOUNTING) {\n          return null;\n        }\n\n        return fiber;\n      } // If we have two possible branches, we'll walk backwards up to the root\n      // to see what path the root points to. On the way we may hit one of the\n      // special cases and we'll deal with them.\n\n\n      var a = fiber;\n      var b = alternate;\n\n      while (true) {\n        var parentA = a['return'];\n        var parentB = parentA ? parentA.alternate : null;\n\n        if (!parentA || !parentB) {\n          // We're at the root.\n          break;\n        } // If both copies of the parent fiber point to the same child, we can\n        // assume that the child is current. This happens when we bailout on low\n        // priority: the bailed out fiber's child reuses the current child.\n\n\n        if (parentA.child === parentB.child) {\n          var child = parentA.child;\n\n          while (child) {\n            if (child === a) {\n              // We've determined that A is the current branch.\n              assertIsMounted(parentA);\n              return fiber;\n            }\n\n            if (child === b) {\n              // We've determined that B is the current branch.\n              assertIsMounted(parentA);\n              return alternate;\n            }\n\n            child = child.sibling;\n          } // We should never have an alternate for any mounting node. So the only\n          // way this could possibly happen is if this was unmounted, if at all.\n\n\n          invariant(false, 'Unable to find node on an unmounted component.');\n        }\n\n        if (a['return'] !== b['return']) {\n          // The return pointer of A and the return pointer of B point to different\n          // fibers. We assume that return pointers never criss-cross, so A must\n          // belong to the child set of A.return, and B must belong to the child\n          // set of B.return.\n          a = parentA;\n          b = parentB;\n        } else {\n          // The return pointers point to the same fiber. We'll have to use the\n          // default, slow path: scan the child sets of each parent alternate to see\n          // which child belongs to which set.\n          //\n          // Search parent A's child set\n          var didFindChild = false;\n          var _child = parentA.child;\n\n          while (_child) {\n            if (_child === a) {\n              didFindChild = true;\n              a = parentA;\n              b = parentB;\n              break;\n            }\n\n            if (_child === b) {\n              didFindChild = true;\n              b = parentA;\n              a = parentB;\n              break;\n            }\n\n            _child = _child.sibling;\n          }\n\n          if (!didFindChild) {\n            // Search parent B's child set\n            _child = parentB.child;\n\n            while (_child) {\n              if (_child === a) {\n                didFindChild = true;\n                a = parentB;\n                b = parentA;\n                break;\n              }\n\n              if (_child === b) {\n                didFindChild = true;\n                b = parentB;\n                a = parentA;\n                break;\n              }\n\n              _child = _child.sibling;\n            }\n\n            !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n          }\n        }\n\n        !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      } // If the root is not a host container, we're in a disconnected tree. I.e.\n      // unmounted.\n\n\n      !(a.tag === HostRoot$1) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n\n      if (a.stateNode.current === a) {\n        // We've determined that A is the current branch.\n        return fiber;\n      } // Otherwise B has to be current branch.\n\n\n      return alternate;\n    }\n\n    var findCurrentFiberUsingSlowPath_1 = findCurrentFiberUsingSlowPath;\n\n    var findCurrentHostFiber = function findCurrentHostFiber(parent) {\n      var currentParent = findCurrentFiberUsingSlowPath(parent);\n\n      if (!currentParent) {\n        return null;\n      } // Next we'll drill down this component to find the first HostComponent/Text.\n\n\n      var node = currentParent;\n\n      while (true) {\n        if (node.tag === HostComponent$1 || node.tag === HostText$1) {\n          return node;\n        } else if (node.child) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n\n        if (node === currentParent) {\n          return null;\n        }\n\n        while (!node.sibling) {\n          if (!node['return'] || node['return'] === currentParent) {\n            return null;\n          }\n\n          node = node['return'];\n        }\n\n        node.sibling['return'] = node['return'];\n        node = node.sibling;\n      } // Flow needs the return null here, but ESLint complains about it.\n      // eslint-disable-next-line no-unreachable\n\n\n      return null;\n    };\n\n    var findCurrentHostFiberWithNoPortals = function findCurrentHostFiberWithNoPortals(parent) {\n      var currentParent = findCurrentFiberUsingSlowPath(parent);\n\n      if (!currentParent) {\n        return null;\n      } // Next we'll drill down this component to find the first HostComponent/Text.\n\n\n      var node = currentParent;\n\n      while (true) {\n        if (node.tag === HostComponent$1 || node.tag === HostText$1) {\n          return node;\n        } else if (node.child && node.tag !== HostPortal) {\n          node.child['return'] = node;\n          node = node.child;\n          continue;\n        }\n\n        if (node === currentParent) {\n          return null;\n        }\n\n        while (!node.sibling) {\n          if (!node['return'] || node['return'] === currentParent) {\n            return null;\n          }\n\n          node = node['return'];\n        }\n\n        node.sibling['return'] = node['return'];\n        node = node.sibling;\n      } // Flow needs the return null here, but ESLint complains about it.\n      // eslint-disable-next-line no-unreachable\n\n\n      return null;\n    };\n\n    var ReactFiberTreeReflection = {\n      isFiberMounted: isFiberMounted,\n      isMounted: isMounted,\n      findCurrentFiberUsingSlowPath: findCurrentFiberUsingSlowPath_1,\n      findCurrentHostFiber: findCurrentHostFiber,\n      findCurrentHostFiberWithNoPortals: findCurrentHostFiberWithNoPortals\n    };\n    var ReactErrorUtils = {\n      // Used by Fiber to simulate a try-catch.\n      _caughtError: null,\n      _hasCaughtError: false,\n      // Used by event system to capture/rethrow the first error.\n      _rethrowError: null,\n      _hasRethrowError: false,\n      injection: {\n        injectErrorUtils: function injectErrorUtils(injectedErrorUtils) {\n          !(typeof injectedErrorUtils.invokeGuardedCallback === 'function') ? invariant(false, 'Injected invokeGuardedCallback() must be a function.') : void 0;\n          _invokeGuardedCallback = injectedErrorUtils.invokeGuardedCallback;\n        }\n      },\n\n      /**\n       * Call a function while guarding against errors that happens within it.\n       * Returns an error if it throws, otherwise null.\n       *\n       * In production, this is implemented using a try-catch. The reason we don't\n       * use a try-catch directly is so that we can swap out a different\n       * implementation in DEV mode.\n       *\n       * @param {String} name of the guard to use for logging or debugging\n       * @param {Function} func The function to invoke\n       * @param {*} context The context to use when calling the function\n       * @param {...*} args Arguments for function\n       */\n      invokeGuardedCallback: function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n        _invokeGuardedCallback.apply(ReactErrorUtils, arguments);\n      },\n\n      /**\n       * Same as invokeGuardedCallback, but instead of returning an error, it stores\n       * it in a global so it can be rethrown by `rethrowCaughtError` later.\n       * TODO: See if _caughtError and _rethrowError can be unified.\n       *\n       * @param {String} name of the guard to use for logging or debugging\n       * @param {Function} func The function to invoke\n       * @param {*} context The context to use when calling the function\n       * @param {...*} args Arguments for function\n       */\n      invokeGuardedCallbackAndCatchFirstError: function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {\n        ReactErrorUtils.invokeGuardedCallback.apply(this, arguments);\n\n        if (ReactErrorUtils.hasCaughtError()) {\n          var error = ReactErrorUtils.clearCaughtError();\n\n          if (!ReactErrorUtils._hasRethrowError) {\n            ReactErrorUtils._hasRethrowError = true;\n            ReactErrorUtils._rethrowError = error;\n          }\n        }\n      },\n\n      /**\n       * During execution of guarded functions we will capture the first error which\n       * we will rethrow to be handled by the top level error handler.\n       */\n      rethrowCaughtError: function rethrowCaughtError() {\n        return _rethrowCaughtError.apply(ReactErrorUtils, arguments);\n      },\n      hasCaughtError: function hasCaughtError() {\n        return ReactErrorUtils._hasCaughtError;\n      },\n      clearCaughtError: function clearCaughtError() {\n        if (ReactErrorUtils._hasCaughtError) {\n          var error = ReactErrorUtils._caughtError;\n          ReactErrorUtils._caughtError = null;\n          ReactErrorUtils._hasCaughtError = false;\n          return error;\n        } else {\n          invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n    };\n\n    var _invokeGuardedCallback = function _invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n      ReactErrorUtils._hasCaughtError = false;\n      ReactErrorUtils._caughtError = null;\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n      try {\n        func.apply(context, funcArgs);\n      } catch (error) {\n        ReactErrorUtils._caughtError = error;\n        ReactErrorUtils._hasCaughtError = true;\n      }\n    };\n\n    {\n      // In DEV mode, we swap out invokeGuardedCallback for a special version\n      // that plays more nicely with the browser's DevTools. The idea is to preserve\n      // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n      // functions in invokeGuardedCallback, and the production version of\n      // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n      // like caught exceptions, and the DevTools won't pause unless the developer\n      // takes the extra step of enabling pause on caught exceptions. This is\n      // untintuitive, though, because even though React has caught the error, from\n      // the developer's perspective, the error is uncaught.\n      //\n      // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n      // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n      // DOM node, and call the user-provided callback from inside an event handler\n      // for that fake event. If the callback throws, the error is \"captured\" using\n      // a global event handler. But because the error happens in a different\n      // event loop context, it does not interrupt the normal program flow.\n      // Effectively, this gives us try-catch behavior without actually using\n      // try-catch. Neat!\n      // Check that the browser supports the APIs we need to implement our special\n      // DEV version of invokeGuardedCallback\n      if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n        var fakeNode = document.createElement('react');\n\n        var invokeGuardedCallbackDev = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {\n          // Keeps track of whether the user-provided callback threw an error. We\n          // set this to true at the beginning, then set it to false right after\n          // calling the function. If the function errors, `didError` will never be\n          // set to false. This strategy works even if the browser is flaky and\n          // fails to call our global error handler, because it doesn't rely on\n          // the error event at all.\n          var didError = true; // Create an event handler for our fake event. We will synchronously\n          // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n          // call the user-provided callback.\n\n          var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n          function callCallback() {\n            // We immediately remove the callback from event listeners so that\n            // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n            // nested call would trigger the fake event handlers of any call higher\n            // in the stack.\n            fakeNode.removeEventListener(evtType, callCallback, false);\n            func.apply(context, funcArgs);\n            didError = false;\n          } // Create a global error event handler. We use this to capture the value\n          // that was thrown. It's possible that this error handler will fire more\n          // than once; for example, if non-React code also calls `dispatchEvent`\n          // and a handler for that event throws. We should be resilient to most of\n          // those cases. Even if our error event handler fires more than once, the\n          // last error event is always used. If the callback actually does error,\n          // we know that the last error event is the correct one, because it's not\n          // possible for anything else to have happened in between our callback\n          // erroring and the code that follows the `dispatchEvent` call below. If\n          // the callback doesn't error, but the error event was fired, we know to\n          // ignore it because `didError` will be false, as described above.\n\n\n          var error = void 0; // Use this to track whether the error event is ever called.\n\n          var didSetError = false;\n          var isCrossOriginError = false;\n\n          function onError(event) {\n            error = event.error;\n            didSetError = true;\n\n            if (error === null && event.colno === 0 && event.lineno === 0) {\n              isCrossOriginError = true;\n            }\n          } // Create a fake event type.\n\n\n          var evtType = 'react-' + (name ? name : 'invokeguardedcallback'); // Attach our event handlers\n\n          window.addEventListener('error', onError);\n          fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function\n          // errors, it will trigger our global error handler.\n\n          var evt = document.createEvent('Event');\n          evt.initEvent(evtType, false, false);\n          fakeNode.dispatchEvent(evt);\n\n          if (didError) {\n            if (!didSetError) {\n              // The callback errored, but the error event never fired.\n              error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n            } else if (isCrossOriginError) {\n              error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n            }\n\n            ReactErrorUtils._hasCaughtError = true;\n            ReactErrorUtils._caughtError = error;\n          } else {\n            ReactErrorUtils._hasCaughtError = false;\n            ReactErrorUtils._caughtError = null;\n          } // Remove our event listeners\n\n\n          window.removeEventListener('error', onError);\n        };\n\n        _invokeGuardedCallback = invokeGuardedCallbackDev;\n      }\n    }\n\n    var _rethrowCaughtError = function _rethrowCaughtError() {\n      if (ReactErrorUtils._hasRethrowError) {\n        var error = ReactErrorUtils._rethrowError;\n        ReactErrorUtils._rethrowError = null;\n        ReactErrorUtils._hasRethrowError = false;\n        throw error;\n      }\n    };\n\n    var ReactErrorUtils_1 = ReactErrorUtils;\n    {\n      var warning$2 = require$$0;\n    }\n    /**\n     * Injected dependencies:\n     */\n\n    /**\n     * - `ComponentTree`: [required] Module that can convert between React instances\n     *   and actual node references.\n     */\n\n    var ComponentTree;\n    var injection = {\n      injectComponentTree: function injectComponentTree(Injected) {\n        ComponentTree = Injected;\n        {\n          warning$2(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');\n        }\n      }\n    };\n\n    function isEndish(topLevelType) {\n      return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';\n    }\n\n    function isMoveish(topLevelType) {\n      return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';\n    }\n\n    function isStartish(topLevelType) {\n      return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';\n    }\n\n    var validateEventDispatches;\n    {\n      validateEventDispatches = function validateEventDispatches(event) {\n        var dispatchListeners = event._dispatchListeners;\n        var dispatchInstances = event._dispatchInstances;\n        var listenersIsArr = Array.isArray(dispatchListeners);\n        var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n        var instancesIsArr = Array.isArray(dispatchInstances);\n        var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n        warning$2(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');\n      };\n    }\n    /**\n     * Dispatch the event to the listener.\n     * @param {SyntheticEvent} event SyntheticEvent to handle\n     * @param {boolean} simulated If the event is simulated (changes exn behavior)\n     * @param {function} listener Application-level callback\n     * @param {*} inst Internal component instance\n     */\n\n    function executeDispatch(event, simulated, listener, inst) {\n      var type = event.type || 'unknown-event';\n      event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);\n      ReactErrorUtils_1.invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n      event.currentTarget = null;\n    }\n    /**\n     * Standard/simple iteration through an event's collected dispatches.\n     */\n\n\n    function executeDispatchesInOrder(event, simulated) {\n      var dispatchListeners = event._dispatchListeners;\n      var dispatchInstances = event._dispatchInstances;\n      {\n        validateEventDispatches(event);\n      }\n\n      if (Array.isArray(dispatchListeners)) {\n        for (var i = 0; i < dispatchListeners.length; i++) {\n          if (event.isPropagationStopped()) {\n            break;\n          } // Listeners and Instances are two parallel arrays that are always in sync.\n\n\n          executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);\n        }\n      } else if (dispatchListeners) {\n        executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n      }\n\n      event._dispatchListeners = null;\n      event._dispatchInstances = null;\n    }\n    /**\n     * Standard/simple iteration through an event's collected dispatches, but stops\n     * at the first dispatch execution returning true, and returns that id.\n     *\n     * @return {?string} id of the first dispatch execution who's listener returns\n     * true, or null if no listener returned true.\n     */\n\n\n    function executeDispatchesInOrderStopAtTrueImpl(event) {\n      var dispatchListeners = event._dispatchListeners;\n      var dispatchInstances = event._dispatchInstances;\n      {\n        validateEventDispatches(event);\n      }\n\n      if (Array.isArray(dispatchListeners)) {\n        for (var i = 0; i < dispatchListeners.length; i++) {\n          if (event.isPropagationStopped()) {\n            break;\n          } // Listeners and Instances are two parallel arrays that are always in sync.\n\n\n          if (dispatchListeners[i](event, dispatchInstances[i])) {\n            return dispatchInstances[i];\n          }\n        }\n      } else if (dispatchListeners) {\n        if (dispatchListeners(event, dispatchInstances)) {\n          return dispatchInstances;\n        }\n      }\n\n      return null;\n    }\n    /**\n     * @see executeDispatchesInOrderStopAtTrueImpl\n     */\n\n\n    function executeDispatchesInOrderStopAtTrue(event) {\n      var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n      event._dispatchInstances = null;\n      event._dispatchListeners = null;\n      return ret;\n    }\n    /**\n     * Execution of a \"direct\" dispatch - there must be at most one dispatch\n     * accumulated on the event or it is considered an error. It doesn't really make\n     * sense for an event with multiple dispatches (bubbled) to keep track of the\n     * return values at each dispatch execution, but it does tend to make sense when\n     * dealing with \"direct\" dispatches.\n     *\n     * @return {*} The return value of executing the single dispatch.\n     */\n\n\n    function executeDirectDispatch(event) {\n      {\n        validateEventDispatches(event);\n      }\n      var dispatchListener = event._dispatchListeners;\n      var dispatchInstance = event._dispatchInstances;\n      !!Array.isArray(dispatchListener) ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : void 0;\n      event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;\n      var res = dispatchListener ? dispatchListener(event) : null;\n      event.currentTarget = null;\n      event._dispatchListeners = null;\n      event._dispatchInstances = null;\n      return res;\n    }\n    /**\n     * @param {SyntheticEvent} event\n     * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n     */\n\n\n    function hasDispatches(event) {\n      return !!event._dispatchListeners;\n    }\n    /**\n     * General utilities that are useful in creating custom Event Plugins.\n     */\n\n\n    var EventPluginUtils = {\n      isEndish: isEndish,\n      isMoveish: isMoveish,\n      isStartish: isStartish,\n      executeDirectDispatch: executeDirectDispatch,\n      executeDispatchesInOrder: executeDispatchesInOrder,\n      executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,\n      hasDispatches: hasDispatches,\n      getFiberCurrentPropsFromNode: function getFiberCurrentPropsFromNode(node) {\n        return ComponentTree.getFiberCurrentPropsFromNode(node);\n      },\n      getInstanceFromNode: function getInstanceFromNode(node) {\n        return ComponentTree.getInstanceFromNode(node);\n      },\n      getNodeFromInstance: function getNodeFromInstance(node) {\n        return ComponentTree.getNodeFromInstance(node);\n      },\n      injection: injection\n    };\n    var EventPluginUtils_1 = EventPluginUtils; // Use to restore controlled state after a change event has fired.\n\n    var fiberHostComponent = null;\n    var ReactControlledComponentInjection = {\n      injectFiberControlledHostComponent: function injectFiberControlledHostComponent(hostComponentImpl) {\n        // The fiber implementation doesn't use dynamic dispatch so we need to\n        // inject the implementation.\n        fiberHostComponent = hostComponentImpl;\n      }\n    };\n    var restoreTarget = null;\n    var restoreQueue = null;\n\n    function restoreStateOfTarget(target) {\n      // We perform this translation at the end of the event loop so that we\n      // always receive the correct fiber here\n      var internalInstance = EventPluginUtils_1.getInstanceFromNode(target);\n\n      if (!internalInstance) {\n        // Unmounted\n        return;\n      }\n\n      if (typeof internalInstance.tag === 'number') {\n        !(fiberHostComponent && typeof fiberHostComponent.restoreControlledState === 'function') ? invariant(false, 'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        var props = EventPluginUtils_1.getFiberCurrentPropsFromNode(internalInstance.stateNode);\n        fiberHostComponent.restoreControlledState(internalInstance.stateNode, internalInstance.type, props);\n        return;\n      }\n\n      !(typeof internalInstance.restoreControlledState === 'function') ? invariant(false, 'The internal instance must be a React host component. This error is likely caused by a bug in React. Please file an issue.') : void 0; // If it is not a Fiber, we can just use dynamic dispatch.\n\n      internalInstance.restoreControlledState();\n    }\n\n    var ReactControlledComponent = {\n      injection: ReactControlledComponentInjection,\n      enqueueStateRestore: function enqueueStateRestore(target) {\n        if (restoreTarget) {\n          if (restoreQueue) {\n            restoreQueue.push(target);\n          } else {\n            restoreQueue = [target];\n          }\n        } else {\n          restoreTarget = target;\n        }\n      },\n      restoreStateIfNeeded: function restoreStateIfNeeded() {\n        if (!restoreTarget) {\n          return;\n        }\n\n        var target = restoreTarget;\n        var queuedTargets = restoreQueue;\n        restoreTarget = null;\n        restoreQueue = null;\n        restoreStateOfTarget(target);\n\n        if (queuedTargets) {\n          for (var i = 0; i < queuedTargets.length; i++) {\n            restoreStateOfTarget(queuedTargets[i]);\n          }\n        }\n      }\n    };\n    var ReactControlledComponent_1 = ReactControlledComponent; // Used as a way to call batchedUpdates when we don't know if we're in a Fiber\n    // or Stack context. Such as when we're dispatching events or if third party\n    // libraries need to call batchedUpdates. Eventually, this API will go away when\n    // everything is batched by default. We'll then have a similar API to opt-out of\n    // scheduled work and instead do synchronous work.\n    // Defaults\n\n    var stackBatchedUpdates = function stackBatchedUpdates(fn, a, b, c, d, e) {\n      return fn(a, b, c, d, e);\n    };\n\n    var fiberBatchedUpdates = function fiberBatchedUpdates(fn, bookkeeping) {\n      return fn(bookkeeping);\n    };\n\n    function performFiberBatchedUpdates(fn, bookkeeping) {\n      // If we have Fiber loaded, we need to wrap this in a batching call so that\n      // Fiber can apply its default priority for this call.\n      return fiberBatchedUpdates(fn, bookkeeping);\n    }\n\n    function batchedUpdates(fn, bookkeeping) {\n      // We first perform work with the stack batching strategy, by passing our\n      // indirection to it.\n      return stackBatchedUpdates(performFiberBatchedUpdates, fn, bookkeeping);\n    }\n\n    var isNestingBatched = false;\n\n    function batchedUpdatesWithControlledComponents(fn, bookkeeping) {\n      if (isNestingBatched) {\n        // If we are currently inside another batch, we need to wait until it\n        // fully completes before restoring state. Therefore, we add the target to\n        // a queue of work.\n        return batchedUpdates(fn, bookkeeping);\n      }\n\n      isNestingBatched = true;\n\n      try {\n        return batchedUpdates(fn, bookkeeping);\n      } finally {\n        // Here we wait until all updates have propagated, which is important\n        // when using controlled components within layers:\n        // https://github.com/facebook/react/issues/1698\n        // Then we restore state of any controlled component.\n        isNestingBatched = false;\n        ReactControlledComponent_1.restoreStateIfNeeded();\n      }\n    }\n\n    var ReactGenericBatchingInjection = {\n      injectStackBatchedUpdates: function injectStackBatchedUpdates(_batchedUpdates) {\n        stackBatchedUpdates = _batchedUpdates;\n      },\n      injectFiberBatchedUpdates: function injectFiberBatchedUpdates(_batchedUpdates) {\n        fiberBatchedUpdates = _batchedUpdates;\n      }\n    };\n    var ReactGenericBatching = {\n      batchedUpdates: batchedUpdatesWithControlledComponents,\n      injection: ReactGenericBatchingInjection\n    };\n    var ReactGenericBatching_1 = ReactGenericBatching;\n    var TEXT_NODE$1 = HTMLNodeType_1.TEXT_NODE;\n    /**\n     * Gets the target node from a native browser event by accounting for\n     * inconsistencies in browser DOM APIs.\n     *\n     * @param {object} nativeEvent Native browser event.\n     * @return {DOMEventTarget} Target node.\n     */\n\n    function getEventTarget(nativeEvent) {\n      var target = nativeEvent.target || nativeEvent.srcElement || window; // Normalize SVG <use> element events #4963\n\n      if (target.correspondingUseElement) {\n        target = target.correspondingUseElement;\n      } // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n      // @see http://www.quirksmode.org/js/events_properties.html\n\n\n      return target.nodeType === TEXT_NODE$1 ? target.parentNode : target;\n    }\n\n    var getEventTarget_1 = getEventTarget;\n    var HostRoot = ReactTypeOfWork.HostRoot;\n    var CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\n    var callbackBookkeepingPool = [];\n    /**\n     * Find the deepest React component completely containing the root of the\n     * passed-in instance (for use when entire React trees are nested within each\n     * other). If React trees are not nested, returns null.\n     */\n\n    function findRootContainerNode(inst) {\n      // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n      // traversal, but caching is difficult to do correctly without using a\n      // mutation observer to listen for all DOM changes.\n      if (typeof inst.tag === 'number') {\n        while (inst['return']) {\n          inst = inst['return'];\n        }\n\n        if (inst.tag !== HostRoot) {\n          // This can happen if we're in a detached tree.\n          return null;\n        }\n\n        return inst.stateNode.containerInfo;\n      } else {\n        while (inst._hostParent) {\n          inst = inst._hostParent;\n        }\n\n        var rootNode = ReactDOMComponentTree_1.getNodeFromInstance(inst);\n        return rootNode.parentNode;\n      }\n    } // Used to store ancestor hierarchy in top level callback\n\n\n    function getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {\n      if (callbackBookkeepingPool.length) {\n        var instance = callbackBookkeepingPool.pop();\n        instance.topLevelType = topLevelType;\n        instance.nativeEvent = nativeEvent;\n        instance.targetInst = targetInst;\n        return instance;\n      }\n\n      return {\n        topLevelType: topLevelType,\n        nativeEvent: nativeEvent,\n        targetInst: targetInst,\n        ancestors: []\n      };\n    }\n\n    function releaseTopLevelCallbackBookKeeping(instance) {\n      instance.topLevelType = null;\n      instance.nativeEvent = null;\n      instance.targetInst = null;\n      instance.ancestors.length = 0;\n\n      if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n        callbackBookkeepingPool.push(instance);\n      }\n    }\n\n    function handleTopLevelImpl(bookKeeping) {\n      var targetInst = bookKeeping.targetInst; // Loop through the hierarchy, in case there's any nested components.\n      // It's important that we build the array of ancestors before calling any\n      // event handlers, because event handlers can modify the DOM, leading to\n      // inconsistencies with ReactMount's node cache. See #1105.\n\n      var ancestor = targetInst;\n\n      do {\n        if (!ancestor) {\n          bookKeeping.ancestors.push(ancestor);\n          break;\n        }\n\n        var root = findRootContainerNode(ancestor);\n\n        if (!root) {\n          break;\n        }\n\n        bookKeeping.ancestors.push(ancestor);\n        ancestor = ReactDOMComponentTree_1.getClosestInstanceFromNode(root);\n      } while (ancestor);\n\n      for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n        targetInst = bookKeeping.ancestors[i];\n\n        ReactDOMEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget_1(bookKeeping.nativeEvent));\n      }\n    }\n\n    var ReactDOMEventListener = {\n      _enabled: true,\n      _handleTopLevel: null,\n      setHandleTopLevel: function setHandleTopLevel(handleTopLevel) {\n        ReactDOMEventListener._handleTopLevel = handleTopLevel;\n      },\n      setEnabled: function setEnabled(enabled) {\n        ReactDOMEventListener._enabled = !!enabled;\n      },\n      isEnabled: function isEnabled() {\n        return ReactDOMEventListener._enabled;\n      },\n\n      /**\n       * Traps top-level events by using event bubbling.\n       *\n       * @param {string} topLevelType Record from `BrowserEventConstants`.\n       * @param {string} handlerBaseName Event name (e.g. \"click\").\n       * @param {object} element Element on which to attach listener.\n       * @return {?object} An object with a remove function which will forcefully\n       *                  remove the listener.\n       * @internal\n       */\n      trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, element) {\n        if (!element) {\n          return null;\n        }\n\n        return EventListener.listen(element, handlerBaseName, ReactDOMEventListener.dispatchEvent.bind(null, topLevelType));\n      },\n\n      /**\n       * Traps a top-level event by using event capturing.\n       *\n       * @param {string} topLevelType Record from `BrowserEventConstants`.\n       * @param {string} handlerBaseName Event name (e.g. \"click\").\n       * @param {object} element Element on which to attach listener.\n       * @return {?object} An object with a remove function which will forcefully\n       *                  remove the listener.\n       * @internal\n       */\n      trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, element) {\n        if (!element) {\n          return null;\n        }\n\n        return EventListener.capture(element, handlerBaseName, ReactDOMEventListener.dispatchEvent.bind(null, topLevelType));\n      },\n      dispatchEvent: function dispatchEvent(topLevelType, nativeEvent) {\n        if (!ReactDOMEventListener._enabled) {\n          return;\n        }\n\n        var nativeEventTarget = getEventTarget_1(nativeEvent);\n        var targetInst = ReactDOMComponentTree_1.getClosestInstanceFromNode(nativeEventTarget);\n\n        if (targetInst !== null && typeof targetInst.tag === 'number' && !ReactFiberTreeReflection.isFiberMounted(targetInst)) {\n          // If we get an event (ex: img onload) before committing that\n          // component's mount, ignore it for now (that is, treat it as if it was an\n          // event on a non-React tree). We might also consider queueing events and\n          // dispatching them after the mount.\n          targetInst = null;\n        }\n\n        var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);\n\n        try {\n          // Event queue being processed in the same cycle allows\n          // `preventDefault`.\n          ReactGenericBatching_1.batchedUpdates(handleTopLevelImpl, bookKeeping);\n        } finally {\n          releaseTopLevelCallbackBookKeeping(bookKeeping);\n        }\n      }\n    };\n    var ReactDOMEventListener_1 = ReactDOMEventListener;\n    /**\n     * Accumulates items that must not be null or undefined into the first one. This\n     * is used to conserve memory by avoiding array allocations, and thus sacrifices\n     * API cleanness. Since `current` can be null before being passed in and not\n     * null after this function, make sure to assign it back to `current`:\n     *\n     * `a = accumulateInto(a, b);`\n     *\n     * This API should be sparingly used. Try `accumulate` for something cleaner.\n     *\n     * @return {*|array<*>} An accumulation of items.\n     */\n\n    function accumulateInto(current, next) {\n      !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;\n\n      if (current == null) {\n        return next;\n      } // Both are not empty. Warning: Never call x.concat(y) when you are not\n      // certain that x is an Array (x could be a string with concat method).\n\n\n      if (Array.isArray(current)) {\n        if (Array.isArray(next)) {\n          current.push.apply(current, next);\n          return current;\n        }\n\n        current.push(next);\n        return current;\n      }\n\n      if (Array.isArray(next)) {\n        // A bit too dangerous to mutate `next`.\n        return [current].concat(next);\n      }\n\n      return [current, next];\n    }\n\n    var accumulateInto_1 = accumulateInto;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule forEachAccumulated\n     * \n     */\n\n    /**\n     * @param {array} arr an \"accumulation\" of items which is either an Array or\n     * a single item. Useful when paired with the `accumulate` module. This is a\n     * simple utility that allows us to reason about a collection of items, but\n     * handling the case when there is exactly one item (and we do not need to\n     * allocate an array).\n     * @param {function} cb Callback invoked with each element or a collection.\n     * @param {?} [scope] Scope used as `this` in a callback.\n     */\n\n    function forEachAccumulated(arr, cb, scope) {\n      if (Array.isArray(arr)) {\n        arr.forEach(cb, scope);\n      } else if (arr) {\n        cb.call(scope, arr);\n      }\n    }\n\n    var forEachAccumulated_1 = forEachAccumulated;\n    /**\n     * Internal queue of events that have accumulated their dispatches and are\n     * waiting to have their dispatches executed.\n     */\n\n    var eventQueue = null;\n    /**\n     * Dispatches an event and releases it back into the pool, unless persistent.\n     *\n     * @param {?object} event Synthetic event to be dispatched.\n     * @param {boolean} simulated If the event is simulated (changes exn behavior)\n     * @private\n     */\n\n    var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {\n      if (event) {\n        EventPluginUtils_1.executeDispatchesInOrder(event, simulated);\n\n        if (!event.isPersistent()) {\n          event.constructor.release(event);\n        }\n      }\n    };\n\n    var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {\n      return executeDispatchesAndRelease(e, true);\n    };\n\n    var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {\n      return executeDispatchesAndRelease(e, false);\n    };\n\n    function isInteractive(tag) {\n      return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n    }\n\n    function shouldPreventMouseEvent(name, type, props) {\n      switch (name) {\n        case 'onClick':\n        case 'onClickCapture':\n        case 'onDoubleClick':\n        case 'onDoubleClickCapture':\n        case 'onMouseDown':\n        case 'onMouseDownCapture':\n        case 'onMouseMove':\n        case 'onMouseMoveCapture':\n        case 'onMouseUp':\n        case 'onMouseUpCapture':\n          return !!(props.disabled && isInteractive(type));\n\n        default:\n          return false;\n      }\n    }\n    /**\n     * This is a unified interface for event plugins to be installed and configured.\n     *\n     * Event plugins can implement the following properties:\n     *\n     *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n     *     Required. When a top-level event is fired, this method is expected to\n     *     extract synthetic events that will in turn be queued and dispatched.\n     *\n     *   `eventTypes` {object}\n     *     Optional, plugins that fire events must publish a mapping of registration\n     *     names that are used to register listeners. Values of this mapping must\n     *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n     *\n     *   `executeDispatch` {function(object, function, string)}\n     *     Optional, allows plugins to override how an event gets dispatched. By\n     *     default, the listener is simply invoked.\n     *\n     * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n     *\n     * @public\n     */\n\n\n    var EventPluginHub = {\n      /**\n       * Methods for injecting dependencies.\n       */\n      injection: {\n        /**\n         * @param {array} InjectedEventPluginOrder\n         * @public\n         */\n        injectEventPluginOrder: EventPluginRegistry_1.injectEventPluginOrder,\n\n        /**\n         * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n         */\n        injectEventPluginsByName: EventPluginRegistry_1.injectEventPluginsByName\n      },\n\n      /**\n       * @param {object} inst The instance, which is the source of events.\n       * @param {string} registrationName Name of listener (e.g. `onClick`).\n       * @return {?function} The stored callback.\n       */\n      getListener: function getListener(inst, registrationName) {\n        var listener; // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n        // live here; needs to be moved to a better place soon\n\n        if (typeof inst.tag === 'number') {\n          var stateNode = inst.stateNode;\n\n          if (!stateNode) {\n            // Work in progress (ex: onload events in incremental mode).\n            return null;\n          }\n\n          var props = EventPluginUtils_1.getFiberCurrentPropsFromNode(stateNode);\n\n          if (!props) {\n            // Work in progress.\n            return null;\n          }\n\n          listener = props[registrationName];\n\n          if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n            return null;\n          }\n        } else {\n          var currentElement = inst._currentElement;\n\n          if (typeof currentElement === 'string' || typeof currentElement === 'number') {\n            // Text node, let it bubble through.\n            return null;\n          }\n\n          if (!inst._rootNodeID) {\n            // If the instance is already unmounted, we have no listeners.\n            return null;\n          }\n\n          var _props = currentElement.props;\n          listener = _props[registrationName];\n\n          if (shouldPreventMouseEvent(registrationName, currentElement.type, _props)) {\n            return null;\n          }\n        }\n\n        !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;\n        return listener;\n      },\n\n      /**\n       * Allows registered plugins an opportunity to extract events from top-level\n       * native browser events.\n       *\n       * @return {*} An accumulation of synthetic events.\n       * @internal\n       */\n      extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        var events;\n        var plugins = EventPluginRegistry_1.plugins;\n\n        for (var i = 0; i < plugins.length; i++) {\n          // Not every plugin in the ordering may be loaded at runtime.\n          var possiblePlugin = plugins[i];\n\n          if (possiblePlugin) {\n            var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n\n            if (extractedEvents) {\n              events = accumulateInto_1(events, extractedEvents);\n            }\n          }\n        }\n\n        return events;\n      },\n\n      /**\n       * Enqueues a synthetic event that should be dispatched when\n       * `processEventQueue` is invoked.\n       *\n       * @param {*} events An accumulation of synthetic events.\n       * @internal\n       */\n      enqueueEvents: function enqueueEvents(events) {\n        if (events) {\n          eventQueue = accumulateInto_1(eventQueue, events);\n        }\n      },\n\n      /**\n       * Dispatches all synthetic events on the event queue.\n       *\n       * @internal\n       */\n      processEventQueue: function processEventQueue(simulated) {\n        // Set `eventQueue` to null before processing it so that we can tell if more\n        // events get enqueued while processing.\n        var processingEventQueue = eventQueue;\n        eventQueue = null;\n\n        if (simulated) {\n          forEachAccumulated_1(processingEventQueue, executeDispatchesAndReleaseSimulated);\n        } else {\n          forEachAccumulated_1(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n        }\n\n        !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0; // This would be a good time to rethrow if any of the event handlers threw.\n\n        ReactErrorUtils_1.rethrowCaughtError();\n      }\n    };\n    var EventPluginHub_1 = EventPluginHub;\n\n    function runEventQueueInBatch(events) {\n      EventPluginHub_1.enqueueEvents(events);\n      EventPluginHub_1.processEventQueue(false);\n    }\n\n    var ReactEventEmitterMixin = {\n      /**\n       * Streams a fired top-level event to `EventPluginHub` where plugins have the\n       * opportunity to create `ReactEvent`s to be dispatched.\n       */\n      handleTopLevel: function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        var events = EventPluginHub_1.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n        runEventQueueInBatch(events);\n      }\n    };\n    var ReactEventEmitterMixin_1 = ReactEventEmitterMixin;\n    var useHasFeature;\n\n    if (ExecutionEnvironment.canUseDOM) {\n      useHasFeature = document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.\n      // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n      document.implementation.hasFeature('', '') !== true;\n    }\n    /**\n     * Checks if an event is supported in the current execution environment.\n     *\n     * NOTE: This will not work correctly for non-generic events such as `change`,\n     * `reset`, `load`, `error`, and `select`.\n     *\n     * Borrows from Modernizr.\n     *\n     * @param {string} eventNameSuffix Event name, e.g. \"click\".\n     * @param {?boolean} capture Check if the capture phase is supported.\n     * @return {boolean} True if the event is supported.\n     * @internal\n     * @license Modernizr 3.0.0pre (Custom Build) | MIT\n     */\n\n\n    function isEventSupported(eventNameSuffix, capture) {\n      if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {\n        return false;\n      }\n\n      var eventName = 'on' + eventNameSuffix;\n      var isSupported = eventName in document;\n\n      if (!isSupported) {\n        var element = document.createElement('div');\n        element.setAttribute(eventName, 'return;');\n        isSupported = typeof element[eventName] === 'function';\n      }\n\n      if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {\n        // This is the only way to test support for the `wheel` event in IE9+.\n        isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n      }\n\n      return isSupported;\n    }\n\n    var isEventSupported_1 = isEventSupported;\n    /**\n     * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n     *\n     * @param {string} styleProp\n     * @param {string} eventName\n     * @returns {object}\n     */\n\n    function makePrefixMap(styleProp, eventName) {\n      var prefixes = {};\n      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n      prefixes['Webkit' + styleProp] = 'webkit' + eventName;\n      prefixes['Moz' + styleProp] = 'moz' + eventName;\n      prefixes['ms' + styleProp] = 'MS' + eventName;\n      prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();\n      return prefixes;\n    }\n    /**\n     * A list of event names to a configurable list of vendor prefixes.\n     */\n\n\n    var vendorPrefixes = {\n      animationend: makePrefixMap('Animation', 'AnimationEnd'),\n      animationiteration: makePrefixMap('Animation', 'AnimationIteration'),\n      animationstart: makePrefixMap('Animation', 'AnimationStart'),\n      transitionend: makePrefixMap('Transition', 'TransitionEnd')\n    };\n    /**\n     * Event names that have already been detected and prefixed (if applicable).\n     */\n\n    var prefixedEventNames = {};\n    /**\n     * Element to check for prefixes on.\n     */\n\n    var style = {};\n    /**\n     * Bootstrap if a DOM exists.\n     */\n\n    if (ExecutionEnvironment.canUseDOM) {\n      style = document.createElement('div').style; // On some platforms, in particular some releases of Android 4.x,\n      // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n      // style object but the events that fire will still be prefixed, so we need\n      // to check if the un-prefixed events are usable, and if not remove them from the map.\n\n      if (!('AnimationEvent' in window)) {\n        delete vendorPrefixes.animationend.animation;\n        delete vendorPrefixes.animationiteration.animation;\n        delete vendorPrefixes.animationstart.animation;\n      } // Same as above\n\n\n      if (!('TransitionEvent' in window)) {\n        delete vendorPrefixes.transitionend.transition;\n      }\n    }\n    /**\n     * Attempts to determine the correct vendor prefixed event name.\n     *\n     * @param {string} eventName\n     * @returns {string}\n     */\n\n\n    function getVendorPrefixedEventName(eventName) {\n      if (prefixedEventNames[eventName]) {\n        return prefixedEventNames[eventName];\n      } else if (!vendorPrefixes[eventName]) {\n        return eventName;\n      }\n\n      var prefixMap = vendorPrefixes[eventName];\n\n      for (var styleProp in prefixMap) {\n        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n          return prefixedEventNames[eventName] = prefixMap[styleProp];\n        }\n      }\n\n      return '';\n    }\n\n    var getVendorPrefixedEventName_1 = getVendorPrefixedEventName;\n    /**\n     * Types of raw signals from the browser caught at the top level.\n     *\n     * For events like 'submit' which don't consistently bubble (which we\n     * trap at a lower node than `document`), binding at `document` would\n     * cause duplicate events so we don't include them here.\n     */\n\n    var topLevelTypes$1 = {\n      topAbort: 'abort',\n      topAnimationEnd: getVendorPrefixedEventName_1('animationend') || 'animationend',\n      topAnimationIteration: getVendorPrefixedEventName_1('animationiteration') || 'animationiteration',\n      topAnimationStart: getVendorPrefixedEventName_1('animationstart') || 'animationstart',\n      topBlur: 'blur',\n      topCancel: 'cancel',\n      topCanPlay: 'canplay',\n      topCanPlayThrough: 'canplaythrough',\n      topChange: 'change',\n      topClick: 'click',\n      topClose: 'close',\n      topCompositionEnd: 'compositionend',\n      topCompositionStart: 'compositionstart',\n      topCompositionUpdate: 'compositionupdate',\n      topContextMenu: 'contextmenu',\n      topCopy: 'copy',\n      topCut: 'cut',\n      topDoubleClick: 'dblclick',\n      topDrag: 'drag',\n      topDragEnd: 'dragend',\n      topDragEnter: 'dragenter',\n      topDragExit: 'dragexit',\n      topDragLeave: 'dragleave',\n      topDragOver: 'dragover',\n      topDragStart: 'dragstart',\n      topDrop: 'drop',\n      topDurationChange: 'durationchange',\n      topEmptied: 'emptied',\n      topEncrypted: 'encrypted',\n      topEnded: 'ended',\n      topError: 'error',\n      topFocus: 'focus',\n      topInput: 'input',\n      topKeyDown: 'keydown',\n      topKeyPress: 'keypress',\n      topKeyUp: 'keyup',\n      topLoadedData: 'loadeddata',\n      topLoad: 'load',\n      topLoadedMetadata: 'loadedmetadata',\n      topLoadStart: 'loadstart',\n      topMouseDown: 'mousedown',\n      topMouseMove: 'mousemove',\n      topMouseOut: 'mouseout',\n      topMouseOver: 'mouseover',\n      topMouseUp: 'mouseup',\n      topPaste: 'paste',\n      topPause: 'pause',\n      topPlay: 'play',\n      topPlaying: 'playing',\n      topProgress: 'progress',\n      topRateChange: 'ratechange',\n      topScroll: 'scroll',\n      topSeeked: 'seeked',\n      topSeeking: 'seeking',\n      topSelectionChange: 'selectionchange',\n      topStalled: 'stalled',\n      topSuspend: 'suspend',\n      topTextInput: 'textInput',\n      topTimeUpdate: 'timeupdate',\n      topToggle: 'toggle',\n      topTouchCancel: 'touchcancel',\n      topTouchEnd: 'touchend',\n      topTouchMove: 'touchmove',\n      topTouchStart: 'touchstart',\n      topTransitionEnd: getVendorPrefixedEventName_1('transitionend') || 'transitionend',\n      topVolumeChange: 'volumechange',\n      topWaiting: 'waiting',\n      topWheel: 'wheel'\n    };\n    var BrowserEventConstants = {\n      topLevelTypes: topLevelTypes$1\n    };\n    var BrowserEventConstants_1 = BrowserEventConstants;\n    var topLevelTypes = BrowserEventConstants_1.topLevelTypes;\n    /**\n     * Summary of `ReactBrowserEventEmitter` event handling:\n     *\n     *  - Top-level delegation is used to trap most native browser events. This\n     *    may only occur in the main thread and is the responsibility of\n     *    ReactDOMEventListener, which is injected and can therefore support\n     *    pluggable event sources. This is the only work that occurs in the main\n     *    thread.\n     *\n     *  - We normalize and de-duplicate events to account for browser quirks. This\n     *    may be done in the worker thread.\n     *\n     *  - Forward these native events (with the associated top-level type used to\n     *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n     *    to extract any synthetic events.\n     *\n     *  - The `EventPluginHub` will then process each event by annotating them with\n     *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n     *\n     *  - The `EventPluginHub` then dispatches the events.\n     *\n     * Overview of React and the event system:\n     *\n     * +------------+    .\n     * |    DOM     |    .\n     * +------------+    .\n     *       |           .\n     *       v           .\n     * +------------+    .\n     * | ReactEvent |    .\n     * |  Listener  |    .\n     * +------------+    .                         +-----------+\n     *       |           .               +--------+|SimpleEvent|\n     *       |           .               |         |Plugin     |\n     * +-----|------+    .               v         +-----------+\n     * |     |      |    .    +--------------+                    +------------+\n     * |     +-----------.--->|EventPluginHub|                    |    Event   |\n     * |            |    .    |              |     +-----------+  | Propagators|\n     * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n     * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n     * |            |    .    |              |     +-----------+  |  utilities |\n     * |     +-----------.--->|              |                    +------------+\n     * |     |      |    .    +--------------+\n     * +-----|------+    .                ^        +-----------+\n     *       |           .                |        |Enter/Leave|\n     *       +           .                +-------+|Plugin     |\n     * +-------------+   .                         +-----------+\n     * | application |   .\n     * |-------------|   .\n     * |             |   .\n     * |             |   .\n     * +-------------+   .\n     *                   .\n     *    React Core     .  General Purpose Event Plugin System\n     */\n\n    var alreadyListeningTo = {};\n    var reactTopListenersCounter = 0;\n    /**\n     * To ensure no conflicts with other potential React instances on the page\n     */\n\n    var topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);\n\n    function getListeningForDocument(mountAt) {\n      // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n      // directly.\n      if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\n        mountAt[topListenersIDKey] = reactTopListenersCounter++;\n        alreadyListeningTo[mountAt[topListenersIDKey]] = {};\n      }\n\n      return alreadyListeningTo[mountAt[topListenersIDKey]];\n    }\n\n    var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin_1, {\n      /**\n       * Sets whether or not any created callbacks should be enabled.\n       *\n       * @param {boolean} enabled True if callbacks should be enabled.\n       */\n      setEnabled: function setEnabled(enabled) {\n        if (ReactDOMEventListener_1) {\n          ReactDOMEventListener_1.setEnabled(enabled);\n        }\n      },\n\n      /**\n       * @return {boolean} True if callbacks are enabled.\n       */\n      isEnabled: function isEnabled() {\n        return !!(ReactDOMEventListener_1 && ReactDOMEventListener_1.isEnabled());\n      },\n\n      /**\n       * We listen for bubbled touch events on the document object.\n       *\n       * Firefox v8.01 (and possibly others) exhibited strange behavior when\n       * mounting `onmousemove` events at some node that was not the document\n       * element. The symptoms were that if your mouse is not moving over something\n       * contained within that mount point (for example on the background) the\n       * top-level listeners for `onmousemove` won't be called. However, if you\n       * register the `mousemove` on the document object, then it will of course\n       * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n       * top-level listeners to the document object only, at least for these\n       * movement types of events and possibly all events.\n       *\n       * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n       *\n       * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n       * they bubble to document.\n       *\n       * @param {string} registrationName Name of listener (e.g. `onClick`).\n       * @param {object} contentDocumentHandle Document which owns the container\n       */\n      listenTo: function listenTo(registrationName, contentDocumentHandle) {\n        var mountAt = contentDocumentHandle;\n        var isListening = getListeningForDocument(mountAt);\n        var dependencies = EventPluginRegistry_1.registrationNameDependencies[registrationName];\n\n        for (var i = 0; i < dependencies.length; i++) {\n          var dependency = dependencies[i];\n\n          if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n            if (dependency === 'topWheel') {\n              if (isEventSupported_1('wheel')) {\n                ReactDOMEventListener_1.trapBubbledEvent('topWheel', 'wheel', mountAt);\n              } else if (isEventSupported_1('mousewheel')) {\n                ReactDOMEventListener_1.trapBubbledEvent('topWheel', 'mousewheel', mountAt);\n              } else {\n                // Firefox needs to capture a different mouse scroll event.\n                // @see http://www.quirksmode.org/dom/events/tests/scroll.html\n                ReactDOMEventListener_1.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);\n              }\n            } else if (dependency === 'topScroll') {\n              ReactDOMEventListener_1.trapCapturedEvent('topScroll', 'scroll', mountAt);\n            } else if (dependency === 'topFocus' || dependency === 'topBlur') {\n              ReactDOMEventListener_1.trapCapturedEvent('topFocus', 'focus', mountAt);\n              ReactDOMEventListener_1.trapCapturedEvent('topBlur', 'blur', mountAt); // to make sure blur and focus event listeners are only attached once\n\n              isListening.topBlur = true;\n              isListening.topFocus = true;\n            } else if (dependency === 'topCancel') {\n              if (isEventSupported_1('cancel', true)) {\n                ReactDOMEventListener_1.trapCapturedEvent('topCancel', 'cancel', mountAt);\n              }\n\n              isListening.topCancel = true;\n            } else if (dependency === 'topClose') {\n              if (isEventSupported_1('close', true)) {\n                ReactDOMEventListener_1.trapCapturedEvent('topClose', 'close', mountAt);\n              }\n\n              isListening.topClose = true;\n            } else if (topLevelTypes.hasOwnProperty(dependency)) {\n              ReactDOMEventListener_1.trapBubbledEvent(dependency, topLevelTypes[dependency], mountAt);\n            }\n\n            isListening[dependency] = true;\n          }\n        }\n      },\n      isListeningToAllDependencies: function isListeningToAllDependencies(registrationName, mountAt) {\n        var isListening = getListeningForDocument(mountAt);\n        var dependencies = EventPluginRegistry_1.registrationNameDependencies[registrationName];\n\n        for (var i = 0; i < dependencies.length; i++) {\n          var dependency = dependencies[i];\n\n          if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n            return false;\n          }\n        }\n\n        return true;\n      },\n      trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {\n        return ReactDOMEventListener_1.trapBubbledEvent(topLevelType, handlerBaseName, handle);\n      },\n      trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {\n        return ReactDOMEventListener_1.trapCapturedEvent(topLevelType, handlerBaseName, handle);\n      }\n    });\n\n    var ReactBrowserEventEmitter_1 = ReactBrowserEventEmitter;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule ReactDOMFeatureFlags\n     */\n\n    var ReactDOMFeatureFlags = {\n      fiberAsyncScheduling: false,\n      useFiber: true\n    };\n    var ReactDOMFeatureFlags_1 = ReactDOMFeatureFlags;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule CSSProperty\n     */\n\n    /**\n     * CSS properties which accept numbers but are not in units of \"px\".\n     */\n\n    var isUnitlessNumber = {\n      animationIterationCount: true,\n      borderImageOutset: true,\n      borderImageSlice: true,\n      borderImageWidth: true,\n      boxFlex: true,\n      boxFlexGroup: true,\n      boxOrdinalGroup: true,\n      columnCount: true,\n      columns: true,\n      flex: true,\n      flexGrow: true,\n      flexPositive: true,\n      flexShrink: true,\n      flexNegative: true,\n      flexOrder: true,\n      gridRow: true,\n      gridRowEnd: true,\n      gridRowSpan: true,\n      gridRowStart: true,\n      gridColumn: true,\n      gridColumnEnd: true,\n      gridColumnSpan: true,\n      gridColumnStart: true,\n      fontWeight: true,\n      lineClamp: true,\n      lineHeight: true,\n      opacity: true,\n      order: true,\n      orphans: true,\n      tabSize: true,\n      widows: true,\n      zIndex: true,\n      zoom: true,\n      // SVG-related properties\n      fillOpacity: true,\n      floodOpacity: true,\n      stopOpacity: true,\n      strokeDasharray: true,\n      strokeDashoffset: true,\n      strokeMiterlimit: true,\n      strokeOpacity: true,\n      strokeWidth: true\n    };\n    /**\n     * @param {string} prefix vendor-specific prefix, eg: Webkit\n     * @param {string} key style name, eg: transitionDuration\n     * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n     * WebkitTransitionDuration\n     */\n\n    function prefixKey(prefix, key) {\n      return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n    }\n    /**\n     * Support style names that may come passed in prefixed by adding permutations\n     * of vendor prefixes.\n     */\n\n\n    var prefixes = ['Webkit', 'ms', 'Moz', 'O']; // Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n    // infinite loop, because it iterates over the newly added props too.\n\n    Object.keys(isUnitlessNumber).forEach(function (prop) {\n      prefixes.forEach(function (prefix) {\n        isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n      });\n    });\n    /**\n     * Most style properties can be unset by doing .style[prop] = '' but IE8\n     * doesn't like doing that with shorthand properties so for the properties that\n     * IE8 breaks on, which are listed here, we instead unset each of the\n     * individual properties. See http://bugs.jquery.com/ticket/12385.\n     * The 4-value 'clock' properties like margin, padding, border-width seem to\n     * behave without any problems. Curiously, list-style works too without any\n     * special prodding.\n     */\n\n    var shorthandPropertyExpansions = {\n      background: {\n        backgroundAttachment: true,\n        backgroundColor: true,\n        backgroundImage: true,\n        backgroundPositionX: true,\n        backgroundPositionY: true,\n        backgroundRepeat: true\n      },\n      backgroundPosition: {\n        backgroundPositionX: true,\n        backgroundPositionY: true\n      },\n      border: {\n        borderWidth: true,\n        borderStyle: true,\n        borderColor: true\n      },\n      borderBottom: {\n        borderBottomWidth: true,\n        borderBottomStyle: true,\n        borderBottomColor: true\n      },\n      borderLeft: {\n        borderLeftWidth: true,\n        borderLeftStyle: true,\n        borderLeftColor: true\n      },\n      borderRight: {\n        borderRightWidth: true,\n        borderRightStyle: true,\n        borderRightColor: true\n      },\n      borderTop: {\n        borderTopWidth: true,\n        borderTopStyle: true,\n        borderTopColor: true\n      },\n      font: {\n        fontStyle: true,\n        fontVariant: true,\n        fontWeight: true,\n        fontSize: true,\n        lineHeight: true,\n        fontFamily: true\n      },\n      outline: {\n        outlineWidth: true,\n        outlineStyle: true,\n        outlineColor: true\n      }\n    };\n    var CSSProperty = {\n      isUnitlessNumber: isUnitlessNumber,\n      shorthandPropertyExpansions: shorthandPropertyExpansions\n    };\n    var CSSProperty_1 = CSSProperty;\n    var isUnitlessNumber$1 = CSSProperty_1.isUnitlessNumber;\n    /**\n     * Convert a value into the proper css writable value. The style name `name`\n     * should be logical (no hyphens), as specified\n     * in `CSSProperty.isUnitlessNumber`.\n     *\n     * @param {string} name CSS property name such as `topMargin`.\n     * @param {*} value CSS property value such as `10px`.\n     * @return {string} Normalized style value with dimensions applied.\n     */\n\n    function dangerousStyleValue(name, value, isCustomProperty) {\n      // Note that we've removed escapeTextForBrowser() calls here since the\n      // whole string will be escaped when the attribute is injected into\n      // the markup. If you provide unsafe user data here they can inject\n      // arbitrary CSS which may be problematic (I couldn't repro this):\n      // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n      // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n      // This is not an XSS hole but instead a potential CSS injection issue\n      // which has lead to a greater discussion about how we're going to\n      // trust URLs moving forward. See #2115901\n      var isEmpty = value == null || typeof value === 'boolean' || value === '';\n\n      if (isEmpty) {\n        return '';\n      }\n\n      if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber$1.hasOwnProperty(name) && isUnitlessNumber$1[name])) {\n        return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n      }\n\n      return ('' + value).trim();\n    }\n\n    var dangerousStyleValue_1 = dangerousStyleValue;\n    /**\n     * Copyright (c) 2016-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * \n     * @providesModule describeComponentFrame\n     */\n\n    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {\n      return '\\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');\n    };\n\n    var IndeterminateComponent = ReactTypeOfWork.IndeterminateComponent;\n    var FunctionalComponent = ReactTypeOfWork.FunctionalComponent;\n    var ClassComponent$1 = ReactTypeOfWork.ClassComponent;\n    var HostComponent$2 = ReactTypeOfWork.HostComponent;\n\n    function describeFiber(fiber) {\n      switch (fiber.tag) {\n        case IndeterminateComponent:\n        case FunctionalComponent:\n        case ClassComponent$1:\n        case HostComponent$2:\n          var owner = fiber._debugOwner;\n          var source = fiber._debugSource;\n          var name = getComponentName_1(fiber);\n          var ownerName = null;\n\n          if (owner) {\n            ownerName = getComponentName_1(owner);\n          }\n\n          return describeComponentFrame(name, source, ownerName);\n\n        default:\n          return '';\n      }\n    } // This function can only be called with a work-in-progress fiber and\n    // only during begin or complete phase. Do not call it under any other\n    // circumstances.\n\n\n    function getStackAddendumByWorkInProgressFiber$1(workInProgress) {\n      var info = '';\n      var node = workInProgress;\n\n      do {\n        info += describeFiber(node); // Otherwise this return pointer might point to the wrong tree:\n\n        node = node['return'];\n      } while (node);\n\n      return info;\n    }\n\n    var ReactFiberComponentTreeHook = {\n      getStackAddendumByWorkInProgressFiber: getStackAddendumByWorkInProgressFiber$1\n    };\n    var ReactDebugCurrentFrame = ReactGlobalSharedState_1.ReactDebugCurrentFrame;\n    {\n      var getComponentName$3 = getComponentName_1;\n      var _require2$2 = ReactFiberComponentTreeHook,\n          getStackAddendumByWorkInProgressFiber = _require2$2.getStackAddendumByWorkInProgressFiber;\n    }\n\n    function getCurrentFiberOwnerName$2() {\n      {\n        var fiber = ReactDebugCurrentFiber.current;\n\n        if (fiber === null) {\n          return null;\n        }\n\n        if (fiber._debugOwner != null) {\n          return getComponentName$3(fiber._debugOwner);\n        }\n      }\n      return null;\n    }\n\n    function getCurrentFiberStackAddendum$1() {\n      {\n        var fiber = ReactDebugCurrentFiber.current;\n\n        if (fiber === null) {\n          return null;\n        } // Safe because if current fiber exists, we are reconciling,\n        // and it is guaranteed to be the work-in-progress version.\n\n\n        return getStackAddendumByWorkInProgressFiber(fiber);\n      }\n      return null;\n    }\n\n    function resetCurrentFiber() {\n      ReactDebugCurrentFrame.getCurrentStack = null;\n      ReactDebugCurrentFiber.current = null;\n      ReactDebugCurrentFiber.phase = null;\n    }\n\n    function setCurrentFiber(fiber, phase) {\n      ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackAddendum$1;\n      ReactDebugCurrentFiber.current = fiber;\n      ReactDebugCurrentFiber.phase = phase;\n    }\n\n    var ReactDebugCurrentFiber = {\n      current: null,\n      phase: null,\n      resetCurrentFiber: resetCurrentFiber,\n      setCurrentFiber: setCurrentFiber,\n      getCurrentFiberOwnerName: getCurrentFiberOwnerName$2,\n      getCurrentFiberStackAddendum: getCurrentFiberStackAddendum$1\n    };\n    var ReactDebugCurrentFiber_1 = ReactDebugCurrentFiber;\n    var warnValidStyle$1 = emptyFunction;\n    {\n      var camelizeStyleName$1 = camelizeStyleName;\n      var getComponentName$2 = getComponentName_1;\n      var warning$4 = require$$0;\n      var _require$3 = ReactDebugCurrentFiber_1,\n          getCurrentFiberOwnerName$1 = _require$3.getCurrentFiberOwnerName; // 'msTransform' is correct, but the other prefixes should be capitalized\n\n      var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/; // style values shouldn't contain a semicolon\n\n      var badStyleValueWithSemicolonPattern = /;\\s*$/;\n      var warnedStyleNames = {};\n      var warnedStyleValues = {};\n      var warnedForNaNValue = false;\n      var warnedForInfinityValue = false;\n\n      var warnHyphenatedStyleName = function warnHyphenatedStyleName(name, owner) {\n        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n          return;\n        }\n\n        warnedStyleNames[name] = true;\n        warning$4(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName$1(name), checkRenderMessage(owner));\n      };\n\n      var warnBadVendoredStyleName = function warnBadVendoredStyleName(name, owner) {\n        if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n          return;\n        }\n\n        warnedStyleNames[name] = true;\n        warning$4(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner));\n      };\n\n      var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value, owner) {\n        if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n          return;\n        }\n\n        warnedStyleValues[value] = true;\n        warning$4(false, \"Style property values shouldn't contain a semicolon.%s \" + 'Try \"%s: %s\" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, ''));\n      };\n\n      var warnStyleValueIsNaN = function warnStyleValueIsNaN(name, value, owner) {\n        if (warnedForNaNValue) {\n          return;\n        }\n\n        warnedForNaNValue = true;\n        warning$4(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner));\n      };\n\n      var warnStyleValueIsInfinity = function warnStyleValueIsInfinity(name, value, owner) {\n        if (warnedForInfinityValue) {\n          return;\n        }\n\n        warnedForInfinityValue = true;\n        warning$4(false, '`Infinity` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner));\n      };\n\n      var checkRenderMessage = function checkRenderMessage(owner) {\n        var ownerName;\n\n        if (owner != null) {\n          // Stack passes the owner manually all the way to CSSPropertyOperations.\n          ownerName = getComponentName$2(owner);\n        } else {\n          // Fiber doesn't pass it but uses ReactDebugCurrentFiber to track it.\n          // It is only enabled in development and tracks host components too.\n          ownerName = getCurrentFiberOwnerName$1(); // TODO: also report the stack.\n        }\n\n        if (ownerName) {\n          return '\\n\\nCheck the render method of `' + ownerName + '`.';\n        }\n\n        return '';\n      };\n\n      warnValidStyle$1 = function warnValidStyle$1(name, value, component) {\n        var owner;\n\n        if (component) {\n          // TODO: this only works with Stack. Seems like we need to add unit tests?\n          owner = component._currentElement._owner;\n        }\n\n        if (name.indexOf('-') > -1) {\n          warnHyphenatedStyleName(name, owner);\n        } else if (badVendoredStyleNamePattern.test(name)) {\n          warnBadVendoredStyleName(name, owner);\n        } else if (badStyleValueWithSemicolonPattern.test(value)) {\n          warnStyleValueWithSemicolon(name, value, owner);\n        }\n\n        if (typeof value === 'number') {\n          if (isNaN(value)) {\n            warnStyleValueIsNaN(name, value, owner);\n          } else if (!isFinite(value)) {\n            warnStyleValueIsInfinity(name, value, owner);\n          }\n        }\n      };\n    }\n    var warnValidStyle_1 = warnValidStyle$1;\n    {\n      var hyphenateStyleName$1 = hyphenateStyleName;\n      var warnValidStyle = warnValidStyle_1;\n    }\n    var hasShorthandPropertyBug = false;\n\n    if (ExecutionEnvironment.canUseDOM) {\n      var tempStyle = document.createElement('div').style;\n\n      try {\n        // IE8 throws \"Invalid argument.\" if resetting shorthand style properties.\n        tempStyle.font = '';\n      } catch (e) {\n        hasShorthandPropertyBug = true;\n      }\n    }\n    /**\n     * Operations for dealing with CSS properties.\n     */\n\n\n    var CSSPropertyOperations = {\n      /**\n       * This creates a string that is expected to be equivalent to the style\n       * attribute generated by server-side rendering. It by-passes warnings and\n       * security checks so it's not safe to use this value for anything other than\n       * comparison. It is only used in DEV for SSR validation.\n       */\n      createDangerousStringForStyles: function createDangerousStringForStyles(styles) {\n        {\n          var serialized = '';\n          var delimiter = '';\n\n          for (var styleName in styles) {\n            if (!styles.hasOwnProperty(styleName)) {\n              continue;\n            }\n\n            var styleValue = styles[styleName];\n\n            if (styleValue != null) {\n              var isCustomProperty = styleName.indexOf('--') === 0;\n              serialized += delimiter + hyphenateStyleName$1(styleName) + ':';\n              serialized += dangerousStyleValue_1(styleName, styleValue, isCustomProperty);\n              delimiter = ';';\n            }\n          }\n\n          return serialized || null;\n        }\n      },\n\n      /**\n       * Sets the value for multiple styles on a node.  If a value is specified as\n       * '' (empty string), the corresponding style property will be unset.\n       *\n       * @param {DOMElement} node\n       * @param {object} styles\n       * @param {ReactDOMComponent} component\n       */\n      setValueForStyles: function setValueForStyles(node, styles, component) {\n        var style = node.style;\n\n        for (var styleName in styles) {\n          if (!styles.hasOwnProperty(styleName)) {\n            continue;\n          }\n\n          var isCustomProperty = styleName.indexOf('--') === 0;\n          {\n            if (!isCustomProperty) {\n              warnValidStyle(styleName, styles[styleName], component);\n            }\n          }\n          var styleValue = dangerousStyleValue_1(styleName, styles[styleName], isCustomProperty);\n\n          if (styleName === 'float') {\n            styleName = 'cssFloat';\n          }\n\n          if (isCustomProperty) {\n            style.setProperty(styleName, styleValue);\n          } else if (styleValue) {\n            style[styleName] = styleValue;\n          } else {\n            var expansion = hasShorthandPropertyBug && CSSProperty_1.shorthandPropertyExpansions[styleName];\n\n            if (expansion) {\n              // Shorthand property that IE8 won't like unsetting, so unset each\n              // component to placate it\n              for (var individualStyleName in expansion) {\n                style[individualStyleName] = '';\n              }\n            } else {\n              style[styleName] = '';\n            }\n          }\n        }\n      }\n    };\n    var CSSPropertyOperations_1 = CSSPropertyOperations;\n    var ReactInvalidSetStateWarningHook = {};\n    {\n      var warning$7 = require$$0;\n      var processingChildContext = false;\n\n      var warnInvalidSetState = function warnInvalidSetState() {\n        warning$7(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()');\n      };\n\n      ReactInvalidSetStateWarningHook = {\n        onBeginProcessingChildContext: function onBeginProcessingChildContext() {\n          processingChildContext = true;\n        },\n        onEndProcessingChildContext: function onEndProcessingChildContext() {\n          processingChildContext = false;\n        },\n        onSetState: function onSetState() {\n          warnInvalidSetState();\n        }\n      };\n    }\n    var ReactInvalidSetStateWarningHook_1 = ReactInvalidSetStateWarningHook;\n    /**\n     * Copyright (c) 2016-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule ReactHostOperationHistoryHook\n     * \n     */\n    // Trust the developer to only use this with a true check\n\n    var ReactHostOperationHistoryHook = null;\n    {\n      var history = [];\n      ReactHostOperationHistoryHook = {\n        onHostOperation: function onHostOperation(operation) {\n          history.push(operation);\n        },\n        clearHistory: function clearHistory() {\n          if (ReactHostOperationHistoryHook._preventClearing) {\n            // Should only be used for tests.\n            return;\n          }\n\n          history = [];\n        },\n        getHistory: function getHistory() {\n          return history;\n        }\n      };\n    }\n    var ReactHostOperationHistoryHook_1 = ReactHostOperationHistoryHook;\n    var ReactComponentTreeHook = ReactGlobalSharedState_1.ReactComponentTreeHook;\n    {\n      var warning$6 = require$$0;\n    } // Trust the developer to only use this with a true check\n\n    var ReactDebugTool$1 = null;\n    {\n      var hooks = [];\n      var didHookThrowForEvent = {};\n\n      var callHook = function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {\n        try {\n          fn.call(context, arg1, arg2, arg3, arg4, arg5);\n        } catch (e) {\n          warning$6(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\\n' + e.stack);\n          didHookThrowForEvent[event] = true;\n        }\n      };\n\n      var emitEvent = function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {\n        for (var i = 0; i < hooks.length; i++) {\n          var hook = hooks[i];\n          var fn = hook[event];\n\n          if (fn) {\n            callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);\n          }\n        }\n      };\n\n      var _isProfiling = false;\n      var flushHistory = [];\n      var lifeCycleTimerStack = [];\n      var currentFlushNesting = 0;\n      var currentFlushMeasurements = [];\n      var currentFlushStartTime = 0;\n      var currentTimerDebugID = null;\n      var currentTimerStartTime = 0;\n      var currentTimerNestedFlushDuration = 0;\n      var currentTimerType = null;\n      var lifeCycleTimerHasWarned = false;\n\n      var clearHistory = function clearHistory() {\n        ReactComponentTreeHook.purgeUnmountedComponents();\n        ReactHostOperationHistoryHook_1.clearHistory();\n      };\n\n      var getTreeSnapshot = function getTreeSnapshot(registeredIDs) {\n        return registeredIDs.reduce(function (tree, id) {\n          var ownerID = ReactComponentTreeHook.getOwnerID(id);\n          var parentID = ReactComponentTreeHook.getParentID(id);\n          tree[id] = {\n            displayName: ReactComponentTreeHook.getDisplayName(id),\n            text: ReactComponentTreeHook.getText(id),\n            updateCount: ReactComponentTreeHook.getUpdateCount(id),\n            childIDs: ReactComponentTreeHook.getChildIDs(id),\n            // Text nodes don't have owners but this is close enough.\n            ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,\n            parentID: parentID\n          };\n          return tree;\n        }, {});\n      };\n\n      var resetMeasurements = function resetMeasurements() {\n        var previousStartTime = currentFlushStartTime;\n        var previousMeasurements = currentFlushMeasurements;\n        var previousOperations = ReactHostOperationHistoryHook_1.getHistory();\n\n        if (currentFlushNesting === 0) {\n          currentFlushStartTime = 0;\n          currentFlushMeasurements = [];\n          clearHistory();\n          return;\n        }\n\n        if (previousMeasurements.length || previousOperations.length) {\n          var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();\n          flushHistory.push({\n            duration: performanceNow() - previousStartTime,\n            measurements: previousMeasurements || [],\n            operations: previousOperations || [],\n            treeSnapshot: getTreeSnapshot(registeredIDs)\n          });\n        }\n\n        clearHistory();\n        currentFlushStartTime = performanceNow();\n        currentFlushMeasurements = [];\n      };\n\n      var checkDebugID = function checkDebugID(debugID) {\n        var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (allowRoot && debugID === 0) {\n          return;\n        }\n\n        if (!debugID) {\n          warning$6(false, 'ReactDebugTool: debugID may not be empty.');\n        }\n      };\n\n      var beginLifeCycleTimer = function beginLifeCycleTimer(debugID, timerType) {\n        if (currentFlushNesting === 0) {\n          return;\n        }\n\n        if (currentTimerType && !lifeCycleTimerHasWarned) {\n          warning$6(false, 'There is an internal error in the React performance measurement code.' + '\\n\\nDid not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another');\n          lifeCycleTimerHasWarned = true;\n        }\n\n        currentTimerStartTime = performanceNow();\n        currentTimerNestedFlushDuration = 0;\n        currentTimerDebugID = debugID;\n        currentTimerType = timerType;\n      };\n\n      var endLifeCycleTimer = function endLifeCycleTimer(debugID, timerType) {\n        if (currentFlushNesting === 0) {\n          return;\n        }\n\n        if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {\n          warning$6(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another');\n          lifeCycleTimerHasWarned = true;\n        }\n\n        if (_isProfiling) {\n          currentFlushMeasurements.push({\n            timerType: timerType,\n            instanceID: debugID,\n            duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration\n          });\n        }\n\n        currentTimerStartTime = 0;\n        currentTimerNestedFlushDuration = 0;\n        currentTimerDebugID = null;\n        currentTimerType = null;\n      };\n\n      var pauseCurrentLifeCycleTimer = function pauseCurrentLifeCycleTimer() {\n        var currentTimer = {\n          startTime: currentTimerStartTime,\n          nestedFlushStartTime: performanceNow(),\n          debugID: currentTimerDebugID,\n          timerType: currentTimerType\n        };\n        lifeCycleTimerStack.push(currentTimer);\n        currentTimerStartTime = 0;\n        currentTimerNestedFlushDuration = 0;\n        currentTimerDebugID = null;\n        currentTimerType = null;\n      };\n\n      var resumeCurrentLifeCycleTimer = function resumeCurrentLifeCycleTimer() {\n        var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),\n            startTime = _lifeCycleTimerStack$.startTime,\n            nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,\n            debugID = _lifeCycleTimerStack$.debugID,\n            timerType = _lifeCycleTimerStack$.timerType;\n\n        var nestedFlushDuration = performanceNow() - nestedFlushStartTime;\n        currentTimerStartTime = startTime;\n        currentTimerNestedFlushDuration += nestedFlushDuration;\n        currentTimerDebugID = debugID;\n        currentTimerType = timerType;\n      };\n\n      var lastMarkTimeStamp = 0;\n      var canUsePerformanceMeasure = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\n      var shouldMark = function shouldMark(debugID) {\n        if (!_isProfiling || !canUsePerformanceMeasure) {\n          return false;\n        }\n\n        var element = ReactComponentTreeHook.getElement(debugID);\n\n        if (element == null || typeof element !== 'object') {\n          return false;\n        }\n\n        var isHostElement = typeof element.type === 'string';\n\n        if (isHostElement) {\n          return false;\n        }\n\n        return true;\n      };\n\n      var markBegin = function markBegin(debugID, markType) {\n        if (!shouldMark(debugID)) {\n          return;\n        }\n\n        var markName = debugID + '::' + markType;\n        lastMarkTimeStamp = performanceNow();\n        performance.mark(markName);\n      };\n\n      var markEnd = function markEnd(debugID, markType) {\n        if (!shouldMark(debugID)) {\n          return;\n        }\n\n        var markName = debugID + '::' + markType;\n        var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown'; // Chrome has an issue of dropping markers recorded too fast:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=640652\n        // To work around this, we will not report very small measurements.\n        // I determined the magic number by tweaking it back and forth.\n        // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.\n        // When the bug is fixed, we can `measure()` unconditionally if we want to.\n\n        var timeStamp = performanceNow();\n\n        if (timeStamp - lastMarkTimeStamp > 0.1) {\n          var measurementName = displayName + ' [' + markType + ']';\n          performance.measure(measurementName, markName);\n        }\n\n        performance.clearMarks(markName);\n\n        if (measurementName) {\n          performance.clearMeasures(measurementName);\n        }\n      };\n\n      ReactDebugTool$1 = {\n        addHook: function addHook(hook) {\n          hooks.push(hook);\n        },\n        removeHook: function removeHook(hook) {\n          for (var i = 0; i < hooks.length; i++) {\n            if (hooks[i] === hook) {\n              hooks.splice(i, 1);\n              i--;\n            }\n          }\n        },\n        isProfiling: function isProfiling() {\n          return _isProfiling;\n        },\n        beginProfiling: function beginProfiling() {\n          if (_isProfiling) {\n            return;\n          }\n\n          _isProfiling = true;\n          flushHistory.length = 0;\n          resetMeasurements();\n          ReactDebugTool$1.addHook(ReactHostOperationHistoryHook_1);\n        },\n        endProfiling: function endProfiling() {\n          if (!_isProfiling) {\n            return;\n          }\n\n          _isProfiling = false;\n          resetMeasurements();\n          ReactDebugTool$1.removeHook(ReactHostOperationHistoryHook_1);\n        },\n        getFlushHistory: function getFlushHistory() {\n          return flushHistory;\n        },\n        onBeginFlush: function onBeginFlush() {\n          currentFlushNesting++;\n          resetMeasurements();\n          pauseCurrentLifeCycleTimer();\n          emitEvent('onBeginFlush');\n        },\n        onEndFlush: function onEndFlush() {\n          resetMeasurements();\n          currentFlushNesting--;\n          resumeCurrentLifeCycleTimer();\n          emitEvent('onEndFlush');\n        },\n        onBeginLifeCycleTimer: function onBeginLifeCycleTimer(debugID, timerType) {\n          checkDebugID(debugID);\n          emitEvent('onBeginLifeCycleTimer', debugID, timerType);\n          markBegin(debugID, timerType);\n          beginLifeCycleTimer(debugID, timerType);\n        },\n        onEndLifeCycleTimer: function onEndLifeCycleTimer(debugID, timerType) {\n          checkDebugID(debugID);\n          endLifeCycleTimer(debugID, timerType);\n          markEnd(debugID, timerType);\n          emitEvent('onEndLifeCycleTimer', debugID, timerType);\n        },\n        onBeginProcessingChildContext: function onBeginProcessingChildContext() {\n          emitEvent('onBeginProcessingChildContext');\n        },\n        onEndProcessingChildContext: function onEndProcessingChildContext() {\n          emitEvent('onEndProcessingChildContext');\n        },\n        onHostOperation: function onHostOperation(operation) {\n          checkDebugID(operation.instanceID);\n          emitEvent('onHostOperation', operation);\n        },\n        onSetState: function onSetState() {\n          emitEvent('onSetState');\n        },\n        onSetChildren: function onSetChildren(debugID, childDebugIDs) {\n          checkDebugID(debugID);\n          childDebugIDs.forEach(checkDebugID);\n          emitEvent('onSetChildren', debugID, childDebugIDs);\n        },\n        onBeforeMountComponent: function onBeforeMountComponent(debugID, element, parentDebugID) {\n          checkDebugID(debugID);\n          checkDebugID(parentDebugID, true);\n          emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);\n          markBegin(debugID, 'mount');\n        },\n        onMountComponent: function onMountComponent(debugID) {\n          checkDebugID(debugID);\n          markEnd(debugID, 'mount');\n          emitEvent('onMountComponent', debugID);\n        },\n        onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {\n          checkDebugID(debugID);\n          emitEvent('onBeforeUpdateComponent', debugID, element);\n          markBegin(debugID, 'update');\n        },\n        onUpdateComponent: function onUpdateComponent(debugID) {\n          checkDebugID(debugID);\n          markEnd(debugID, 'update');\n          emitEvent('onUpdateComponent', debugID);\n        },\n        onBeforeUnmountComponent: function onBeforeUnmountComponent(debugID) {\n          checkDebugID(debugID);\n          emitEvent('onBeforeUnmountComponent', debugID);\n          markBegin(debugID, 'unmount');\n        },\n        onUnmountComponent: function onUnmountComponent(debugID) {\n          checkDebugID(debugID);\n          markEnd(debugID, 'unmount');\n          emitEvent('onUnmountComponent', debugID);\n        },\n        onTestEvent: function onTestEvent() {\n          emitEvent('onTestEvent');\n        }\n      };\n      ReactDebugTool$1.addHook(ReactInvalidSetStateWarningHook_1);\n      ReactDebugTool$1.addHook(ReactComponentTreeHook);\n      var url = ExecutionEnvironment.canUseDOM && window.location.href || '';\n\n      if (/[?&]react_perf\\b/.test(url)) {\n        ReactDebugTool$1.beginProfiling();\n      }\n    }\n    var ReactDebugTool_1 = ReactDebugTool$1; // Trust the developer to only use ReactInstrumentation with a true check\n\n    var debugTool = null;\n    {\n      var ReactDebugTool = ReactDebugTool_1;\n      debugTool = ReactDebugTool;\n    }\n    var ReactInstrumentation = {\n      debugTool: debugTool\n    };\n    {\n      var warning$5 = require$$0;\n    } // isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.\n    // TODO: Find a better place for this.\n\n    var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty_1.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty_1.ATTRIBUTE_NAME_CHAR + ']*$');\n    var illegalAttributeNameCache = {};\n    var validatedAttributeNameCache = {};\n\n    function isAttributeNameSafe(attributeName) {\n      if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {\n        return true;\n      }\n\n      if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {\n        return false;\n      }\n\n      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n        validatedAttributeNameCache[attributeName] = true;\n        return true;\n      }\n\n      illegalAttributeNameCache[attributeName] = true;\n      {\n        warning$5(false, 'Invalid attribute name: `%s`', attributeName);\n      }\n      return false;\n    } // shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.\n    // TODO: Find a better place for this.\n\n\n    function shouldIgnoreValue(propertyInfo, value) {\n      return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;\n    }\n    /**\n     * Operations for dealing with DOM properties.\n     */\n\n\n    var DOMPropertyOperations = {\n      setAttributeForID: function setAttributeForID(node, id) {\n        node.setAttribute(DOMProperty_1.ID_ATTRIBUTE_NAME, id);\n      },\n      setAttributeForRoot: function setAttributeForRoot(node) {\n        node.setAttribute(DOMProperty_1.ROOT_ATTRIBUTE_NAME, '');\n      },\n\n      /**\n       * Get the value for a property on a node. Only used in DEV for SSR validation.\n       * The \"expected\" argument is used as a hint of what the expected value is.\n       * Some properties have multiple equivalent values.\n       */\n      getValueForProperty: function getValueForProperty(node, name, expected) {\n        {\n          var propertyInfo = DOMProperty_1.getPropertyInfo(name);\n\n          if (propertyInfo) {\n            var mutationMethod = propertyInfo.mutationMethod;\n\n            if (mutationMethod || propertyInfo.mustUseProperty) {\n              return node[propertyInfo.propertyName];\n            } else {\n              var attributeName = propertyInfo.attributeName;\n              var stringValue = null;\n\n              if (propertyInfo.hasOverloadedBooleanValue) {\n                if (node.hasAttribute(attributeName)) {\n                  var value = node.getAttribute(attributeName);\n\n                  if (value === '') {\n                    return true;\n                  }\n\n                  if (shouldIgnoreValue(propertyInfo, expected)) {\n                    return value;\n                  }\n\n                  if (value === '' + expected) {\n                    return expected;\n                  }\n\n                  return value;\n                }\n              } else if (node.hasAttribute(attributeName)) {\n                if (shouldIgnoreValue(propertyInfo, expected)) {\n                  // We had an attribute but shouldn't have had one, so read it\n                  // for the error message.\n                  return node.getAttribute(attributeName);\n                }\n\n                if (propertyInfo.hasBooleanValue) {\n                  // If this was a boolean, it doesn't matter what the value is\n                  // the fact that we have it is the same as the expected.\n                  return expected;\n                } // Even if this property uses a namespace we use getAttribute\n                // because we assume its namespaced name is the same as our config.\n                // To use getAttributeNS we need the local name which we don't have\n                // in our config atm.\n\n\n                stringValue = node.getAttribute(attributeName);\n              }\n\n              if (shouldIgnoreValue(propertyInfo, expected)) {\n                return stringValue === null ? expected : stringValue;\n              } else if (stringValue === '' + expected) {\n                return expected;\n              } else {\n                return stringValue;\n              }\n            }\n          }\n        }\n      },\n\n      /**\n       * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n       * The third argument is used as a hint of what the expected value is. Some\n       * attributes have multiple equivalent values.\n       */\n      getValueForAttribute: function getValueForAttribute(node, name, expected) {\n        {\n          if (!isAttributeNameSafe(name)) {\n            return;\n          }\n\n          if (!node.hasAttribute(name)) {\n            return expected === undefined ? undefined : null;\n          }\n\n          var value = node.getAttribute(name);\n\n          if (value === '' + expected) {\n            return expected;\n          }\n\n          return value;\n        }\n      },\n\n      /**\n       * Sets the value for a property on a node.\n       *\n       * @param {DOMElement} node\n       * @param {string} name\n       * @param {*} value\n       */\n      setValueForProperty: function setValueForProperty(node, name, value) {\n        var propertyInfo = DOMProperty_1.getPropertyInfo(name);\n\n        if (propertyInfo && DOMProperty_1.shouldSetAttribute(name, value)) {\n          var mutationMethod = propertyInfo.mutationMethod;\n\n          if (mutationMethod) {\n            mutationMethod(node, value);\n          } else if (shouldIgnoreValue(propertyInfo, value)) {\n            DOMPropertyOperations.deleteValueForProperty(node, name);\n            return;\n          } else if (propertyInfo.mustUseProperty) {\n            // Contrary to `setAttribute`, object properties are properly\n            // `toString`ed by IE8/9.\n            node[propertyInfo.propertyName] = value;\n          } else {\n            var attributeName = propertyInfo.attributeName;\n            var namespace = propertyInfo.attributeNamespace; // `setAttribute` with objects becomes only `[object]` in IE8/9,\n            // ('' + value) makes it output the correct toString()-value.\n\n            if (namespace) {\n              node.setAttributeNS(namespace, attributeName, '' + value);\n            } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {\n              node.setAttribute(attributeName, '');\n            } else {\n              node.setAttribute(attributeName, '' + value);\n            }\n          }\n        } else {\n          DOMPropertyOperations.setValueForAttribute(node, name, DOMProperty_1.shouldSetAttribute(name, value) ? value : null);\n          return;\n        }\n\n        {\n          var payload = {};\n          payload[name] = value;\n          ReactInstrumentation.debugTool.onHostOperation({\n            instanceID: ReactDOMComponentTree_1.getInstanceFromNode(node)._debugID,\n            type: 'update attribute',\n            payload: payload\n          });\n        }\n      },\n      setValueForAttribute: function setValueForAttribute(node, name, value) {\n        if (!isAttributeNameSafe(name)) {\n          return;\n        }\n\n        if (value == null) {\n          node.removeAttribute(name);\n        } else {\n          node.setAttribute(name, '' + value);\n        }\n\n        {\n          var payload = {};\n          payload[name] = value;\n          ReactInstrumentation.debugTool.onHostOperation({\n            instanceID: ReactDOMComponentTree_1.getInstanceFromNode(node)._debugID,\n            type: 'update attribute',\n            payload: payload\n          });\n        }\n      },\n\n      /**\n       * Deletes an attributes from a node.\n       *\n       * @param {DOMElement} node\n       * @param {string} name\n       */\n      deleteValueForAttribute: function deleteValueForAttribute(node, name) {\n        node.removeAttribute(name);\n        {\n          ReactInstrumentation.debugTool.onHostOperation({\n            instanceID: ReactDOMComponentTree_1.getInstanceFromNode(node)._debugID,\n            type: 'remove attribute',\n            payload: name\n          });\n        }\n      },\n\n      /**\n       * Deletes the value for a property on a node.\n       *\n       * @param {DOMElement} node\n       * @param {string} name\n       */\n      deleteValueForProperty: function deleteValueForProperty(node, name) {\n        var propertyInfo = DOMProperty_1.getPropertyInfo(name);\n\n        if (propertyInfo) {\n          var mutationMethod = propertyInfo.mutationMethod;\n\n          if (mutationMethod) {\n            mutationMethod(node, undefined);\n          } else if (propertyInfo.mustUseProperty) {\n            var propName = propertyInfo.propertyName;\n\n            if (propertyInfo.hasBooleanValue) {\n              node[propName] = false;\n            } else {\n              node[propName] = '';\n            }\n          } else {\n            node.removeAttribute(propertyInfo.attributeName);\n          }\n        } else {\n          node.removeAttribute(name);\n        }\n\n        {\n          ReactInstrumentation.debugTool.onHostOperation({\n            instanceID: ReactDOMComponentTree_1.getInstanceFromNode(node)._debugID,\n            type: 'remove attribute',\n            payload: name\n          });\n        }\n      }\n    };\n    var DOMPropertyOperations_1 = DOMPropertyOperations;\n    var ReactControlledValuePropTypes = {\n      checkPropTypes: null\n    };\n    {\n      var warning$9 = require$$0;\n      var emptyFunction$2 = emptyFunction;\n      var PropTypes = propTypes;\n      var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n      ReactControlledValuePropTypes.checkPropTypes = emptyFunction$2;\n      var hasReadOnlyValue = {\n        button: true,\n        checkbox: true,\n        image: true,\n        hidden: true,\n        radio: true,\n        reset: true,\n        submit: true\n      };\n      var propTypes$1 = {\n        value: function value(props, propName, componentName) {\n          if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {\n            return null;\n          }\n\n          return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n        },\n        checked: function checked(props, propName, componentName) {\n          if (!props[propName] || props.onChange || props.readOnly || props.disabled) {\n            return null;\n          }\n\n          return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n        },\n        onChange: PropTypes.func\n      };\n      var loggedTypeFailures = {};\n      /**\n       * Provide a linked `value` attribute for controlled forms. You should not use\n       * this outside of the ReactDOM controlled form components.\n       */\n\n      ReactControlledValuePropTypes.checkPropTypes = function (tagName, props, getStack) {\n        for (var propName in propTypes$1) {\n          if (propTypes$1.hasOwnProperty(propName)) {\n            var error = propTypes$1[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);\n          }\n\n          if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n            // Only monitor this failure once because there tends to be a lot of the\n            // same error.\n            loggedTypeFailures[error.message] = true;\n            warning$9(false, 'Failed form propType: %s%s', error.message, getStack());\n          }\n        }\n      };\n    }\n    var ReactControlledValuePropTypes_1 = ReactControlledValuePropTypes;\n    var getCurrentFiberOwnerName$3 = ReactDebugCurrentFiber_1.getCurrentFiberOwnerName;\n    {\n      var _require2$3 = ReactDebugCurrentFiber_1,\n          getCurrentFiberStackAddendum$2 = _require2$3.getCurrentFiberStackAddendum;\n      var warning$8 = require$$0;\n    }\n    var didWarnValueDefaultValue = false;\n    var didWarnCheckedDefaultChecked = false;\n    var didWarnControlledToUncontrolled = false;\n    var didWarnUncontrolledToControlled = false;\n\n    function isControlled(props) {\n      var usesChecked = props.type === 'checkbox' || props.type === 'radio';\n      return usesChecked ? props.checked != null : props.value != null;\n    }\n    /**\n     * Implements an <input> host component that allows setting these optional\n     * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n     *\n     * If `checked` or `value` are not supplied (or null/undefined), user actions\n     * that affect the checked state or value will trigger updates to the element.\n     *\n     * If they are supplied (and not null/undefined), the rendered element will not\n     * trigger updates to the element. Instead, the props must change in order for\n     * the rendered element to be updated.\n     *\n     * The rendered element will be initialized as unchecked (or `defaultChecked`)\n     * with an empty value (or `defaultValue`).\n     *\n     * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n     */\n\n\n    var ReactDOMInput = {\n      getHostProps: function getHostProps(element, props) {\n        var node = element;\n        var value = props.value;\n        var checked = props.checked;\n\n        var hostProps = _assign({\n          // Make sure we set .type before any other properties (setting .value\n          // before .type means .value is lost in IE11 and below)\n          type: undefined,\n          // Make sure we set .step before .value (setting .value before .step\n          // means .value is rounded on mount, based upon step precision)\n          step: undefined,\n          // Make sure we set .min & .max before .value (to ensure proper order\n          // in corner cases such as min or max deriving from value, e.g. Issue #7170)\n          min: undefined,\n          max: undefined\n        }, props, {\n          defaultChecked: undefined,\n          defaultValue: undefined,\n          value: value != null ? value : node._wrapperState.initialValue,\n          checked: checked != null ? checked : node._wrapperState.initialChecked\n        });\n\n        return hostProps;\n      },\n      initWrapperState: function initWrapperState(element, props) {\n        {\n          ReactControlledValuePropTypes_1.checkPropTypes('input', props, getCurrentFiberStackAddendum$2);\n\n          if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\n            warning$8(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$3() || 'A component', props.type);\n            didWarnCheckedDefaultChecked = true;\n          }\n\n          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\n            warning$8(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerName$3() || 'A component', props.type);\n            didWarnValueDefaultValue = true;\n          }\n        }\n        var defaultValue = props.defaultValue;\n        var node = element;\n        node._wrapperState = {\n          initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n          initialValue: props.value != null ? props.value : defaultValue,\n          controlled: isControlled(props)\n        };\n      },\n      updateWrapper: function updateWrapper(element, props) {\n        var node = element;\n        {\n          var controlled = isControlled(props);\n\n          if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {\n            warning$8(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$2());\n            didWarnUncontrolledToControlled = true;\n          }\n\n          if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {\n            warning$8(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s', props.type, getCurrentFiberStackAddendum$2());\n            didWarnControlledToUncontrolled = true;\n          }\n        }\n        var checked = props.checked;\n\n        if (checked != null) {\n          DOMPropertyOperations_1.setValueForProperty(node, 'checked', checked || false);\n        }\n\n        var value = props.value;\n\n        if (value != null) {\n          if (value === 0 && node.value === '') {\n            node.value = '0'; // Note: IE9 reports a number inputs as 'text', so check props instead.\n          } else if (props.type === 'number') {\n            // Simulate `input.valueAsNumber`. IE9 does not support it\n            var valueAsNumber = parseFloat(node.value) || 0;\n\n            if ( // eslint-disable-next-line\n            value != valueAsNumber || // eslint-disable-next-line\n            value == valueAsNumber && node.value != value) {\n              // Cast `value` to a string to ensure the value is set correctly. While\n              // browsers typically do this as necessary, jsdom doesn't.\n              node.value = '' + value;\n            }\n          } else if (node.value !== '' + value) {\n            // Cast `value` to a string to ensure the value is set correctly. While\n            // browsers typically do this as necessary, jsdom doesn't.\n            node.value = '' + value;\n          }\n        } else {\n          if (props.value == null && props.defaultValue != null) {\n            // In Chrome, assigning defaultValue to certain input types triggers input validation.\n            // For number inputs, the display value loses trailing decimal points. For email inputs,\n            // Chrome raises \"The specified value <x> is not a valid email address\".\n            //\n            // Here we check to see if the defaultValue has actually changed, avoiding these problems\n            // when the user is inputting text\n            //\n            // https://github.com/facebook/react/issues/7253\n            if (node.defaultValue !== '' + props.defaultValue) {\n              node.defaultValue = '' + props.defaultValue;\n            }\n          }\n\n          if (props.checked == null && props.defaultChecked != null) {\n            node.defaultChecked = !!props.defaultChecked;\n          }\n        }\n      },\n      postMountWrapper: function postMountWrapper(element, props) {\n        var node = element; // Detach value from defaultValue. We won't do anything if we're working on\n        // submit or reset inputs as those values & defaultValues are linked. They\n        // are not resetable nodes so this operation doesn't matter and actually\n        // removes browser-default values (eg \"Submit Query\") when no value is\n        // provided.\n\n        switch (props.type) {\n          case 'submit':\n          case 'reset':\n            break;\n\n          case 'color':\n          case 'date':\n          case 'datetime':\n          case 'datetime-local':\n          case 'month':\n          case 'time':\n          case 'week':\n            // This fixes the no-show issue on iOS Safari and Android Chrome:\n            // https://github.com/facebook/react/issues/7233\n            node.value = '';\n            node.value = node.defaultValue;\n            break;\n\n          default:\n            node.value = node.value;\n            break;\n        } // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n        // this is needed to work around a chrome bug where setting defaultChecked\n        // will sometimes influence the value of checked (even after detachment).\n        // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n        // We need to temporarily unset name to avoid disrupting radio button groups.\n\n\n        var name = node.name;\n\n        if (name !== '') {\n          node.name = '';\n        }\n\n        node.defaultChecked = !node.defaultChecked;\n        node.defaultChecked = !node.defaultChecked;\n\n        if (name !== '') {\n          node.name = name;\n        }\n      },\n      restoreControlledState: function restoreControlledState(element, props) {\n        var node = element;\n        ReactDOMInput.updateWrapper(node, props);\n        updateNamedCousins(node, props);\n      }\n    };\n\n    function updateNamedCousins(rootNode, props) {\n      var name = props.name;\n\n      if (props.type === 'radio' && name != null) {\n        var queryRoot = rootNode;\n\n        while (queryRoot.parentNode) {\n          queryRoot = queryRoot.parentNode;\n        } // If `rootNode.form` was non-null, then we could try `form.elements`,\n        // but that sometimes behaves strangely in IE8. We could also try using\n        // `form.getElementsByName`, but that will only return direct children\n        // and won't include inputs that use the HTML5 `form=` attribute. Since\n        // the input might not even be in a form. It might not even be in the\n        // document. Let's just use the local `querySelectorAll` to ensure we don't\n        // miss anything.\n\n\n        var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n        for (var i = 0; i < group.length; i++) {\n          var otherNode = group[i];\n\n          if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n            continue;\n          } // This will throw if radio buttons rendered by different copies of React\n          // and the same name are rendered into the same form (same as #1939).\n          // That's probably okay; we don't support it just as we don't support\n          // mixing React radio buttons with non-React ones.\n\n\n          var otherProps = ReactDOMComponentTree_1.getFiberCurrentPropsFromNode(otherNode);\n          !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0; // If this is a controlled radio button group, forcing the input that\n          // was previously checked to update will cause it to be come re-checked\n          // as appropriate.\n\n          ReactDOMInput.updateWrapper(otherNode, otherProps);\n        }\n      }\n    }\n\n    var ReactDOMFiberInput = ReactDOMInput;\n    {\n      var warning$10 = require$$0;\n    }\n\n    function flattenChildren(children) {\n      var content = ''; // Flatten children and warn if they aren't strings or numbers;\n      // invalid types are ignored.\n      // We can silently skip them because invalid DOM nesting warning\n      // catches these cases in Fiber.\n\n      react.Children.forEach(children, function (child) {\n        if (child == null) {\n          return;\n        }\n\n        if (typeof child === 'string' || typeof child === 'number') {\n          content += child;\n        }\n      });\n      return content;\n    }\n    /**\n     * Implements an <option> host component that warns when `selected` is set.\n     */\n\n\n    var ReactDOMOption = {\n      validateProps: function validateProps(element, props) {\n        // TODO (yungsters): Remove support for `selected` in <option>.\n        {\n          warning$10(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');\n        }\n      },\n      postMountWrapper: function postMountWrapper(element, props) {\n        // value=\"\" should make a value attribute (#6219)\n        if (props.value != null) {\n          element.setAttribute('value', props.value);\n        }\n      },\n      getHostProps: function getHostProps(element, props) {\n        var hostProps = _assign({\n          children: undefined\n        }, props);\n\n        var content = flattenChildren(props.children);\n\n        if (content) {\n          hostProps.children = content;\n        }\n\n        return hostProps;\n      }\n    };\n    var ReactDOMFiberOption = ReactDOMOption;\n    var getCurrentFiberOwnerName$4 = ReactDebugCurrentFiber_1.getCurrentFiberOwnerName;\n    {\n      var didWarnValueDefaultValue$1 = false;\n      var warning$11 = require$$0;\n      var _require2$4 = ReactDebugCurrentFiber_1,\n          getCurrentFiberStackAddendum$3 = _require2$4.getCurrentFiberStackAddendum;\n    }\n\n    function getDeclarationErrorAddendum() {\n      var ownerName = getCurrentFiberOwnerName$4();\n\n      if (ownerName) {\n        return '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n\n      return '';\n    }\n\n    var valuePropNames = ['value', 'defaultValue'];\n    /**\n     * Validation function for `value` and `defaultValue`.\n     */\n\n    function checkSelectPropTypes(props) {\n      ReactControlledValuePropTypes_1.checkPropTypes('select', props, getCurrentFiberStackAddendum$3);\n\n      for (var i = 0; i < valuePropNames.length; i++) {\n        var propName = valuePropNames[i];\n\n        if (props[propName] == null) {\n          continue;\n        }\n\n        var isArray = Array.isArray(props[propName]);\n\n        if (props.multiple && !isArray) {\n          warning$11(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());\n        } else if (!props.multiple && isArray) {\n          warning$11(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());\n        }\n      }\n    }\n\n    function updateOptions(node, multiple, propValue) {\n      var options = node.options;\n\n      if (multiple) {\n        var selectedValues = propValue;\n        var selectedValue = {};\n\n        for (var i = 0; i < selectedValues.length; i++) {\n          // Prefix to avoid chaos with special keys.\n          selectedValue['$' + selectedValues[i]] = true;\n        }\n\n        for (var _i = 0; _i < options.length; _i++) {\n          var selected = selectedValue.hasOwnProperty('$' + options[_i].value);\n\n          if (options[_i].selected !== selected) {\n            options[_i].selected = selected;\n          }\n        }\n      } else {\n        // Do not set `select.value` as exact behavior isn't consistent across all\n        // browsers for all cases.\n        var _selectedValue = '' + propValue;\n\n        var defaultSelected = null;\n\n        for (var _i2 = 0; _i2 < options.length; _i2++) {\n          if (options[_i2].value === _selectedValue) {\n            options[_i2].selected = true;\n            return;\n          }\n\n          if (defaultSelected === null && !options[_i2].disabled) {\n            defaultSelected = options[_i2];\n          }\n        }\n\n        if (defaultSelected !== null) {\n          defaultSelected.selected = true;\n        }\n      }\n    }\n    /**\n     * Implements a <select> host component that allows optionally setting the\n     * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n     * stringable. If `multiple` is true, the prop must be an array of stringables.\n     *\n     * If `value` is not supplied (or null/undefined), user actions that change the\n     * selected option will trigger updates to the rendered options.\n     *\n     * If it is supplied (and not null/undefined), the rendered options will not\n     * update in response to user actions. Instead, the `value` prop must change in\n     * order for the rendered options to update.\n     *\n     * If `defaultValue` is provided, any options with the supplied values will be\n     * selected.\n     */\n\n\n    var ReactDOMSelect = {\n      getHostProps: function getHostProps(element, props) {\n        return _assign({}, props, {\n          value: undefined\n        });\n      },\n      initWrapperState: function initWrapperState(element, props) {\n        var node = element;\n        {\n          checkSelectPropTypes(props);\n        }\n        var value = props.value;\n        node._wrapperState = {\n          initialValue: value != null ? value : props.defaultValue,\n          wasMultiple: !!props.multiple\n        };\n        {\n          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {\n            warning$11(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n            didWarnValueDefaultValue$1 = true;\n          }\n        }\n      },\n      postMountWrapper: function postMountWrapper(element, props) {\n        var node = element;\n        node.multiple = !!props.multiple;\n        var value = props.value;\n\n        if (value != null) {\n          updateOptions(node, !!props.multiple, value);\n        } else if (props.defaultValue != null) {\n          updateOptions(node, !!props.multiple, props.defaultValue);\n        }\n      },\n      postUpdateWrapper: function postUpdateWrapper(element, props) {\n        var node = element; // After the initial mount, we control selected-ness manually so don't pass\n        // this value down\n\n        node._wrapperState.initialValue = undefined;\n        var wasMultiple = node._wrapperState.wasMultiple;\n        node._wrapperState.wasMultiple = !!props.multiple;\n        var value = props.value;\n\n        if (value != null) {\n          updateOptions(node, !!props.multiple, value);\n        } else if (wasMultiple !== !!props.multiple) {\n          // For simplicity, reapply `defaultValue` if `multiple` is toggled.\n          if (props.defaultValue != null) {\n            updateOptions(node, !!props.multiple, props.defaultValue);\n          } else {\n            // Revert the select back to its default unselected state.\n            updateOptions(node, !!props.multiple, props.multiple ? [] : '');\n          }\n        }\n      },\n      restoreControlledState: function restoreControlledState(element, props) {\n        var node = element;\n        var value = props.value;\n\n        if (value != null) {\n          updateOptions(node, !!props.multiple, value);\n        }\n      }\n    };\n    var ReactDOMFiberSelect = ReactDOMSelect;\n    {\n      var warning$12 = require$$0;\n      var _require$4 = ReactDebugCurrentFiber_1,\n          getCurrentFiberStackAddendum$4 = _require$4.getCurrentFiberStackAddendum;\n    }\n    var didWarnValDefaultVal = false;\n    /**\n     * Implements a <textarea> host component that allows setting `value`, and\n     * `defaultValue`. This differs from the traditional DOM API because value is\n     * usually set as PCDATA children.\n     *\n     * If `value` is not supplied (or null/undefined), user actions that affect the\n     * value will trigger updates to the element.\n     *\n     * If `value` is supplied (and not null/undefined), the rendered element will\n     * not trigger updates to the element. Instead, the `value` prop must change in\n     * order for the rendered element to be updated.\n     *\n     * The rendered element will be initialized with an empty value, the prop\n     * `defaultValue` if specified, or the children content (deprecated).\n     */\n\n    var ReactDOMTextarea = {\n      getHostProps: function getHostProps(element, props) {\n        var node = element;\n        !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0; // Always set children to the same thing. In IE9, the selection range will\n        // get reset if `textContent` is mutated.  We could add a check in setTextContent\n        // to only set the value if/when the value differs from the node value (which would\n        // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n        // solution. The value can be a boolean or object so that's why it's forced\n        // to be a string.\n\n        var hostProps = _assign({}, props, {\n          value: undefined,\n          defaultValue: undefined,\n          children: '' + node._wrapperState.initialValue\n        });\n\n        return hostProps;\n      },\n      initWrapperState: function initWrapperState(element, props) {\n        var node = element;\n        {\n          ReactControlledValuePropTypes_1.checkPropTypes('textarea', props, getCurrentFiberStackAddendum$4);\n\n          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {\n            warning$12(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n            didWarnValDefaultVal = true;\n          }\n        }\n        var value = props.value;\n        var initialValue = value; // Only bother fetching default value if we're going to use it\n\n        if (value == null) {\n          var defaultValue = props.defaultValue; // TODO (yungsters): Remove support for children content in <textarea>.\n\n          var children = props.children;\n\n          if (children != null) {\n            {\n              warning$12(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');\n            }\n            !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;\n\n            if (Array.isArray(children)) {\n              !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;\n              children = children[0];\n            }\n\n            defaultValue = '' + children;\n          }\n\n          if (defaultValue == null) {\n            defaultValue = '';\n          }\n\n          initialValue = defaultValue;\n        }\n\n        node._wrapperState = {\n          initialValue: '' + initialValue\n        };\n      },\n      updateWrapper: function updateWrapper(element, props) {\n        var node = element;\n        var value = props.value;\n\n        if (value != null) {\n          // Cast `value` to a string to ensure the value is set correctly. While\n          // browsers typically do this as necessary, jsdom doesn't.\n          var newValue = '' + value; // To avoid side effects (such as losing text selection), only set value if changed\n\n          if (newValue !== node.value) {\n            node.value = newValue;\n          }\n\n          if (props.defaultValue == null) {\n            node.defaultValue = newValue;\n          }\n        }\n\n        if (props.defaultValue != null) {\n          node.defaultValue = props.defaultValue;\n        }\n      },\n      postMountWrapper: function postMountWrapper(element, props) {\n        var node = element; // This is in postMount because we need access to the DOM node, which is not\n        // available until after the component has mounted.\n\n        var textContent = node.textContent; // Only set node.value if textContent is equal to the expected\n        // initial value. In IE10/IE11 there is a bug where the placeholder attribute\n        // will populate textContent as well.\n        // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\n\n        if (textContent === node._wrapperState.initialValue) {\n          node.value = textContent;\n        }\n      },\n      restoreControlledState: function restoreControlledState(element, props) {\n        // DOM component is still mounted; update\n        ReactDOMTextarea.updateWrapper(element, props);\n      }\n    };\n    var ReactDOMFiberTextarea = ReactDOMTextarea;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule omittedCloseTags\n     */\n    // For HTML, certain tags should omit their close tag. We keep a whitelist for\n    // those special-case tags.\n\n    var omittedCloseTags = {\n      area: true,\n      base: true,\n      br: true,\n      col: true,\n      embed: true,\n      hr: true,\n      img: true,\n      input: true,\n      keygen: true,\n      link: true,\n      meta: true,\n      param: true,\n      source: true,\n      track: true,\n      wbr: true\n    };\n    var omittedCloseTags_1 = omittedCloseTags; // For HTML, certain tags cannot have children. This has the same purpose as\n    // `omittedCloseTags` except that `menuitem` should still have its closing tag.\n\n    var voidElementTags = _assign({\n      menuitem: true\n    }, omittedCloseTags_1);\n\n    var voidElementTags_1 = voidElementTags;\n    {\n      var warning$13 = require$$0;\n    }\n    var HTML$1 = '__html';\n\n    function getDeclarationErrorAddendum$1(getCurrentOwnerName) {\n      {\n        var ownerName = getCurrentOwnerName();\n\n        if (ownerName) {\n          // TODO: also report the stack.\n          return '\\n\\nThis DOM node was rendered by `' + ownerName + '`.';\n        }\n      }\n      return '';\n    }\n\n    function assertValidProps(tag, props, getCurrentOwnerName) {\n      if (!props) {\n        return;\n      } // Note the use of `==` which checks for null or undefined.\n\n\n      if (voidElementTags_1[tag]) {\n        !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, getDeclarationErrorAddendum$1(getCurrentOwnerName)) : void 0;\n      }\n\n      if (props.dangerouslySetInnerHTML != null) {\n        !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;\n        !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;\n      }\n\n      {\n        warning$13(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.');\n      }\n      !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \\'em\\'}} when using JSX.%s', getDeclarationErrorAddendum$1(getCurrentOwnerName)) : void 0;\n    }\n\n    var assertValidProps_1 = assertValidProps;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule inputValueTracking\n     * \n     */\n\n    function isCheckable(elem) {\n      var type = elem.type;\n      var nodeName = elem.nodeName;\n      return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');\n    }\n\n    function getTracker(node) {\n      return node._valueTracker;\n    }\n\n    function detachTracker(node) {\n      node._valueTracker = null;\n    }\n\n    function getValueFromNode(node) {\n      var value = '';\n\n      if (!node) {\n        return value;\n      }\n\n      if (isCheckable(node)) {\n        value = node.checked ? 'true' : 'false';\n      } else {\n        value = node.value;\n      }\n\n      return value;\n    }\n\n    function trackValueOnNode(node) {\n      var valueField = isCheckable(node) ? 'checked' : 'value';\n      var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n      var currentValue = '' + node[valueField]; // if someone has already defined a value or Safari, then bail\n      // and don't track value will cause over reporting of changes,\n      // but it's better then a hard failure\n      // (needed for certain tests that spyOn input values and Safari)\n\n      if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {\n        return;\n      }\n\n      Object.defineProperty(node, valueField, {\n        enumerable: descriptor.enumerable,\n        configurable: true,\n        get: function get() {\n          return descriptor.get.call(this);\n        },\n        set: function set(value) {\n          currentValue = '' + value;\n          descriptor.set.call(this, value);\n        }\n      });\n      var tracker = {\n        getValue: function getValue() {\n          return currentValue;\n        },\n        setValue: function setValue(value) {\n          currentValue = '' + value;\n        },\n        stopTracking: function stopTracking() {\n          detachTracker(node);\n          delete node[valueField];\n        }\n      };\n      return tracker;\n    }\n\n    var inputValueTracking = {\n      // exposed for testing\n      _getTrackerFromNode: getTracker,\n      track: function track(node) {\n        if (getTracker(node)) {\n          return;\n        } // TODO: Once it's just Fiber we can move this to node._wrapperState\n\n\n        node._valueTracker = trackValueOnNode(node);\n      },\n      updateValueIfChanged: function updateValueIfChanged(node) {\n        if (!node) {\n          return false;\n        }\n\n        var tracker = getTracker(node); // if there is no tracker at this point it's unlikely\n        // that trying again will succeed\n\n        if (!tracker) {\n          return true;\n        }\n\n        var lastValue = tracker.getValue();\n        var nextValue = getValueFromNode(node);\n\n        if (nextValue !== lastValue) {\n          tracker.setValue(nextValue);\n          return true;\n        }\n\n        return false;\n      },\n      stopTracking: function stopTracking(node) {\n        var tracker = getTracker(node);\n\n        if (tracker) {\n          tracker.stopTracking();\n        }\n      }\n    };\n    var inputValueTracking_1 = inputValueTracking;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule isCustomComponent\n     * \n     */\n\n    function isCustomComponent(tagName, props) {\n      if (tagName.indexOf('-') === -1) {\n        return typeof props.is === 'string';\n      }\n\n      switch (tagName) {\n        // These are reserved SVG and MathML elements.\n        // We don't mind this whitelist too much because we expect it to never grow.\n        // The alternative is to track the namespace in a few places which is convoluted.\n        // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n        case 'annotation-xml':\n        case 'color-profile':\n        case 'font-face':\n        case 'font-face-src':\n        case 'font-face-uri':\n        case 'font-face-format':\n        case 'font-face-name':\n        case 'missing-glyph':\n          return false;\n\n        default:\n          return true;\n      }\n    }\n\n    var isCustomComponent_1 = isCustomComponent;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule createMicrosoftUnsafeLocalFunction\n     */\n\n    /* globals MSApp */\n\n    /**\n     * Create a function which has 'unsafe' privileges (required by windows8 apps)\n     */\n\n    var createMicrosoftUnsafeLocalFunction = function createMicrosoftUnsafeLocalFunction(func) {\n      if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\n        return function (arg0, arg1, arg2, arg3) {\n          MSApp.execUnsafeLocalFunction(function () {\n            return func(arg0, arg1, arg2, arg3);\n          });\n        };\n      } else {\n        return func;\n      }\n    };\n\n    var createMicrosoftUnsafeLocalFunction_1 = createMicrosoftUnsafeLocalFunction;\n    var Namespaces$1 = DOMNamespaces.Namespaces; // SVG temp container for IE lacking innerHTML\n\n    var reusableSVGContainer;\n    /**\n     * Set the innerHTML property of a node\n     *\n     * @param {DOMElement} node\n     * @param {string} html\n     * @internal\n     */\n\n    var setInnerHTML = createMicrosoftUnsafeLocalFunction_1(function (node, html) {\n      // IE does not have innerHTML for SVG nodes, so instead we inject the\n      // new markup in a temp node and then move the child nodes across into\n      // the target node\n      if (node.namespaceURI === Namespaces$1.svg && !('innerHTML' in node)) {\n        reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n        reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n        var svgNode = reusableSVGContainer.firstChild;\n\n        while (svgNode.firstChild) {\n          node.appendChild(svgNode.firstChild);\n        }\n      } else {\n        node.innerHTML = html;\n      }\n    });\n    var setInnerHTML_1 = setInnerHTML;\n    /**\n     * Copyright (c) 2016-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * Based on the escape-html library, which is used under the MIT License below:\n     *\n     * Copyright (c) 2012-2013 TJ Holowaychuk\n     * Copyright (c) 2015 Andreas Lubbe\n     * Copyright (c) 2015 Tiancheng \"Timothy\" Gu\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining\n     * a copy of this software and associated documentation files (the\n     * 'Software'), to deal in the Software without restriction, including\n     * without limitation the rights to use, copy, modify, merge, publish,\n     * distribute, sublicense, and/or sell copies of the Software, and to\n     * permit persons to whom the Software is furnished to do so, subject to\n     * the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be\n     * included in all copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\n     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n     * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n     * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n     * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n     * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n     *\n     * @providesModule escapeTextContentForBrowser\n     */\n    // code copied and modified from escape-html\n\n    /**\n     * Module variables.\n     * @private\n     */\n\n    var matchHtmlRegExp = /[\"'&<>]/;\n    /**\n     * Escape special characters in the given string of html.\n     *\n     * @param  {string} string The string to escape for inserting into HTML\n     * @return {string}\n     * @public\n     */\n\n    function escapeHtml(string) {\n      var str = '' + string;\n      var match = matchHtmlRegExp.exec(str);\n\n      if (!match) {\n        return str;\n      }\n\n      var escape;\n      var html = '';\n      var index = 0;\n      var lastIndex = 0;\n\n      for (index = match.index; index < str.length; index++) {\n        switch (str.charCodeAt(index)) {\n          case 34:\n            // \"\n            escape = '&quot;';\n            break;\n\n          case 38:\n            // &\n            escape = '&amp;';\n            break;\n\n          case 39:\n            // '\n            escape = '&#x27;'; // modified from escape-html; used to be '&#39'\n\n            break;\n\n          case 60:\n            // <\n            escape = '&lt;';\n            break;\n\n          case 62:\n            // >\n            escape = '&gt;';\n            break;\n\n          default:\n            continue;\n        }\n\n        if (lastIndex !== index) {\n          html += str.substring(lastIndex, index);\n        }\n\n        lastIndex = index + 1;\n        html += escape;\n      }\n\n      return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\n    } // end code copied and modified from escape-html\n\n    /**\n     * Escapes text to prevent scripting attacks.\n     *\n     * @param {*} text Text value to escape.\n     * @return {string} An escaped string.\n     */\n\n\n    function escapeTextContentForBrowser(text) {\n      if (typeof text === 'boolean' || typeof text === 'number') {\n        // this shortcircuit helps perf for types that we know will never have\n        // special characters, especially given that this function is used often\n        // for numeric dom ids.\n        return '' + text;\n      }\n\n      return escapeHtml(text);\n    }\n\n    var escapeTextContentForBrowser_1 = escapeTextContentForBrowser;\n    var TEXT_NODE$2 = HTMLNodeType_1.TEXT_NODE;\n    /**\n     * Set the textContent property of a node, ensuring that whitespace is preserved\n     * even in IE8. innerText is a poor substitute for textContent and, among many\n     * issues, inserts <br> instead of the literal newline chars. innerHTML behaves\n     * as it should.\n     *\n     * @param {DOMElement} node\n     * @param {string} text\n     * @internal\n     */\n\n    var setTextContent = function setTextContent(node, text) {\n      if (text) {\n        var firstChild = node.firstChild;\n\n        if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE$2) {\n          firstChild.nodeValue = text;\n          return;\n        }\n      }\n\n      node.textContent = text;\n    };\n\n    if (ExecutionEnvironment.canUseDOM) {\n      if (!('textContent' in document.documentElement)) {\n        setTextContent = function setTextContent(node, text) {\n          if (node.nodeType === TEXT_NODE$2) {\n            node.nodeValue = text;\n            return;\n          }\n\n          setInnerHTML_1(node, escapeTextContentForBrowser_1(text));\n        };\n      }\n    }\n\n    var setTextContent_1 = setTextContent;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule validAriaProperties\n     */\n\n    var ariaProperties = {\n      'aria-current': 0,\n      // state\n      'aria-details': 0,\n      'aria-disabled': 0,\n      // state\n      'aria-hidden': 0,\n      // state\n      'aria-invalid': 0,\n      // state\n      'aria-keyshortcuts': 0,\n      'aria-label': 0,\n      'aria-roledescription': 0,\n      // Widget Attributes\n      'aria-autocomplete': 0,\n      'aria-checked': 0,\n      'aria-expanded': 0,\n      'aria-haspopup': 0,\n      'aria-level': 0,\n      'aria-modal': 0,\n      'aria-multiline': 0,\n      'aria-multiselectable': 0,\n      'aria-orientation': 0,\n      'aria-placeholder': 0,\n      'aria-pressed': 0,\n      'aria-readonly': 0,\n      'aria-required': 0,\n      'aria-selected': 0,\n      'aria-sort': 0,\n      'aria-valuemax': 0,\n      'aria-valuemin': 0,\n      'aria-valuenow': 0,\n      'aria-valuetext': 0,\n      // Live Region Attributes\n      'aria-atomic': 0,\n      'aria-busy': 0,\n      'aria-live': 0,\n      'aria-relevant': 0,\n      // Drag-and-Drop Attributes\n      'aria-dropeffect': 0,\n      'aria-grabbed': 0,\n      // Relationship Attributes\n      'aria-activedescendant': 0,\n      'aria-colcount': 0,\n      'aria-colindex': 0,\n      'aria-colspan': 0,\n      'aria-controls': 0,\n      'aria-describedby': 0,\n      'aria-errormessage': 0,\n      'aria-flowto': 0,\n      'aria-labelledby': 0,\n      'aria-owns': 0,\n      'aria-posinset': 0,\n      'aria-rowcount': 0,\n      'aria-rowindex': 0,\n      'aria-rowspan': 0,\n      'aria-setsize': 0\n    };\n    var validAriaProperties$1 = ariaProperties;\n    var warnedProperties = {};\n    var rARIA = new RegExp('^(aria)-[' + DOMProperty_1.ATTRIBUTE_NAME_CHAR + ']*$');\n    var rARIACamel = new RegExp('^(aria)[A-Z][' + DOMProperty_1.ATTRIBUTE_NAME_CHAR + ']*$');\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    {\n      var warning$14 = require$$0;\n      var _require$5 = ReactGlobalSharedState_1,\n          ReactComponentTreeHook$1 = _require$5.ReactComponentTreeHook,\n          ReactDebugCurrentFrame$1 = _require$5.ReactDebugCurrentFrame;\n      var getStackAddendumByID = ReactComponentTreeHook$1.getStackAddendumByID;\n      var validAriaProperties = validAriaProperties$1;\n    }\n\n    function getStackAddendum(debugID) {\n      if (debugID != null) {\n        // This can only happen on Stack\n        return getStackAddendumByID(debugID);\n      } else {\n        // This can only happen on Fiber / Server\n        var stack = ReactDebugCurrentFrame$1.getStackAddendum();\n        return stack != null ? stack : '';\n      }\n    }\n\n    function validateProperty(tagName, name, debugID) {\n      if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n        return true;\n      }\n\n      if (rARIACamel.test(name)) {\n        var ariaName = 'aria-' + name.slice(4).toLowerCase();\n        var correctName = validAriaProperties.hasOwnProperty(ariaName) ? ariaName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n        // DOM properties, then it is an invalid aria-* attribute.\n\n        if (correctName == null) {\n          warning$14(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s', name, getStackAddendum(debugID));\n          warnedProperties[name] = true;\n          return true;\n        } // aria-* attributes should be lowercase; suggest the lowercase version.\n\n\n        if (name !== correctName) {\n          warning$14(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?%s', name, correctName, getStackAddendum(debugID));\n          warnedProperties[name] = true;\n          return true;\n        }\n      }\n\n      if (rARIA.test(name)) {\n        var lowerCasedName = name.toLowerCase();\n        var standardName = validAriaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null; // If this is an aria-* attribute, but is not listed in the known DOM\n        // DOM properties, then it is an invalid aria-* attribute.\n\n        if (standardName == null) {\n          warnedProperties[name] = true;\n          return false;\n        } // aria-* attributes should be lowercase; suggest the lowercase version.\n\n\n        if (name !== standardName) {\n          warning$14(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum(debugID));\n          warnedProperties[name] = true;\n          return true;\n        }\n      }\n\n      return true;\n    }\n\n    function warnInvalidARIAProps(type, props, debugID) {\n      var invalidProps = [];\n\n      for (var key in props) {\n        var isValid = validateProperty(type, key, debugID);\n\n        if (!isValid) {\n          invalidProps.push(key);\n        }\n      }\n\n      var unknownPropString = invalidProps.map(function (prop) {\n        return '`' + prop + '`';\n      }).join(', ');\n\n      if (invalidProps.length === 1) {\n        warning$14(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum(debugID));\n      } else if (invalidProps.length > 1) {\n        warning$14(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, type, getStackAddendum(debugID));\n      }\n    }\n\n    function validateProperties(type, props, debugID\n    /* Stack only */\n    ) {\n      if (isCustomComponent_1(type, props)) {\n        return;\n      }\n\n      warnInvalidARIAProps(type, props, debugID);\n    }\n\n    var ReactDOMInvalidARIAHook$1 = {\n      // Fiber\n      validateProperties: validateProperties,\n      // Stack\n      onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {\n        if (true && element != null && typeof element.type === 'string') {\n          validateProperties(element.type, element.props, debugID);\n        }\n      },\n      onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {\n        if (true && element != null && typeof element.type === 'string') {\n          validateProperties(element.type, element.props, debugID);\n        }\n      }\n    };\n    var ReactDOMInvalidARIAHook_1 = ReactDOMInvalidARIAHook$1;\n    {\n      var warning$15 = require$$0;\n      var _require$6 = ReactGlobalSharedState_1,\n          ReactComponentTreeHook$2 = _require$6.ReactComponentTreeHook,\n          ReactDebugCurrentFrame$2 = _require$6.ReactDebugCurrentFrame;\n      var getStackAddendumByID$1 = ReactComponentTreeHook$2.getStackAddendumByID;\n    }\n    var didWarnValueNull = false;\n\n    function getStackAddendum$1(debugID) {\n      if (debugID != null) {\n        // This can only happen on Stack\n        return getStackAddendumByID$1(debugID);\n      } else {\n        // This can only happen on Fiber / Server\n        var stack = ReactDebugCurrentFrame$2.getStackAddendum();\n        return stack != null ? stack : '';\n      }\n    }\n\n    function validateProperties$1(type, props, debugID\n    /* Stack only */\n    ) {\n      if (type !== 'input' && type !== 'textarea' && type !== 'select') {\n        return;\n      }\n\n      if (props != null && props.value === null && !didWarnValueNull) {\n        warning$15(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', type, getStackAddendum$1(debugID));\n        didWarnValueNull = true;\n      }\n    }\n\n    var ReactDOMNullInputValuePropHook$1 = {\n      // Fiber\n      validateProperties: validateProperties$1,\n      // Stack\n      onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {\n        if (true && element != null && typeof element.type === 'string') {\n          validateProperties$1(element.type, element.props, debugID);\n        }\n      },\n      onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {\n        if (true && element != null && typeof element.type === 'string') {\n          validateProperties$1(element.type, element.props, debugID);\n        }\n      }\n    };\n    var ReactDOMNullInputValuePropHook_1 = ReactDOMNullInputValuePropHook$1;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule possibleStandardNames\n     */\n    // When adding attributes to the HTML or SVG whitelist, be sure to\n    // also add them to this module to ensure casing and incorrect name\n    // warnings.\n\n    var possibleStandardNames$1 = {\n      // HTML\n      accept: 'accept',\n      acceptcharset: 'acceptCharset',\n      'accept-charset': 'acceptCharset',\n      accesskey: 'accessKey',\n      action: 'action',\n      allowfullscreen: 'allowFullScreen',\n      allowtransparency: 'allowTransparency',\n      alt: 'alt',\n      as: 'as',\n      async: 'async',\n      autocapitalize: 'autoCapitalize',\n      autocomplete: 'autoComplete',\n      autocorrect: 'autoCorrect',\n      autofocus: 'autoFocus',\n      autoplay: 'autoPlay',\n      autosave: 'autoSave',\n      capture: 'capture',\n      cellpadding: 'cellPadding',\n      cellspacing: 'cellSpacing',\n      challenge: 'challenge',\n      charset: 'charSet',\n      checked: 'checked',\n      children: 'children',\n      cite: 'cite',\n      'class': 'className',\n      classid: 'classID',\n      classname: 'className',\n      cols: 'cols',\n      colspan: 'colSpan',\n      content: 'content',\n      contenteditable: 'contentEditable',\n      contextmenu: 'contextMenu',\n      controls: 'controls',\n      controlslist: 'controlsList',\n      coords: 'coords',\n      crossorigin: 'crossOrigin',\n      dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',\n      data: 'data',\n      datetime: 'dateTime',\n      'default': 'default',\n      defaultchecked: 'defaultChecked',\n      defaultvalue: 'defaultValue',\n      defer: 'defer',\n      dir: 'dir',\n      disabled: 'disabled',\n      download: 'download',\n      draggable: 'draggable',\n      enctype: 'encType',\n      'for': 'htmlFor',\n      form: 'form',\n      formmethod: 'formMethod',\n      formaction: 'formAction',\n      formenctype: 'formEncType',\n      formnovalidate: 'formNoValidate',\n      formtarget: 'formTarget',\n      frameborder: 'frameBorder',\n      headers: 'headers',\n      height: 'height',\n      hidden: 'hidden',\n      high: 'high',\n      href: 'href',\n      hreflang: 'hrefLang',\n      htmlfor: 'htmlFor',\n      httpequiv: 'httpEquiv',\n      'http-equiv': 'httpEquiv',\n      icon: 'icon',\n      id: 'id',\n      innerhtml: 'innerHTML',\n      inputmode: 'inputMode',\n      integrity: 'integrity',\n      is: 'is',\n      itemid: 'itemID',\n      itemprop: 'itemProp',\n      itemref: 'itemRef',\n      itemscope: 'itemScope',\n      itemtype: 'itemType',\n      keyparams: 'keyParams',\n      keytype: 'keyType',\n      kind: 'kind',\n      label: 'label',\n      lang: 'lang',\n      list: 'list',\n      loop: 'loop',\n      low: 'low',\n      manifest: 'manifest',\n      marginwidth: 'marginWidth',\n      marginheight: 'marginHeight',\n      max: 'max',\n      maxlength: 'maxLength',\n      media: 'media',\n      mediagroup: 'mediaGroup',\n      method: 'method',\n      min: 'min',\n      minlength: 'minLength',\n      multiple: 'multiple',\n      muted: 'muted',\n      name: 'name',\n      nonce: 'nonce',\n      novalidate: 'noValidate',\n      open: 'open',\n      optimum: 'optimum',\n      pattern: 'pattern',\n      placeholder: 'placeholder',\n      playsinline: 'playsInline',\n      poster: 'poster',\n      preload: 'preload',\n      profile: 'profile',\n      radiogroup: 'radioGroup',\n      readonly: 'readOnly',\n      referrerpolicy: 'referrerPolicy',\n      rel: 'rel',\n      required: 'required',\n      reversed: 'reversed',\n      role: 'role',\n      rows: 'rows',\n      rowspan: 'rowSpan',\n      sandbox: 'sandbox',\n      scope: 'scope',\n      scoped: 'scoped',\n      scrolling: 'scrolling',\n      seamless: 'seamless',\n      selected: 'selected',\n      shape: 'shape',\n      size: 'size',\n      sizes: 'sizes',\n      span: 'span',\n      spellcheck: 'spellCheck',\n      src: 'src',\n      srcdoc: 'srcDoc',\n      srclang: 'srcLang',\n      srcset: 'srcSet',\n      start: 'start',\n      step: 'step',\n      style: 'style',\n      summary: 'summary',\n      tabindex: 'tabIndex',\n      target: 'target',\n      title: 'title',\n      type: 'type',\n      usemap: 'useMap',\n      value: 'value',\n      width: 'width',\n      wmode: 'wmode',\n      wrap: 'wrap',\n      // SVG\n      about: 'about',\n      accentheight: 'accentHeight',\n      'accent-height': 'accentHeight',\n      accumulate: 'accumulate',\n      additive: 'additive',\n      alignmentbaseline: 'alignmentBaseline',\n      'alignment-baseline': 'alignmentBaseline',\n      allowreorder: 'allowReorder',\n      alphabetic: 'alphabetic',\n      amplitude: 'amplitude',\n      arabicform: 'arabicForm',\n      'arabic-form': 'arabicForm',\n      ascent: 'ascent',\n      attributename: 'attributeName',\n      attributetype: 'attributeType',\n      autoreverse: 'autoReverse',\n      azimuth: 'azimuth',\n      basefrequency: 'baseFrequency',\n      baselineshift: 'baselineShift',\n      'baseline-shift': 'baselineShift',\n      baseprofile: 'baseProfile',\n      bbox: 'bbox',\n      begin: 'begin',\n      bias: 'bias',\n      by: 'by',\n      calcmode: 'calcMode',\n      capheight: 'capHeight',\n      'cap-height': 'capHeight',\n      clip: 'clip',\n      clippath: 'clipPath',\n      'clip-path': 'clipPath',\n      clippathunits: 'clipPathUnits',\n      cliprule: 'clipRule',\n      'clip-rule': 'clipRule',\n      color: 'color',\n      colorinterpolation: 'colorInterpolation',\n      'color-interpolation': 'colorInterpolation',\n      colorinterpolationfilters: 'colorInterpolationFilters',\n      'color-interpolation-filters': 'colorInterpolationFilters',\n      colorprofile: 'colorProfile',\n      'color-profile': 'colorProfile',\n      colorrendering: 'colorRendering',\n      'color-rendering': 'colorRendering',\n      contentscripttype: 'contentScriptType',\n      contentstyletype: 'contentStyleType',\n      cursor: 'cursor',\n      cx: 'cx',\n      cy: 'cy',\n      d: 'd',\n      datatype: 'datatype',\n      decelerate: 'decelerate',\n      descent: 'descent',\n      diffuseconstant: 'diffuseConstant',\n      direction: 'direction',\n      display: 'display',\n      divisor: 'divisor',\n      dominantbaseline: 'dominantBaseline',\n      'dominant-baseline': 'dominantBaseline',\n      dur: 'dur',\n      dx: 'dx',\n      dy: 'dy',\n      edgemode: 'edgeMode',\n      elevation: 'elevation',\n      enablebackground: 'enableBackground',\n      'enable-background': 'enableBackground',\n      end: 'end',\n      exponent: 'exponent',\n      externalresourcesrequired: 'externalResourcesRequired',\n      fill: 'fill',\n      fillopacity: 'fillOpacity',\n      'fill-opacity': 'fillOpacity',\n      fillrule: 'fillRule',\n      'fill-rule': 'fillRule',\n      filter: 'filter',\n      filterres: 'filterRes',\n      filterunits: 'filterUnits',\n      floodopacity: 'floodOpacity',\n      'flood-opacity': 'floodOpacity',\n      floodcolor: 'floodColor',\n      'flood-color': 'floodColor',\n      focusable: 'focusable',\n      fontfamily: 'fontFamily',\n      'font-family': 'fontFamily',\n      fontsize: 'fontSize',\n      'font-size': 'fontSize',\n      fontsizeadjust: 'fontSizeAdjust',\n      'font-size-adjust': 'fontSizeAdjust',\n      fontstretch: 'fontStretch',\n      'font-stretch': 'fontStretch',\n      fontstyle: 'fontStyle',\n      'font-style': 'fontStyle',\n      fontvariant: 'fontVariant',\n      'font-variant': 'fontVariant',\n      fontweight: 'fontWeight',\n      'font-weight': 'fontWeight',\n      format: 'format',\n      from: 'from',\n      fx: 'fx',\n      fy: 'fy',\n      g1: 'g1',\n      g2: 'g2',\n      glyphname: 'glyphName',\n      'glyph-name': 'glyphName',\n      glyphorientationhorizontal: 'glyphOrientationHorizontal',\n      'glyph-orientation-horizontal': 'glyphOrientationHorizontal',\n      glyphorientationvertical: 'glyphOrientationVertical',\n      'glyph-orientation-vertical': 'glyphOrientationVertical',\n      glyphref: 'glyphRef',\n      gradienttransform: 'gradientTransform',\n      gradientunits: 'gradientUnits',\n      hanging: 'hanging',\n      horizadvx: 'horizAdvX',\n      'horiz-adv-x': 'horizAdvX',\n      horizoriginx: 'horizOriginX',\n      'horiz-origin-x': 'horizOriginX',\n      ideographic: 'ideographic',\n      imagerendering: 'imageRendering',\n      'image-rendering': 'imageRendering',\n      in2: 'in2',\n      'in': 'in',\n      inlist: 'inlist',\n      intercept: 'intercept',\n      k1: 'k1',\n      k2: 'k2',\n      k3: 'k3',\n      k4: 'k4',\n      k: 'k',\n      kernelmatrix: 'kernelMatrix',\n      kernelunitlength: 'kernelUnitLength',\n      kerning: 'kerning',\n      keypoints: 'keyPoints',\n      keysplines: 'keySplines',\n      keytimes: 'keyTimes',\n      lengthadjust: 'lengthAdjust',\n      letterspacing: 'letterSpacing',\n      'letter-spacing': 'letterSpacing',\n      lightingcolor: 'lightingColor',\n      'lighting-color': 'lightingColor',\n      limitingconeangle: 'limitingConeAngle',\n      local: 'local',\n      markerend: 'markerEnd',\n      'marker-end': 'markerEnd',\n      markerheight: 'markerHeight',\n      markermid: 'markerMid',\n      'marker-mid': 'markerMid',\n      markerstart: 'markerStart',\n      'marker-start': 'markerStart',\n      markerunits: 'markerUnits',\n      markerwidth: 'markerWidth',\n      mask: 'mask',\n      maskcontentunits: 'maskContentUnits',\n      maskunits: 'maskUnits',\n      mathematical: 'mathematical',\n      mode: 'mode',\n      numoctaves: 'numOctaves',\n      offset: 'offset',\n      opacity: 'opacity',\n      operator: 'operator',\n      order: 'order',\n      orient: 'orient',\n      orientation: 'orientation',\n      origin: 'origin',\n      overflow: 'overflow',\n      overlineposition: 'overlinePosition',\n      'overline-position': 'overlinePosition',\n      overlinethickness: 'overlineThickness',\n      'overline-thickness': 'overlineThickness',\n      paintorder: 'paintOrder',\n      'paint-order': 'paintOrder',\n      panose1: 'panose1',\n      'panose-1': 'panose1',\n      pathlength: 'pathLength',\n      patterncontentunits: 'patternContentUnits',\n      patterntransform: 'patternTransform',\n      patternunits: 'patternUnits',\n      pointerevents: 'pointerEvents',\n      'pointer-events': 'pointerEvents',\n      points: 'points',\n      pointsatx: 'pointsAtX',\n      pointsaty: 'pointsAtY',\n      pointsatz: 'pointsAtZ',\n      prefix: 'prefix',\n      preservealpha: 'preserveAlpha',\n      preserveaspectratio: 'preserveAspectRatio',\n      primitiveunits: 'primitiveUnits',\n      property: 'property',\n      r: 'r',\n      radius: 'radius',\n      refx: 'refX',\n      refy: 'refY',\n      renderingintent: 'renderingIntent',\n      'rendering-intent': 'renderingIntent',\n      repeatcount: 'repeatCount',\n      repeatdur: 'repeatDur',\n      requiredextensions: 'requiredExtensions',\n      requiredfeatures: 'requiredFeatures',\n      resource: 'resource',\n      restart: 'restart',\n      result: 'result',\n      results: 'results',\n      rotate: 'rotate',\n      rx: 'rx',\n      ry: 'ry',\n      scale: 'scale',\n      security: 'security',\n      seed: 'seed',\n      shaperendering: 'shapeRendering',\n      'shape-rendering': 'shapeRendering',\n      slope: 'slope',\n      spacing: 'spacing',\n      specularconstant: 'specularConstant',\n      specularexponent: 'specularExponent',\n      speed: 'speed',\n      spreadmethod: 'spreadMethod',\n      startoffset: 'startOffset',\n      stddeviation: 'stdDeviation',\n      stemh: 'stemh',\n      stemv: 'stemv',\n      stitchtiles: 'stitchTiles',\n      stopcolor: 'stopColor',\n      'stop-color': 'stopColor',\n      stopopacity: 'stopOpacity',\n      'stop-opacity': 'stopOpacity',\n      strikethroughposition: 'strikethroughPosition',\n      'strikethrough-position': 'strikethroughPosition',\n      strikethroughthickness: 'strikethroughThickness',\n      'strikethrough-thickness': 'strikethroughThickness',\n      string: 'string',\n      stroke: 'stroke',\n      strokedasharray: 'strokeDasharray',\n      'stroke-dasharray': 'strokeDasharray',\n      strokedashoffset: 'strokeDashoffset',\n      'stroke-dashoffset': 'strokeDashoffset',\n      strokelinecap: 'strokeLinecap',\n      'stroke-linecap': 'strokeLinecap',\n      strokelinejoin: 'strokeLinejoin',\n      'stroke-linejoin': 'strokeLinejoin',\n      strokemiterlimit: 'strokeMiterlimit',\n      'stroke-miterlimit': 'strokeMiterlimit',\n      strokewidth: 'strokeWidth',\n      'stroke-width': 'strokeWidth',\n      strokeopacity: 'strokeOpacity',\n      'stroke-opacity': 'strokeOpacity',\n      suppresscontenteditablewarning: 'suppressContentEditableWarning',\n      surfacescale: 'surfaceScale',\n      systemlanguage: 'systemLanguage',\n      tablevalues: 'tableValues',\n      targetx: 'targetX',\n      targety: 'targetY',\n      textanchor: 'textAnchor',\n      'text-anchor': 'textAnchor',\n      textdecoration: 'textDecoration',\n      'text-decoration': 'textDecoration',\n      textlength: 'textLength',\n      textrendering: 'textRendering',\n      'text-rendering': 'textRendering',\n      to: 'to',\n      transform: 'transform',\n      'typeof': 'typeof',\n      u1: 'u1',\n      u2: 'u2',\n      underlineposition: 'underlinePosition',\n      'underline-position': 'underlinePosition',\n      underlinethickness: 'underlineThickness',\n      'underline-thickness': 'underlineThickness',\n      unicode: 'unicode',\n      unicodebidi: 'unicodeBidi',\n      'unicode-bidi': 'unicodeBidi',\n      unicoderange: 'unicodeRange',\n      'unicode-range': 'unicodeRange',\n      unitsperem: 'unitsPerEm',\n      'units-per-em': 'unitsPerEm',\n      unselectable: 'unselectable',\n      valphabetic: 'vAlphabetic',\n      'v-alphabetic': 'vAlphabetic',\n      values: 'values',\n      vectoreffect: 'vectorEffect',\n      'vector-effect': 'vectorEffect',\n      version: 'version',\n      vertadvy: 'vertAdvY',\n      'vert-adv-y': 'vertAdvY',\n      vertoriginx: 'vertOriginX',\n      'vert-origin-x': 'vertOriginX',\n      vertoriginy: 'vertOriginY',\n      'vert-origin-y': 'vertOriginY',\n      vhanging: 'vHanging',\n      'v-hanging': 'vHanging',\n      videographic: 'vIdeographic',\n      'v-ideographic': 'vIdeographic',\n      viewbox: 'viewBox',\n      viewtarget: 'viewTarget',\n      visibility: 'visibility',\n      vmathematical: 'vMathematical',\n      'v-mathematical': 'vMathematical',\n      vocab: 'vocab',\n      widths: 'widths',\n      wordspacing: 'wordSpacing',\n      'word-spacing': 'wordSpacing',\n      writingmode: 'writingMode',\n      'writing-mode': 'writingMode',\n      x1: 'x1',\n      x2: 'x2',\n      x: 'x',\n      xchannelselector: 'xChannelSelector',\n      xheight: 'xHeight',\n      'x-height': 'xHeight',\n      xlinkactuate: 'xlinkActuate',\n      'xlink:actuate': 'xlinkActuate',\n      xlinkarcrole: 'xlinkArcrole',\n      'xlink:arcrole': 'xlinkArcrole',\n      xlinkhref: 'xlinkHref',\n      'xlink:href': 'xlinkHref',\n      xlinkrole: 'xlinkRole',\n      'xlink:role': 'xlinkRole',\n      xlinkshow: 'xlinkShow',\n      'xlink:show': 'xlinkShow',\n      xlinktitle: 'xlinkTitle',\n      'xlink:title': 'xlinkTitle',\n      xlinktype: 'xlinkType',\n      'xlink:type': 'xlinkType',\n      xmlbase: 'xmlBase',\n      'xml:base': 'xmlBase',\n      xmllang: 'xmlLang',\n      'xml:lang': 'xmlLang',\n      xmlns: 'xmlns',\n      'xml:space': 'xmlSpace',\n      xmlnsxlink: 'xmlnsXlink',\n      'xmlns:xlink': 'xmlnsXlink',\n      xmlspace: 'xmlSpace',\n      y1: 'y1',\n      y2: 'y2',\n      y: 'y',\n      ychannelselector: 'yChannelSelector',\n      z: 'z',\n      zoomandpan: 'zoomAndPan'\n    };\n    var possibleStandardNames_1 = possibleStandardNames$1;\n    {\n      var warning$16 = require$$0;\n      var _require$7 = ReactGlobalSharedState_1,\n          ReactComponentTreeHook$3 = _require$7.ReactComponentTreeHook,\n          ReactDebugCurrentFrame$3 = _require$7.ReactDebugCurrentFrame;\n      var getStackAddendumByID$2 = ReactComponentTreeHook$3.getStackAddendumByID;\n    }\n\n    function getStackAddendum$2(debugID) {\n      if (debugID != null) {\n        // This can only happen on Stack\n        return getStackAddendumByID$2(debugID);\n      } else {\n        // This can only happen on Fiber / Server\n        var stack = ReactDebugCurrentFrame$3.getStackAddendum();\n        return stack != null ? stack : '';\n      }\n    }\n\n    {\n      var warnedProperties$1 = {};\n      var hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n      var EVENT_NAME_REGEX = /^on[A-Z]/;\n      var rARIA$1 = new RegExp('^(aria)-[' + DOMProperty_1.ATTRIBUTE_NAME_CHAR + ']*$');\n      var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + DOMProperty_1.ATTRIBUTE_NAME_CHAR + ']*$');\n      var possibleStandardNames = possibleStandardNames_1;\n\n      var validateProperty$1 = function validateProperty$1(tagName, name, value, debugID) {\n        if (hasOwnProperty$1.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n          return true;\n        }\n\n        if (EventPluginRegistry_1.registrationNameModules.hasOwnProperty(name)) {\n          return true;\n        }\n\n        if (EventPluginRegistry_1.plugins.length === 0 && EVENT_NAME_REGEX.test(name)) {\n          // If no event plugins have been injected, we might be in a server environment.\n          // Don't check events in this case.\n          return true;\n        }\n\n        var lowerCasedName = name.toLowerCase();\n        var registrationName = EventPluginRegistry_1.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry_1.possibleRegistrationNames[lowerCasedName] : null;\n\n        if (registrationName != null) {\n          warning$16(false, 'Invalid event handler property `%s`. Did you mean `%s`?%s', name, registrationName, getStackAddendum$2(debugID));\n          warnedProperties$1[name] = true;\n          return true;\n        }\n\n        if (lowerCasedName.indexOf('on') === 0) {\n          warning$16(false, 'Unknown event handler property `%s`. It will be ignored.%s', name, getStackAddendum$2(debugID));\n          warnedProperties$1[name] = true;\n          return true;\n        } // Let the ARIA attribute hook validate ARIA attributes\n\n\n        if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n          return true;\n        }\n\n        if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {\n          warning$16(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');\n          warnedProperties$1[name] = true;\n          return true;\n        }\n\n        if (lowerCasedName === 'innerhtml') {\n          warning$16(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');\n          warnedProperties$1[name] = true;\n          return true;\n        }\n\n        if (lowerCasedName === 'aria') {\n          warning$16(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');\n          warnedProperties$1[name] = true;\n          return true;\n        }\n\n        if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {\n          warning$16(false, 'Received a `%s` for string attribute `is`. If this is expected, cast ' + 'the value to a string.%s', typeof value, getStackAddendum$2(debugID));\n          warnedProperties$1[name] = true;\n          return true;\n        }\n\n        if (typeof value === 'number' && isNaN(value)) {\n          warning$16(false, 'Received NaN for numeric attribute `%s`. If this is expected, cast ' + 'the value to a string.%s', name, getStackAddendum$2(debugID));\n          warnedProperties$1[name] = true;\n          return true;\n        }\n\n        var isReserved = DOMProperty_1.isReservedProp(name); // Known attributes should match the casing specified in the property config.\n\n        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n          var standardName = possibleStandardNames[lowerCasedName];\n\n          if (standardName !== name) {\n            warning$16(false, 'Invalid DOM property `%s`. Did you mean `%s`?%s', name, standardName, getStackAddendum$2(debugID));\n            warnedProperties$1[name] = true;\n            return true;\n          }\n        } else if (!isReserved && name !== lowerCasedName) {\n          // Unknown attributes should have lowercase casing since that's how they\n          // will be cased anyway with server rendering.\n          warning$16(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.%s', name, lowerCasedName, getStackAddendum$2(debugID));\n          warnedProperties$1[name] = true;\n          return true;\n        }\n\n        if (typeof value === 'boolean') {\n          warning$16(DOMProperty_1.shouldAttributeAcceptBooleanValue(name), 'Received `%s` for non-boolean attribute `%s`. If this is expected, cast ' + 'the value to a string.%s', value, name, getStackAddendum$2(debugID));\n          warnedProperties$1[name] = true;\n          return true;\n        } // Now that we've validated casing, do not validate\n        // data types for reserved props\n\n\n        if (isReserved) {\n          return true;\n        } // Warn when a known attribute is a bad type\n\n\n        if (!DOMProperty_1.shouldSetAttribute(name, value)) {\n          warnedProperties$1[name] = true;\n          return false;\n        }\n\n        return true;\n      };\n    }\n\n    var warnUnknownProperties = function warnUnknownProperties(type, props, debugID) {\n      var unknownProps = [];\n\n      for (var key in props) {\n        var isValid = validateProperty$1(type, key, props[key], debugID);\n\n        if (!isValid) {\n          unknownProps.push(key);\n        }\n      }\n\n      var unknownPropString = unknownProps.map(function (prop) {\n        return '`' + prop + '`';\n      }).join(', ');\n\n      if (unknownProps.length === 1) {\n        warning$16(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2(debugID));\n      } else if (unknownProps.length > 1) {\n        warning$16(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior%s', unknownPropString, type, getStackAddendum$2(debugID));\n      }\n    };\n\n    function validateProperties$2(type, props, debugID\n    /* Stack only */\n    ) {\n      if (isCustomComponent_1(type, props)) {\n        return;\n      }\n\n      warnUnknownProperties(type, props, debugID);\n    }\n\n    var ReactDOMUnknownPropertyHook$1 = {\n      // Fiber\n      validateProperties: validateProperties$2,\n      // Stack\n      onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {\n        if (true && element != null && typeof element.type === 'string') {\n          validateProperties$2(element.type, element.props, debugID);\n        }\n      },\n      onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {\n        if (true && element != null && typeof element.type === 'string') {\n          validateProperties$2(element.type, element.props, debugID);\n        }\n      }\n    };\n    var ReactDOMUnknownPropertyHook_1 = ReactDOMUnknownPropertyHook$1;\n    var getCurrentFiberOwnerName = ReactDebugCurrentFiber_1.getCurrentFiberOwnerName;\n    var DOCUMENT_NODE$1 = HTMLNodeType_1.DOCUMENT_NODE;\n    var DOCUMENT_FRAGMENT_NODE$1 = HTMLNodeType_1.DOCUMENT_FRAGMENT_NODE;\n    {\n      var warning$3 = require$$0;\n      var _require3$1 = ReactDebugCurrentFiber_1,\n          getCurrentFiberStackAddendum = _require3$1.getCurrentFiberStackAddendum;\n      var ReactDOMInvalidARIAHook = ReactDOMInvalidARIAHook_1;\n      var ReactDOMNullInputValuePropHook = ReactDOMNullInputValuePropHook_1;\n      var ReactDOMUnknownPropertyHook = ReactDOMUnknownPropertyHook_1;\n      var validateARIAProperties = ReactDOMInvalidARIAHook.validateProperties;\n      var validateInputProperties = ReactDOMNullInputValuePropHook.validateProperties;\n      var validateUnknownProperties = ReactDOMUnknownPropertyHook.validateProperties;\n    }\n    var didWarnInvalidHydration = false;\n    var didWarnShadyDOM = false;\n    var listenTo = ReactBrowserEventEmitter_1.listenTo;\n    var registrationNameModules = EventPluginRegistry_1.registrationNameModules;\n    var DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';\n    var SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';\n    var CHILDREN = 'children';\n    var STYLE = 'style';\n    var HTML = '__html';\n    var HTML_NAMESPACE$1 = DOMNamespaces.Namespaces.html;\n    var getIntrinsicNamespace$1 = DOMNamespaces.getIntrinsicNamespace;\n    {\n      var warnedUnknownTags = {\n        // Chrome is the only major browser not shipping <time>. But as of July\n        // 2017 it intends to ship it due to widespread usage. We intentionally\n        // *don't* warn for <time> even if it's unrecognized by Chrome because\n        // it soon will be, and many apps have been using it anyway.\n        time: true\n      };\n\n      var validatePropertiesInDevelopment = function validatePropertiesInDevelopment(type, props) {\n        validateARIAProperties(type, props);\n        validateInputProperties(type, props);\n        validateUnknownProperties(type, props);\n      };\n\n      var warnForTextDifference = function warnForTextDifference(serverText, clientText) {\n        if (didWarnInvalidHydration) {\n          return;\n        }\n\n        didWarnInvalidHydration = true;\n        warning$3(false, 'Text content did not match. Server: \"%s\" Client: \"%s\"', serverText, clientText);\n      };\n\n      var warnForPropDifference = function warnForPropDifference(propName, serverValue, clientValue) {\n        if (didWarnInvalidHydration) {\n          return;\n        }\n\n        didWarnInvalidHydration = true;\n        warning$3(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(serverValue), JSON.stringify(clientValue));\n      };\n\n      var warnForExtraAttributes = function warnForExtraAttributes(attributeNames) {\n        if (didWarnInvalidHydration) {\n          return;\n        }\n\n        didWarnInvalidHydration = true;\n        var names = [];\n        attributeNames.forEach(function (name) {\n          names.push(name);\n        });\n        warning$3(false, 'Extra attributes from the server: %s', names);\n      };\n\n      var warnForInvalidEventListener = function warnForInvalidEventListener(registrationName, listener) {\n        warning$3(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.%s', registrationName, typeof listener, getCurrentFiberStackAddendum());\n      };\n\n      var testDocument; // Parse the HTML and read it back to normalize the HTML string so that it\n      // can be used for comparison.\n\n      var normalizeHTML = function normalizeHTML(parent, html) {\n        if (!testDocument) {\n          testDocument = document.implementation.createHTMLDocument();\n        }\n\n        var testElement = parent.namespaceURI === HTML_NAMESPACE$1 ? testDocument.createElement(parent.tagName) : testDocument.createElementNS(parent.namespaceURI, parent.tagName);\n        testElement.innerHTML = html;\n        return testElement.innerHTML;\n      };\n    }\n\n    function ensureListeningTo(rootContainerElement, registrationName) {\n      var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE$1 || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE$1;\n      var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;\n      listenTo(registrationName, doc);\n    }\n\n    function getOwnerDocumentFromRootContainer(rootContainerElement) {\n      return rootContainerElement.nodeType === DOCUMENT_NODE$1 ? rootContainerElement : rootContainerElement.ownerDocument;\n    } // There are so many media events, it makes sense to just\n    // maintain a list rather than create a `trapBubbledEvent` for each\n\n\n    var mediaEvents = {\n      topAbort: 'abort',\n      topCanPlay: 'canplay',\n      topCanPlayThrough: 'canplaythrough',\n      topDurationChange: 'durationchange',\n      topEmptied: 'emptied',\n      topEncrypted: 'encrypted',\n      topEnded: 'ended',\n      topError: 'error',\n      topLoadedData: 'loadeddata',\n      topLoadedMetadata: 'loadedmetadata',\n      topLoadStart: 'loadstart',\n      topPause: 'pause',\n      topPlay: 'play',\n      topPlaying: 'playing',\n      topProgress: 'progress',\n      topRateChange: 'ratechange',\n      topSeeked: 'seeked',\n      topSeeking: 'seeking',\n      topStalled: 'stalled',\n      topSuspend: 'suspend',\n      topTimeUpdate: 'timeupdate',\n      topVolumeChange: 'volumechange',\n      topWaiting: 'waiting'\n    };\n\n    function trapClickOnNonInteractiveElement(node) {\n      // Mobile Safari does not fire properly bubble click events on\n      // non-interactive elements, which means delegated click listeners do not\n      // fire. The workaround for this bug involves attaching an empty click\n      // listener on the target node.\n      // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n      // Just set it using the onclick property so that we don't have to manage any\n      // bookkeeping for it. Not sure if we need to clear it when the listener is\n      // removed.\n      // TODO: Only do this for the relevant Safaris maybe?\n      node.onclick = emptyFunction;\n    }\n\n    function setInitialDOMProperties(domElement, rootContainerElement, nextProps, isCustomComponentTag) {\n      for (var propKey in nextProps) {\n        if (!nextProps.hasOwnProperty(propKey)) {\n          continue;\n        }\n\n        var nextProp = nextProps[propKey];\n\n        if (propKey === STYLE) {\n          {\n            if (nextProp) {\n              // Freeze the next style object so that we can assume it won't be\n              // mutated. We have already warned for this in the past.\n              Object.freeze(nextProp);\n            }\n          } // Relies on `updateStylesByID` not mutating `styleUpdates`.\n\n          CSSPropertyOperations_1.setValueForStyles(domElement, nextProp);\n        } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n          var nextHtml = nextProp ? nextProp[HTML] : undefined;\n\n          if (nextHtml != null) {\n            setInnerHTML_1(domElement, nextHtml);\n          }\n        } else if (propKey === CHILDREN) {\n          if (typeof nextProp === 'string') {\n            setTextContent_1(domElement, nextProp);\n          } else if (typeof nextProp === 'number') {\n            setTextContent_1(domElement, '' + nextProp);\n          }\n        } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING) {// Noop\n        } else if (registrationNameModules.hasOwnProperty(propKey)) {\n          if (nextProp != null) {\n            if (true && typeof nextProp !== 'function') {\n              warnForInvalidEventListener(propKey, nextProp);\n            }\n\n            ensureListeningTo(rootContainerElement, propKey);\n          }\n        } else if (isCustomComponentTag) {\n          DOMPropertyOperations_1.setValueForAttribute(domElement, propKey, nextProp);\n        } else if (nextProp != null) {\n          // If we're updating to null or undefined, we should remove the property\n          // from the DOM node instead of inadvertently setting to a string. This\n          // brings us in line with the same behavior we have on initial render.\n          DOMPropertyOperations_1.setValueForProperty(domElement, propKey, nextProp);\n        }\n      }\n    }\n\n    function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\n      // TODO: Handle wasCustomComponentTag\n      for (var i = 0; i < updatePayload.length; i += 2) {\n        var propKey = updatePayload[i];\n        var propValue = updatePayload[i + 1];\n\n        if (propKey === STYLE) {\n          CSSPropertyOperations_1.setValueForStyles(domElement, propValue);\n        } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n          setInnerHTML_1(domElement, propValue);\n        } else if (propKey === CHILDREN) {\n          setTextContent_1(domElement, propValue);\n        } else if (isCustomComponentTag) {\n          if (propValue != null) {\n            DOMPropertyOperations_1.setValueForAttribute(domElement, propKey, propValue);\n          } else {\n            DOMPropertyOperations_1.deleteValueForAttribute(domElement, propKey);\n          }\n        } else if (propValue != null) {\n          DOMPropertyOperations_1.setValueForProperty(domElement, propKey, propValue);\n        } else {\n          // If we're updating to null or undefined, we should remove the property\n          // from the DOM node instead of inadvertently setting to a string. This\n          // brings us in line with the same behavior we have on initial render.\n          DOMPropertyOperations_1.deleteValueForProperty(domElement, propKey);\n        }\n      }\n    }\n\n    var ReactDOMFiberComponent = {\n      createElement: function createElement(type, props, rootContainerElement, parentNamespace) {\n        // We create tags in the namespace of their parent container, except HTML\n        var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\n        var domElement;\n        var namespaceURI = parentNamespace;\n\n        if (namespaceURI === HTML_NAMESPACE$1) {\n          namespaceURI = getIntrinsicNamespace$1(type);\n        }\n\n        if (namespaceURI === HTML_NAMESPACE$1) {\n          {\n            var isCustomComponentTag = isCustomComponent_1(type, props); // Should this check be gated by parent namespace? Not sure we want to\n            // allow <SVG> or <mATH>.\n\n            warning$3(isCustomComponentTag || type === type.toLowerCase(), '<%s /> is using uppercase HTML. Always use lowercase HTML tags ' + 'in React.', type);\n          }\n\n          if (type === 'script') {\n            // Create the script via .innerHTML so its \"parser-inserted\" flag is\n            // set to true and it does not execute\n            var div = ownerDocument.createElement('div');\n            div.innerHTML = '<script><' + '/script>'; // eslint-disable-line\n            // This is guaranteed to yield a script element.\n\n            var firstChild = div.firstChild;\n            domElement = div.removeChild(firstChild);\n          } else if (typeof props.is === 'string') {\n            // $FlowIssue `createElement` should be updated for Web Components\n            domElement = ownerDocument.createElement(type, {\n              is: props.is\n            });\n          } else {\n            // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n            // See discussion in https://github.com/facebook/react/pull/6896\n            // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\n            domElement = ownerDocument.createElement(type);\n          }\n        } else {\n          domElement = ownerDocument.createElementNS(namespaceURI, type);\n        }\n\n        {\n          if (namespaceURI === HTML_NAMESPACE$1) {\n            if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {\n              warnedUnknownTags[type] = true;\n              warning$3(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);\n            }\n          }\n        }\n        return domElement;\n      },\n      createTextNode: function createTextNode(text, rootContainerElement) {\n        return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\n      },\n      setInitialProperties: function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {\n        var isCustomComponentTag = isCustomComponent_1(tag, rawProps);\n        {\n          validatePropertiesInDevelopment(tag, rawProps);\n\n          if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n            warning$3(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName() || 'A component');\n            didWarnShadyDOM = true;\n          }\n        } // TODO: Make sure that we check isMounted before firing any of these events.\n\n        var props;\n\n        switch (tag) {\n          case 'iframe':\n          case 'object':\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topLoad', 'load', domElement);\n            props = rawProps;\n            break;\n\n          case 'video':\n          case 'audio':\n            // Create listener for each media event\n            for (var event in mediaEvents) {\n              if (mediaEvents.hasOwnProperty(event)) {\n                ReactBrowserEventEmitter_1.trapBubbledEvent(event, mediaEvents[event], domElement);\n              }\n            }\n\n            props = rawProps;\n            break;\n\n          case 'source':\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topError', 'error', domElement);\n            props = rawProps;\n            break;\n\n          case 'img':\n          case 'image':\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topError', 'error', domElement);\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topLoad', 'load', domElement);\n            props = rawProps;\n            break;\n\n          case 'form':\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topReset', 'reset', domElement);\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topSubmit', 'submit', domElement);\n            props = rawProps;\n            break;\n\n          case 'details':\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topToggle', 'toggle', domElement);\n            props = rawProps;\n            break;\n\n          case 'input':\n            ReactDOMFiberInput.initWrapperState(domElement, rawProps);\n            props = ReactDOMFiberInput.getHostProps(domElement, rawProps);\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening\n            // to onChange. Even if there is no listener.\n\n            ensureListeningTo(rootContainerElement, 'onChange');\n            break;\n\n          case 'option':\n            ReactDOMFiberOption.validateProps(domElement, rawProps);\n            props = ReactDOMFiberOption.getHostProps(domElement, rawProps);\n            break;\n\n          case 'select':\n            ReactDOMFiberSelect.initWrapperState(domElement, rawProps);\n            props = ReactDOMFiberSelect.getHostProps(domElement, rawProps);\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening\n            // to onChange. Even if there is no listener.\n\n            ensureListeningTo(rootContainerElement, 'onChange');\n            break;\n\n          case 'textarea':\n            ReactDOMFiberTextarea.initWrapperState(domElement, rawProps);\n            props = ReactDOMFiberTextarea.getHostProps(domElement, rawProps);\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening\n            // to onChange. Even if there is no listener.\n\n            ensureListeningTo(rootContainerElement, 'onChange');\n            break;\n\n          default:\n            props = rawProps;\n        }\n\n        assertValidProps_1(tag, props, getCurrentFiberOwnerName);\n        setInitialDOMProperties(domElement, rootContainerElement, props, isCustomComponentTag);\n\n        switch (tag) {\n          case 'input':\n            // TODO: Make sure we check if this is still unmounted or do any clean\n            // up necessary since we never stop tracking anymore.\n            inputValueTracking_1.track(domElement);\n            ReactDOMFiberInput.postMountWrapper(domElement, rawProps);\n            break;\n\n          case 'textarea':\n            // TODO: Make sure we check if this is still unmounted or do any clean\n            // up necessary since we never stop tracking anymore.\n            inputValueTracking_1.track(domElement);\n            ReactDOMFiberTextarea.postMountWrapper(domElement, rawProps);\n            break;\n\n          case 'option':\n            ReactDOMFiberOption.postMountWrapper(domElement, rawProps);\n            break;\n\n          case 'select':\n            ReactDOMFiberSelect.postMountWrapper(domElement, rawProps);\n            break;\n\n          default:\n            if (typeof props.onClick === 'function') {\n              // TODO: This cast may not be sound for SVG, MathML or custom elements.\n              trapClickOnNonInteractiveElement(domElement);\n            }\n\n            break;\n        }\n      },\n      // Calculate the diff between the two objects.\n      diffProperties: function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\n        {\n          validatePropertiesInDevelopment(tag, nextRawProps);\n        }\n        var updatePayload = null;\n        var lastProps;\n        var nextProps;\n\n        switch (tag) {\n          case 'input':\n            lastProps = ReactDOMFiberInput.getHostProps(domElement, lastRawProps);\n            nextProps = ReactDOMFiberInput.getHostProps(domElement, nextRawProps);\n            updatePayload = [];\n            break;\n\n          case 'option':\n            lastProps = ReactDOMFiberOption.getHostProps(domElement, lastRawProps);\n            nextProps = ReactDOMFiberOption.getHostProps(domElement, nextRawProps);\n            updatePayload = [];\n            break;\n\n          case 'select':\n            lastProps = ReactDOMFiberSelect.getHostProps(domElement, lastRawProps);\n            nextProps = ReactDOMFiberSelect.getHostProps(domElement, nextRawProps);\n            updatePayload = [];\n            break;\n\n          case 'textarea':\n            lastProps = ReactDOMFiberTextarea.getHostProps(domElement, lastRawProps);\n            nextProps = ReactDOMFiberTextarea.getHostProps(domElement, nextRawProps);\n            updatePayload = [];\n            break;\n\n          default:\n            lastProps = lastRawProps;\n            nextProps = nextRawProps;\n\n            if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {\n              // TODO: This cast may not be sound for SVG, MathML or custom elements.\n              trapClickOnNonInteractiveElement(domElement);\n            }\n\n            break;\n        }\n\n        assertValidProps_1(tag, nextProps, getCurrentFiberOwnerName);\n        var propKey;\n        var styleName;\n        var styleUpdates = null;\n\n        for (propKey in lastProps) {\n          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\n            continue;\n          }\n\n          if (propKey === STYLE) {\n            var lastStyle = lastProps[propKey];\n\n            for (styleName in lastStyle) {\n              if (lastStyle.hasOwnProperty(styleName)) {\n                if (!styleUpdates) {\n                  styleUpdates = {};\n                }\n\n                styleUpdates[styleName] = '';\n              }\n            }\n          } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {// Noop. This is handled by the clear text mechanism.\n          } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING) {// Noop\n          } else if (registrationNameModules.hasOwnProperty(propKey)) {\n            // This is a special case. If any listener updates we need to ensure\n            // that the \"current\" fiber pointer gets updated so we need a commit\n            // to update this element.\n            if (!updatePayload) {\n              updatePayload = [];\n            }\n          } else {\n            // For all other deleted properties we add it to the queue. We use\n            // the whitelist in the commit phase instead.\n            (updatePayload = updatePayload || []).push(propKey, null);\n          }\n        }\n\n        for (propKey in nextProps) {\n          var nextProp = nextProps[propKey];\n          var lastProp = lastProps != null ? lastProps[propKey] : undefined;\n\n          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\n            continue;\n          }\n\n          if (propKey === STYLE) {\n            {\n              if (nextProp) {\n                // Freeze the next style object so that we can assume it won't be\n                // mutated. We have already warned for this in the past.\n                Object.freeze(nextProp);\n              }\n            }\n\n            if (lastProp) {\n              // Unset styles on `lastProp` but not on `nextProp`.\n              for (styleName in lastProp) {\n                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n                  if (!styleUpdates) {\n                    styleUpdates = {};\n                  }\n\n                  styleUpdates[styleName] = '';\n                }\n              } // Update styles that changed since `lastProp`.\n\n\n              for (styleName in nextProp) {\n                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n                  if (!styleUpdates) {\n                    styleUpdates = {};\n                  }\n\n                  styleUpdates[styleName] = nextProp[styleName];\n                }\n              }\n            } else {\n              // Relies on `updateStylesByID` not mutating `styleUpdates`.\n              if (!styleUpdates) {\n                if (!updatePayload) {\n                  updatePayload = [];\n                }\n\n                updatePayload.push(propKey, styleUpdates);\n              }\n\n              styleUpdates = nextProp;\n            }\n          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n            var nextHtml = nextProp ? nextProp[HTML] : undefined;\n            var lastHtml = lastProp ? lastProp[HTML] : undefined;\n\n            if (nextHtml != null) {\n              if (lastHtml !== nextHtml) {\n                (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);\n              }\n            } else {// TODO: It might be too late to clear this if we have children\n              // inserted already.\n            }\n          } else if (propKey === CHILDREN) {\n            if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {\n              (updatePayload = updatePayload || []).push(propKey, '' + nextProp);\n            }\n          } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING) {// Noop\n          } else if (registrationNameModules.hasOwnProperty(propKey)) {\n            if (nextProp != null) {\n              // We eagerly listen to this even though we haven't committed yet.\n              if (true && typeof nextProp !== 'function') {\n                warnForInvalidEventListener(propKey, nextProp);\n              }\n\n              ensureListeningTo(rootContainerElement, propKey);\n            }\n\n            if (!updatePayload && lastProp !== nextProp) {\n              // This is a special case. If any listener updates we need to ensure\n              // that the \"current\" props pointer gets updated so we need a commit\n              // to update this element.\n              updatePayload = [];\n            }\n          } else {\n            // For any other property we always add it to the queue and then we\n            // filter it out using the whitelist during the commit.\n            (updatePayload = updatePayload || []).push(propKey, nextProp);\n          }\n        }\n\n        if (styleUpdates) {\n          (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\n        }\n\n        return updatePayload;\n      },\n      // Apply the diff.\n      updateProperties: function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\n        var wasCustomComponentTag = isCustomComponent_1(tag, lastRawProps);\n        var isCustomComponentTag = isCustomComponent_1(tag, nextRawProps); // Apply the diff.\n\n        updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag); // TODO: Ensure that an update gets scheduled if any of the special props\n        // changed.\n\n        switch (tag) {\n          case 'input':\n            // Update the wrapper around inputs *after* updating props. This has to\n            // happen after `updateDOMProperties`. Otherwise HTML5 input validations\n            // raise warnings and prevent the new value from being assigned.\n            ReactDOMFiberInput.updateWrapper(domElement, nextRawProps); // We also check that we haven't missed a value update, such as a\n            // Radio group shifting the checked value to another named radio input.\n\n            inputValueTracking_1.updateValueIfChanged(domElement);\n            break;\n\n          case 'textarea':\n            ReactDOMFiberTextarea.updateWrapper(domElement, nextRawProps);\n            break;\n\n          case 'select':\n            // <select> value update needs to occur after <option> children\n            // reconciliation\n            ReactDOMFiberSelect.postUpdateWrapper(domElement, nextRawProps);\n            break;\n        }\n      },\n      diffHydratedProperties: function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {\n        {\n          var isCustomComponentTag = isCustomComponent_1(tag, rawProps);\n          validatePropertiesInDevelopment(tag, rawProps);\n\n          if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n            warning$3(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerName() || 'A component');\n            didWarnShadyDOM = true;\n          }\n        } // TODO: Make sure that we check isMounted before firing any of these events.\n\n        switch (tag) {\n          case 'iframe':\n          case 'object':\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topLoad', 'load', domElement);\n            break;\n\n          case 'video':\n          case 'audio':\n            // Create listener for each media event\n            for (var event in mediaEvents) {\n              if (mediaEvents.hasOwnProperty(event)) {\n                ReactBrowserEventEmitter_1.trapBubbledEvent(event, mediaEvents[event], domElement);\n              }\n            }\n\n            break;\n\n          case 'source':\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topError', 'error', domElement);\n            break;\n\n          case 'img':\n          case 'image':\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topError', 'error', domElement);\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topLoad', 'load', domElement);\n            break;\n\n          case 'form':\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topReset', 'reset', domElement);\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topSubmit', 'submit', domElement);\n            break;\n\n          case 'details':\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topToggle', 'toggle', domElement);\n            break;\n\n          case 'input':\n            ReactDOMFiberInput.initWrapperState(domElement, rawProps);\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening\n            // to onChange. Even if there is no listener.\n\n            ensureListeningTo(rootContainerElement, 'onChange');\n            break;\n\n          case 'option':\n            ReactDOMFiberOption.validateProps(domElement, rawProps);\n            break;\n\n          case 'select':\n            ReactDOMFiberSelect.initWrapperState(domElement, rawProps);\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening\n            // to onChange. Even if there is no listener.\n\n            ensureListeningTo(rootContainerElement, 'onChange');\n            break;\n\n          case 'textarea':\n            ReactDOMFiberTextarea.initWrapperState(domElement, rawProps);\n            ReactBrowserEventEmitter_1.trapBubbledEvent('topInvalid', 'invalid', domElement); // For controlled components we always need to ensure we're listening\n            // to onChange. Even if there is no listener.\n\n            ensureListeningTo(rootContainerElement, 'onChange');\n            break;\n        }\n\n        assertValidProps_1(tag, rawProps, getCurrentFiberOwnerName);\n        {\n          var extraAttributeNames = new Set();\n          var attributes = domElement.attributes;\n\n          for (var i = 0; i < attributes.length; i++) {\n            var name = attributes[i].name.toLowerCase();\n\n            switch (name) {\n              // Built-in SSR attribute is whitelisted\n              case 'data-reactroot':\n                break;\n              // Controlled attributes are not validated\n              // TODO: Only ignore them on controlled tags.\n\n              case 'value':\n                break;\n\n              case 'checked':\n                break;\n\n              case 'selected':\n                break;\n\n              default:\n                // Intentionally use the original name.\n                // See discussion in https://github.com/facebook/react/pull/10676.\n                extraAttributeNames.add(attributes[i].name);\n            }\n          }\n        }\n        var updatePayload = null;\n\n        for (var propKey in rawProps) {\n          if (!rawProps.hasOwnProperty(propKey)) {\n            continue;\n          }\n\n          var nextProp = rawProps[propKey];\n\n          if (propKey === CHILDREN) {\n            // For text content children we compare against textContent. This\n            // might match additional HTML that is hidden when we read it using\n            // textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n            // satisfies our requirement. Our requirement is not to produce perfect\n            // HTML and attributes. Ideally we should preserve structure but it's\n            // ok not to if the visible content is still enough to indicate what\n            // even listeners these nodes might be wired up to.\n            // TODO: Warn if there is more than a single textNode as a child.\n            // TODO: Should we use domElement.firstChild.nodeValue to compare?\n            if (typeof nextProp === 'string') {\n              if (domElement.textContent !== nextProp) {\n                {\n                  warnForTextDifference(domElement.textContent, nextProp);\n                }\n                updatePayload = [CHILDREN, nextProp];\n              }\n            } else if (typeof nextProp === 'number') {\n              if (domElement.textContent !== '' + nextProp) {\n                {\n                  warnForTextDifference(domElement.textContent, nextProp);\n                }\n                updatePayload = [CHILDREN, '' + nextProp];\n              }\n            }\n          } else if (registrationNameModules.hasOwnProperty(propKey)) {\n            if (nextProp != null) {\n              if (true && typeof nextProp !== 'function') {\n                warnForInvalidEventListener(propKey, nextProp);\n              }\n\n              ensureListeningTo(rootContainerElement, propKey);\n            }\n          } else {\n            // Validate that the properties correspond to their expected values.\n            var serverValue;\n            var propertyInfo;\n\n            if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || // Controlled attributes are not validated\n            // TODO: Only ignore them on controlled tags.\n            propKey === 'value' || propKey === 'checked' || propKey === 'selected') {// Noop\n            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n              var rawHtml = nextProp ? nextProp[HTML] || '' : '';\n              var serverHTML = domElement.innerHTML;\n              var expectedHTML = normalizeHTML(domElement, rawHtml);\n\n              if (expectedHTML !== serverHTML) {\n                warnForPropDifference(propKey, serverHTML, expectedHTML);\n              }\n            } else if (propKey === STYLE) {\n              // $FlowFixMe - Should be inferred as not undefined.\n              extraAttributeNames['delete'](propKey);\n              var expectedStyle = CSSPropertyOperations_1.createDangerousStringForStyles(nextProp);\n              serverValue = domElement.getAttribute('style');\n\n              if (expectedStyle !== serverValue) {\n                warnForPropDifference(propKey, serverValue, expectedStyle);\n              }\n            } else if (isCustomComponentTag) {\n              // $FlowFixMe - Should be inferred as not undefined.\n              extraAttributeNames['delete'](propKey.toLowerCase());\n              serverValue = DOMPropertyOperations_1.getValueForAttribute(domElement, propKey, nextProp);\n\n              if (nextProp !== serverValue) {\n                warnForPropDifference(propKey, serverValue, nextProp);\n              }\n            } else if (DOMProperty_1.shouldSetAttribute(propKey, nextProp)) {\n              if (propertyInfo = DOMProperty_1.getPropertyInfo(propKey)) {\n                // $FlowFixMe - Should be inferred as not undefined.\n                extraAttributeNames['delete'](propertyInfo.attributeName);\n                serverValue = DOMPropertyOperations_1.getValueForProperty(domElement, propKey, nextProp);\n              } else {\n                var ownNamespace = parentNamespace;\n\n                if (ownNamespace === HTML_NAMESPACE$1) {\n                  ownNamespace = getIntrinsicNamespace$1(tag);\n                }\n\n                if (ownNamespace === HTML_NAMESPACE$1) {\n                  // $FlowFixMe - Should be inferred as not undefined.\n                  extraAttributeNames['delete'](propKey.toLowerCase());\n                } else {\n                  // $FlowFixMe - Should be inferred as not undefined.\n                  extraAttributeNames['delete'](propKey);\n                }\n\n                serverValue = DOMPropertyOperations_1.getValueForAttribute(domElement, propKey, nextProp);\n              }\n\n              if (nextProp !== serverValue) {\n                warnForPropDifference(propKey, serverValue, nextProp);\n              }\n            }\n          }\n        }\n\n        {\n          // $FlowFixMe - Should be inferred as not undefined.\n          if (extraAttributeNames.size > 0) {\n            // $FlowFixMe - Should be inferred as not undefined.\n            warnForExtraAttributes(extraAttributeNames);\n          }\n        }\n\n        switch (tag) {\n          case 'input':\n            // TODO: Make sure we check if this is still unmounted or do any clean\n            // up necessary since we never stop tracking anymore.\n            inputValueTracking_1.track(domElement);\n            ReactDOMFiberInput.postMountWrapper(domElement, rawProps);\n            break;\n\n          case 'textarea':\n            // TODO: Make sure we check if this is still unmounted or do any clean\n            // up necessary since we never stop tracking anymore.\n            inputValueTracking_1.track(domElement);\n            ReactDOMFiberTextarea.postMountWrapper(domElement, rawProps);\n            break;\n\n          case 'select':\n          case 'option':\n            // For input and textarea we current always set the value property at\n            // post mount to force it to diverge from attributes. However, for\n            // option and select we don't quite do the same thing and select\n            // is not resilient to the DOM state changing so we don't do that here.\n            // TODO: Consider not doing this for input and textarea.\n            break;\n\n          default:\n            if (typeof rawProps.onClick === 'function') {\n              // TODO: This cast may not be sound for SVG, MathML or custom elements.\n              trapClickOnNonInteractiveElement(domElement);\n            }\n\n            break;\n        }\n\n        return updatePayload;\n      },\n      diffHydratedText: function diffHydratedText(textNode, text) {\n        var isDifferent = textNode.nodeValue !== text;\n        {\n          if (isDifferent) {\n            warnForTextDifference(textNode.nodeValue, text);\n          }\n        }\n        return isDifferent;\n      },\n      warnForDeletedHydratableElement: function warnForDeletedHydratableElement(parentNode, child) {\n        {\n          if (didWarnInvalidHydration) {\n            return;\n          }\n\n          didWarnInvalidHydration = true;\n          warning$3(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\n        }\n      },\n      warnForDeletedHydratableText: function warnForDeletedHydratableText(parentNode, child) {\n        {\n          if (didWarnInvalidHydration) {\n            return;\n          }\n\n          didWarnInvalidHydration = true;\n          warning$3(false, 'Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\n        }\n      },\n      warnForInsertedHydratedElement: function warnForInsertedHydratedElement(parentNode, tag, props) {\n        {\n          if (didWarnInvalidHydration) {\n            return;\n          }\n\n          didWarnInvalidHydration = true;\n          warning$3(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());\n        }\n      },\n      warnForInsertedHydratedText: function warnForInsertedHydratedText(parentNode, text) {\n        {\n          if (text === '') {\n            // We expect to insert empty text nodes since they're not represented in\n            // the HTML.\n            // TODO: Remove this special case if we can just avoid inserting empty\n            // text nodes.\n            return;\n          }\n\n          if (didWarnInvalidHydration) {\n            return;\n          }\n\n          didWarnInvalidHydration = true;\n          warning$3(false, 'Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\n        }\n      },\n      restoreControlledState: function restoreControlledState(domElement, tag, props) {\n        switch (tag) {\n          case 'input':\n            ReactDOMFiberInput.restoreControlledState(domElement, props);\n            return;\n\n          case 'textarea':\n            ReactDOMFiberTextarea.restoreControlledState(domElement, props);\n            return;\n\n          case 'select':\n            ReactDOMFiberSelect.restoreControlledState(domElement, props);\n            return;\n        }\n      }\n    };\n    var ReactDOMFiberComponent_1 = ReactDOMFiberComponent; // This is a built-in polyfill for requestIdleCallback. It works by scheduling\n    // a requestAnimationFrame, storing the time for the start of the frame, then\n    // scheduling a postMessage which gets scheduled after paint. Within the\n    // postMessage handler do as much work as possible until time + frame rate.\n    // By separating the idle call into a separate event tick we ensure that\n    // layout, paint and other browser work is counted against the available time.\n    // The frame rate is dynamically adjusted.\n\n    {\n      var warning$17 = require$$0;\n\n      if (ExecutionEnvironment.canUseDOM && typeof requestAnimationFrame !== 'function') {\n        warning$17(false, 'React depends on requestAnimationFrame. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');\n      }\n    } // TODO: There's no way to cancel, because Fiber doesn't atm.\n\n    var rIC = void 0;\n\n    if (!ExecutionEnvironment.canUseDOM) {\n      rIC = function rIC(frameCallback) {\n        setTimeout(function () {\n          frameCallback({\n            timeRemaining: function timeRemaining() {\n              return Infinity;\n            }\n          });\n        });\n        return 0;\n      };\n    } else if (typeof requestIdleCallback !== 'function') {\n      // Polyfill requestIdleCallback.\n      var scheduledRAFCallback = null;\n      var scheduledRICCallback = null;\n      var isIdleScheduled = false;\n      var isAnimationFrameScheduled = false;\n      var frameDeadline = 0; // We start out assuming that we run at 30fps but then the heuristic tracking\n      // will adjust this value to a faster fps if we get more frequent animation\n      // frames.\n\n      var previousFrameTime = 33;\n      var activeFrameTime = 33;\n      var frameDeadlineObject = {\n        timeRemaining: typeof performance === 'object' && typeof performance.now === 'function' ? function () {\n          // We assume that if we have a performance timer that the rAF callback\n          // gets a performance timer value. Not sure if this is always true.\n          return frameDeadline - performance.now();\n        } : function () {\n          // As a fallback we use Date.now.\n          return frameDeadline - Date.now();\n        }\n      }; // We use the postMessage trick to defer idle work until after the repaint.\n\n      var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n\n      var idleTick = function idleTick(event) {\n        if (event.source !== window || event.data !== messageKey) {\n          return;\n        }\n\n        isIdleScheduled = false;\n        var callback = scheduledRICCallback;\n        scheduledRICCallback = null;\n\n        if (callback !== null) {\n          callback(frameDeadlineObject);\n        }\n      }; // Assumes that we have addEventListener in this environment. Might need\n      // something better for old IE.\n\n\n      window.addEventListener('message', idleTick, false);\n\n      var animationTick = function animationTick(rafTime) {\n        isAnimationFrameScheduled = false;\n        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n\n        if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n          if (nextFrameTime < 8) {\n            // Defensive coding. We don't support higher frame rates than 120hz.\n            // If we get lower than that, it is probably a bug.\n            nextFrameTime = 8;\n          } // If one frame goes long, then the next one can be short to catch up.\n          // If two frames are short in a row, then that's an indication that we\n          // actually have a higher frame rate than what we're currently optimizing.\n          // We adjust our heuristic dynamically accordingly. For example, if we're\n          // running on 120hz display or 90hz VR display.\n          // Take the max of the two in case one of them was an anomaly due to\n          // missed frame deadlines.\n\n\n          activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n        } else {\n          previousFrameTime = nextFrameTime;\n        }\n\n        frameDeadline = rafTime + activeFrameTime;\n\n        if (!isIdleScheduled) {\n          isIdleScheduled = true;\n          window.postMessage(messageKey, '*');\n        }\n\n        var callback = scheduledRAFCallback;\n        scheduledRAFCallback = null;\n\n        if (callback !== null) {\n          callback(rafTime);\n        }\n      };\n\n      rIC = function rIC(callback) {\n        // This assumes that we only schedule one callback at a time because that's\n        // how Fiber uses it.\n        scheduledRICCallback = callback;\n\n        if (!isAnimationFrameScheduled) {\n          // If rAF didn't already schedule one, we need to schedule a frame.\n          // TODO: If this rAF doesn't materialize because the browser throttles, we\n          // might want to still have setTimeout trigger rIC as a backup to ensure\n          // that we keep performing work.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrame(animationTick);\n        }\n\n        return 0;\n      };\n    } else {\n      rIC = requestIdleCallback;\n    }\n\n    var rIC_1 = rIC;\n    var ReactDOMFrameScheduling = {\n      rIC: rIC_1\n    };\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule ReactFeatureFlags\n     * \n     */\n\n    var ReactFeatureFlags = {\n      enableAsyncSubtreeAPI: true\n    };\n    var ReactFeatureFlags_1 = ReactFeatureFlags;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule ReactPriorityLevel\n     * \n     */\n\n    var ReactPriorityLevel = {\n      NoWork: 0,\n      // No work is pending.\n      SynchronousPriority: 1,\n      // For controlled text inputs. Synchronous side-effects.\n      TaskPriority: 2,\n      // Completes at the end of the current tick.\n      HighPriority: 3,\n      // Interaction that needs to complete pretty soon to feel responsive.\n      LowPriority: 4,\n      // Data fetching, or result from updating stores.\n      OffscreenPriority: 5\n    };\n    var CallbackEffect = ReactTypeOfSideEffect.Callback;\n    var NoWork = ReactPriorityLevel.NoWork;\n    var SynchronousPriority = ReactPriorityLevel.SynchronousPriority;\n    var TaskPriority = ReactPriorityLevel.TaskPriority;\n    var ClassComponent$2 = ReactTypeOfWork.ClassComponent;\n    var HostRoot$2 = ReactTypeOfWork.HostRoot;\n    {\n      var warning$19 = require$$0;\n    } // Callbacks are not validated until invocation\n    // Singly linked-list of updates. When an update is scheduled, it is added to\n    // the queue of the current fiber and the work-in-progress fiber. The two queues\n    // are separate but they share a persistent structure.\n    //\n    // During reconciliation, updates are removed from the work-in-progress fiber,\n    // but they remain on the current fiber. That ensures that if a work-in-progress\n    // is aborted, the aborted updates are recovered by cloning from current.\n    //\n    // The work-in-progress queue is always a subset of the current queue.\n    //\n    // When the tree is committed, the work-in-progress becomes the current.\n\n    var _queue1 = void 0;\n\n    var _queue2 = void 0;\n\n    function comparePriority(a, b) {\n      // When comparing update priorities, treat sync and Task work as equal.\n      // TODO: Could we avoid the need for this by always coercing sync priority\n      // to Task when scheduling an update?\n      if ((a === TaskPriority || a === SynchronousPriority) && (b === TaskPriority || b === SynchronousPriority)) {\n        return 0;\n      }\n\n      if (a === NoWork && b !== NoWork) {\n        return -255;\n      }\n\n      if (a !== NoWork && b === NoWork) {\n        return 255;\n      }\n\n      return a - b;\n    }\n\n    function createUpdateQueue() {\n      var queue = {\n        first: null,\n        last: null,\n        hasForceUpdate: false,\n        callbackList: null\n      };\n      {\n        queue.isProcessing = false;\n      }\n      return queue;\n    }\n\n    function cloneUpdate(update) {\n      return {\n        priorityLevel: update.priorityLevel,\n        partialState: update.partialState,\n        callback: update.callback,\n        isReplace: update.isReplace,\n        isForced: update.isForced,\n        isTopLevelUnmount: update.isTopLevelUnmount,\n        next: null\n      };\n    }\n\n    function insertUpdateIntoQueue(queue, update, insertAfter, insertBefore) {\n      if (insertAfter !== null) {\n        insertAfter.next = update;\n      } else {\n        // This is the first item in the queue.\n        update.next = queue.first;\n        queue.first = update;\n      }\n\n      if (insertBefore !== null) {\n        update.next = insertBefore;\n      } else {\n        // This is the last item in the queue.\n        queue.last = update;\n      }\n    } // Returns the update after which the incoming update should be inserted into\n    // the queue, or null if it should be inserted at beginning.\n\n\n    function findInsertionPosition(queue, update) {\n      var priorityLevel = update.priorityLevel;\n      var insertAfter = null;\n      var insertBefore = null;\n\n      if (queue.last !== null && comparePriority(queue.last.priorityLevel, priorityLevel) <= 0) {\n        // Fast path for the common case where the update should be inserted at\n        // the end of the queue.\n        insertAfter = queue.last;\n      } else {\n        insertBefore = queue.first;\n\n        while (insertBefore !== null && comparePriority(insertBefore.priorityLevel, priorityLevel) <= 0) {\n          insertAfter = insertBefore;\n          insertBefore = insertBefore.next;\n        }\n      }\n\n      return insertAfter;\n    }\n\n    function ensureUpdateQueues(fiber) {\n      var alternateFiber = fiber.alternate;\n      var queue1 = fiber.updateQueue;\n\n      if (queue1 === null) {\n        queue1 = fiber.updateQueue = createUpdateQueue();\n      }\n\n      var queue2 = void 0;\n\n      if (alternateFiber !== null) {\n        queue2 = alternateFiber.updateQueue;\n\n        if (queue2 === null) {\n          queue2 = alternateFiber.updateQueue = createUpdateQueue();\n        }\n      } else {\n        queue2 = null;\n      }\n\n      _queue1 = queue1; // Return null if there is no alternate queue, or if its queue is the same.\n\n      _queue2 = queue2 !== queue1 ? queue2 : null;\n    } // The work-in-progress queue is a subset of the current queue (if it exists).\n    // We need to insert the incoming update into both lists. However, it's possible\n    // that the correct position in one list will be different from the position in\n    // the other. Consider the following case:\n    //\n    //     Current:             3-5-6\n    //     Work-in-progress:        6\n    //\n    // Then we receive an update with priority 4 and insert it into each list:\n    //\n    //     Current:             3-4-5-6\n    //     Work-in-progress:        4-6\n    //\n    // In the current queue, the new update's `next` pointer points to the update\n    // with priority 5. But in the work-in-progress queue, the pointer points to the\n    // update with priority 6. Because these two queues share the same persistent\n    // data structure, this won't do. (This can only happen when the incoming update\n    // has higher priority than all the updates in the work-in-progress queue.)\n    //\n    // To solve this, in the case where the incoming update needs to be inserted\n    // into two different positions, we'll make a clone of the update and insert\n    // each copy into a separate queue. This forks the list while maintaining a\n    // persistent structure, because the update that is added to the work-in-progress\n    // is always added to the front of the list.\n    //\n    // However, if incoming update is inserted into the same position of both lists,\n    // we shouldn't make a copy.\n    //\n    // If the update is cloned, it returns the cloned update.\n\n\n    function insertUpdate(fiber, update) {\n      // We'll have at least one and at most two distinct update queues.\n      ensureUpdateQueues(fiber);\n      var queue1 = _queue1;\n      var queue2 = _queue2; // Warn if an update is scheduled from inside an updater function.\n\n      {\n        if (queue1.isProcessing || queue2 !== null && queue2.isProcessing) {\n          warning$19(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n        }\n      } // Find the insertion position in the first queue.\n\n      var insertAfter1 = findInsertionPosition(queue1, update);\n      var insertBefore1 = insertAfter1 !== null ? insertAfter1.next : queue1.first;\n\n      if (queue2 === null) {\n        // If there's no alternate queue, there's nothing else to do but insert.\n        insertUpdateIntoQueue(queue1, update, insertAfter1, insertBefore1);\n        return null;\n      } // If there is an alternate queue, find the insertion position.\n\n\n      var insertAfter2 = findInsertionPosition(queue2, update);\n      var insertBefore2 = insertAfter2 !== null ? insertAfter2.next : queue2.first; // Now we can insert into the first queue. This must come after finding both\n      // insertion positions because it mutates the list.\n\n      insertUpdateIntoQueue(queue1, update, insertAfter1, insertBefore1); // See if the insertion positions are equal. Be careful to only compare\n      // non-null values.\n\n      if (insertBefore1 === insertBefore2 && insertBefore1 !== null || insertAfter1 === insertAfter2 && insertAfter1 !== null) {\n        // The insertion positions are the same, so when we inserted into the first\n        // queue, it also inserted into the alternate. All we need to do is update\n        // the alternate queue's `first` and `last` pointers, in case they\n        // have changed.\n        if (insertAfter2 === null) {\n          queue2.first = update;\n        }\n\n        if (insertBefore2 === null) {\n          queue2.last = null;\n        }\n\n        return null;\n      } else {\n        // The insertion positions are different, so we need to clone the update and\n        // insert the clone into the alternate queue.\n        var update2 = cloneUpdate(update);\n        insertUpdateIntoQueue(queue2, update2, insertAfter2, insertBefore2);\n        return update2;\n      }\n    }\n\n    function addUpdate(fiber, partialState, callback, priorityLevel) {\n      var update = {\n        priorityLevel: priorityLevel,\n        partialState: partialState,\n        callback: callback,\n        isReplace: false,\n        isForced: false,\n        isTopLevelUnmount: false,\n        next: null\n      };\n      insertUpdate(fiber, update);\n    }\n\n    var addUpdate_1 = addUpdate;\n\n    function addReplaceUpdate(fiber, state, callback, priorityLevel) {\n      var update = {\n        priorityLevel: priorityLevel,\n        partialState: state,\n        callback: callback,\n        isReplace: true,\n        isForced: false,\n        isTopLevelUnmount: false,\n        next: null\n      };\n      insertUpdate(fiber, update);\n    }\n\n    var addReplaceUpdate_1 = addReplaceUpdate;\n\n    function addForceUpdate(fiber, callback, priorityLevel) {\n      var update = {\n        priorityLevel: priorityLevel,\n        partialState: null,\n        callback: callback,\n        isReplace: false,\n        isForced: true,\n        isTopLevelUnmount: false,\n        next: null\n      };\n      insertUpdate(fiber, update);\n    }\n\n    var addForceUpdate_1 = addForceUpdate;\n\n    function getUpdatePriority(fiber) {\n      var updateQueue = fiber.updateQueue;\n\n      if (updateQueue === null) {\n        return NoWork;\n      }\n\n      if (fiber.tag !== ClassComponent$2 && fiber.tag !== HostRoot$2) {\n        return NoWork;\n      }\n\n      return updateQueue.first !== null ? updateQueue.first.priorityLevel : NoWork;\n    }\n\n    var getUpdatePriority_1 = getUpdatePriority;\n\n    function addTopLevelUpdate$1(fiber, partialState, callback, priorityLevel) {\n      var isTopLevelUnmount = partialState.element === null;\n      var update = {\n        priorityLevel: priorityLevel,\n        partialState: partialState,\n        callback: callback,\n        isReplace: false,\n        isForced: false,\n        isTopLevelUnmount: isTopLevelUnmount,\n        next: null\n      };\n      var update2 = insertUpdate(fiber, update);\n\n      if (isTopLevelUnmount) {\n        // TODO: Redesign the top-level mount/update/unmount API to avoid this\n        // special case.\n        var queue1 = _queue1;\n        var queue2 = _queue2; // Drop all updates that are lower-priority, so that the tree is not\n        // remounted. We need to do this for both queues.\n\n        if (queue1 !== null && update.next !== null) {\n          update.next = null;\n          queue1.last = update;\n        }\n\n        if (queue2 !== null && update2 !== null && update2.next !== null) {\n          update2.next = null;\n          queue2.last = update;\n        }\n      }\n    }\n\n    var addTopLevelUpdate_1 = addTopLevelUpdate$1;\n\n    function getStateFromUpdate(update, instance, prevState, props) {\n      var partialState = update.partialState;\n\n      if (typeof partialState === 'function') {\n        var updateFn = partialState;\n        return updateFn.call(instance, prevState, props);\n      } else {\n        return partialState;\n      }\n    }\n\n    function beginUpdateQueue(current, workInProgress, queue, instance, prevState, props, priorityLevel) {\n      if (current !== null && current.updateQueue === queue) {\n        // We need to create a work-in-progress queue, by cloning the current queue.\n        var currentQueue = queue;\n        queue = workInProgress.updateQueue = {\n          first: currentQueue.first,\n          last: currentQueue.last,\n          // These fields are no longer valid because they were already committed.\n          // Reset them.\n          callbackList: null,\n          hasForceUpdate: false\n        };\n      }\n\n      {\n        // Set this flag so we can warn if setState is called inside the update\n        // function of another setState.\n        queue.isProcessing = true;\n      } // Calculate these using the the existing values as a base.\n\n      var callbackList = queue.callbackList;\n      var hasForceUpdate = queue.hasForceUpdate; // Applies updates with matching priority to the previous state to create\n      // a new state object.\n\n      var state = prevState;\n      var dontMutatePrevState = true;\n      var update = queue.first;\n\n      while (update !== null && comparePriority(update.priorityLevel, priorityLevel) <= 0) {\n        // Remove each update from the queue right before it is processed. That way\n        // if setState is called from inside an updater function, the new update\n        // will be inserted in the correct position.\n        queue.first = update.next;\n\n        if (queue.first === null) {\n          queue.last = null;\n        }\n\n        var _partialState = void 0;\n\n        if (update.isReplace) {\n          state = getStateFromUpdate(update, instance, state, props);\n          dontMutatePrevState = true;\n        } else {\n          _partialState = getStateFromUpdate(update, instance, state, props);\n\n          if (_partialState) {\n            if (dontMutatePrevState) {\n              state = _assign({}, state, _partialState);\n            } else {\n              state = _assign(state, _partialState);\n            }\n\n            dontMutatePrevState = false;\n          }\n        }\n\n        if (update.isForced) {\n          hasForceUpdate = true;\n        } // Second condition ignores top-level unmount callbacks if they are not the\n        // last update in the queue, since a subsequent update will cause a remount.\n\n\n        if (update.callback !== null && !(update.isTopLevelUnmount && update.next !== null)) {\n          callbackList = callbackList !== null ? callbackList : [];\n          callbackList.push(update.callback);\n          workInProgress.effectTag |= CallbackEffect;\n        }\n\n        update = update.next;\n      }\n\n      queue.callbackList = callbackList;\n      queue.hasForceUpdate = hasForceUpdate;\n\n      if (queue.first === null && callbackList === null && !hasForceUpdate) {\n        // The queue is empty and there are no callbacks. We can reset it.\n        workInProgress.updateQueue = null;\n      }\n\n      {\n        // No longer processing.\n        queue.isProcessing = false;\n      }\n      return state;\n    }\n\n    var beginUpdateQueue_1 = beginUpdateQueue;\n\n    function commitCallbacks(finishedWork, queue, context) {\n      var callbackList = queue.callbackList;\n\n      if (callbackList === null) {\n        return;\n      } // Set the list to null to make sure they don't get called more than once.\n\n\n      queue.callbackList = null;\n\n      for (var i = 0; i < callbackList.length; i++) {\n        var _callback = callbackList[i];\n        !(typeof _callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback) : void 0;\n\n        _callback.call(context);\n      }\n    }\n\n    var commitCallbacks_1 = commitCallbacks;\n    var ReactFiberUpdateQueue = {\n      addUpdate: addUpdate_1,\n      addReplaceUpdate: addReplaceUpdate_1,\n      addForceUpdate: addForceUpdate_1,\n      getUpdatePriority: getUpdatePriority_1,\n      addTopLevelUpdate: addTopLevelUpdate_1,\n      beginUpdateQueue: beginUpdateQueue_1,\n      commitCallbacks: commitCallbacks_1\n    };\n    {\n      var warning$21 = require$$0;\n    }\n    var valueStack = [];\n    {\n      var fiberStack = [];\n    }\n    var index = -1;\n\n    var createCursor$1 = function createCursor$1(defaultValue) {\n      return {\n        current: defaultValue\n      };\n    };\n\n    var isEmpty = function isEmpty() {\n      return index === -1;\n    };\n\n    var pop$1 = function pop$1(cursor, fiber) {\n      if (index < 0) {\n        {\n          warning$21(false, 'Unexpected pop.');\n        }\n        return;\n      }\n\n      {\n        if (fiber !== fiberStack[index]) {\n          warning$21(false, 'Unexpected Fiber popped.');\n        }\n      }\n      cursor.current = valueStack[index];\n      valueStack[index] = null;\n      {\n        fiberStack[index] = null;\n      }\n      index--;\n    };\n\n    var push$1 = function push$1(cursor, value, fiber) {\n      index++;\n      valueStack[index] = cursor.current;\n      {\n        fiberStack[index] = fiber;\n      }\n      cursor.current = value;\n    };\n\n    var reset = function reset() {\n      while (index > -1) {\n        valueStack[index] = null;\n        {\n          fiberStack[index] = null;\n        }\n        index--;\n      }\n    };\n\n    var ReactFiberStack = {\n      createCursor: createCursor$1,\n      isEmpty: isEmpty,\n      pop: pop$1,\n      push: push$1,\n      reset: reset\n    }; // Trust the developer to only use this with a true check\n\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule ReactDebugFiberPerf\n     * \n     */\n\n    var ReactDebugFiberPerf = null;\n    {\n      var _require$8 = ReactTypeOfWork,\n          HostRoot$4 = _require$8.HostRoot,\n          HostComponent$4 = _require$8.HostComponent,\n          HostText$2 = _require$8.HostText,\n          HostPortal$1 = _require$8.HostPortal,\n          YieldComponent = _require$8.YieldComponent,\n          Fragment = _require$8.Fragment;\n      var getComponentName$5 = getComponentName_1; // Prefix measurements so that it's possible to filter them.\n      // Longer prefixes are hard to read in DevTools.\n\n      var reactEmoji = \"\\u269B\";\n      var warningEmoji = \"\\u26D4\";\n      var supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function'; // Keep track of current fiber so that we know the path to unwind on pause.\n      // TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\n\n      var currentFiber = null; // If we're in the middle of user code, which fiber and method is it?\n      // Reusing `currentFiber` would be confusing for this because user code fiber\n      // can change during commit phase too, but we don't need to unwind it (since\n      // lifecycles in the commit phase don't resemble a tree).\n\n      var currentPhase = null;\n      var currentPhaseFiber = null; // Did lifecycle hook schedule an update? This is often a performance problem,\n      // so we will keep track of it, and include it in the report.\n      // Track commits caused by cascading updates.\n\n      var isCommitting = false;\n      var hasScheduledUpdateInCurrentCommit = false;\n      var hasScheduledUpdateInCurrentPhase = false;\n      var commitCountInCurrentWorkLoop = 0;\n      var effectCountInCurrentCommit = 0; // During commits, we only show a measurement once per method name\n      // to avoid stretch the commit phase with measurement overhead.\n\n      var labelsInCurrentCommit = new Set();\n\n      var formatMarkName = function formatMarkName(markName) {\n        return reactEmoji + ' ' + markName;\n      };\n\n      var formatLabel = function formatLabel(label, warning) {\n        var prefix = warning ? warningEmoji + ' ' : reactEmoji + ' ';\n        var suffix = warning ? ' Warning: ' + warning : '';\n        return '' + prefix + label + suffix;\n      };\n\n      var beginMark = function beginMark(markName) {\n        performance.mark(formatMarkName(markName));\n      };\n\n      var clearMark = function clearMark(markName) {\n        performance.clearMarks(formatMarkName(markName));\n      };\n\n      var endMark = function endMark(label, markName, warning) {\n        var formattedMarkName = formatMarkName(markName);\n        var formattedLabel = formatLabel(label, warning);\n\n        try {\n          performance.measure(formattedLabel, formattedMarkName);\n        } catch (err) {} // If previous mark was missing for some reason, this will throw.\n        // This could only happen if React crashed in an unexpected place earlier.\n        // Don't pile on with more errors.\n        // Clear marks immediately to avoid growing buffer.\n\n\n        performance.clearMarks(formattedMarkName);\n        performance.clearMeasures(formattedLabel);\n      };\n\n      var getFiberMarkName = function getFiberMarkName(label, debugID) {\n        return label + ' (#' + debugID + ')';\n      };\n\n      var getFiberLabel = function getFiberLabel(componentName, isMounted, phase) {\n        if (phase === null) {\n          // These are composite component total time measurements.\n          return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n        } else {\n          // Composite component methods.\n          return componentName + '.' + phase;\n        }\n      };\n\n      var beginFiberMark = function beginFiberMark(fiber, phase) {\n        var componentName = getComponentName$5(fiber) || 'Unknown';\n        var debugID = fiber._debugID;\n        var isMounted = fiber.alternate !== null;\n        var label = getFiberLabel(componentName, isMounted, phase);\n\n        if (isCommitting && labelsInCurrentCommit.has(label)) {\n          // During the commit phase, we don't show duplicate labels because\n          // there is a fixed overhead for every measurement, and we don't\n          // want to stretch the commit phase beyond necessary.\n          return false;\n        }\n\n        labelsInCurrentCommit.add(label);\n        var markName = getFiberMarkName(label, debugID);\n        beginMark(markName);\n        return true;\n      };\n\n      var clearFiberMark = function clearFiberMark(fiber, phase) {\n        var componentName = getComponentName$5(fiber) || 'Unknown';\n        var debugID = fiber._debugID;\n        var isMounted = fiber.alternate !== null;\n        var label = getFiberLabel(componentName, isMounted, phase);\n        var markName = getFiberMarkName(label, debugID);\n        clearMark(markName);\n      };\n\n      var endFiberMark = function endFiberMark(fiber, phase, warning) {\n        var componentName = getComponentName$5(fiber) || 'Unknown';\n        var debugID = fiber._debugID;\n        var isMounted = fiber.alternate !== null;\n        var label = getFiberLabel(componentName, isMounted, phase);\n        var markName = getFiberMarkName(label, debugID);\n        endMark(label, markName, warning);\n      };\n\n      var shouldIgnoreFiber = function shouldIgnoreFiber(fiber) {\n        // Host components should be skipped in the timeline.\n        // We could check typeof fiber.type, but does this work with RN?\n        switch (fiber.tag) {\n          case HostRoot$4:\n          case HostComponent$4:\n          case HostText$2:\n          case HostPortal$1:\n          case YieldComponent:\n          case Fragment:\n            return true;\n\n          default:\n            return false;\n        }\n      };\n\n      var clearPendingPhaseMeasurement = function clearPendingPhaseMeasurement() {\n        if (currentPhase !== null && currentPhaseFiber !== null) {\n          clearFiberMark(currentPhaseFiber, currentPhase);\n        }\n\n        currentPhaseFiber = null;\n        currentPhase = null;\n        hasScheduledUpdateInCurrentPhase = false;\n      };\n\n      var pauseTimers = function pauseTimers() {\n        // Stops all currently active measurements so that they can be resumed\n        // if we continue in a later deferred loop from the same unit of work.\n        var fiber = currentFiber;\n\n        while (fiber) {\n          if (fiber._debugIsCurrentlyTiming) {\n            endFiberMark(fiber, null, null);\n          }\n\n          fiber = fiber['return'];\n        }\n      };\n\n      var resumeTimersRecursively = function resumeTimersRecursively(fiber) {\n        if (fiber['return'] !== null) {\n          resumeTimersRecursively(fiber['return']);\n        }\n\n        if (fiber._debugIsCurrentlyTiming) {\n          beginFiberMark(fiber, null);\n        }\n      };\n\n      var resumeTimers = function resumeTimers() {\n        // Resumes all measurements that were active during the last deferred loop.\n        if (currentFiber !== null) {\n          resumeTimersRecursively(currentFiber);\n        }\n      };\n\n      ReactDebugFiberPerf = {\n        recordEffect: function recordEffect() {\n          effectCountInCurrentCommit++;\n        },\n        recordScheduleUpdate: function recordScheduleUpdate() {\n          if (isCommitting) {\n            hasScheduledUpdateInCurrentCommit = true;\n          }\n\n          if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n            hasScheduledUpdateInCurrentPhase = true;\n          }\n        },\n        startWorkTimer: function startWorkTimer(fiber) {\n          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n            return;\n          } // If we pause, this is the fiber to unwind from.\n\n\n          currentFiber = fiber;\n\n          if (!beginFiberMark(fiber, null)) {\n            return;\n          }\n\n          fiber._debugIsCurrentlyTiming = true;\n        },\n        cancelWorkTimer: function cancelWorkTimer(fiber) {\n          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n            return;\n          } // Remember we shouldn't complete measurement for this fiber.\n          // Otherwise flamechart will be deep even for small updates.\n\n\n          fiber._debugIsCurrentlyTiming = false;\n          clearFiberMark(fiber, null);\n        },\n        stopWorkTimer: function stopWorkTimer(fiber) {\n          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n            return;\n          } // If we pause, its parent is the fiber to unwind from.\n\n\n          currentFiber = fiber['return'];\n\n          if (!fiber._debugIsCurrentlyTiming) {\n            return;\n          }\n\n          fiber._debugIsCurrentlyTiming = false;\n          endFiberMark(fiber, null, null);\n        },\n        stopFailedWorkTimer: function stopFailedWorkTimer(fiber) {\n          if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n            return;\n          } // If we pause, its parent is the fiber to unwind from.\n\n\n          currentFiber = fiber['return'];\n\n          if (!fiber._debugIsCurrentlyTiming) {\n            return;\n          }\n\n          fiber._debugIsCurrentlyTiming = false;\n          var warning = 'An error was thrown inside this error boundary';\n          endFiberMark(fiber, null, warning);\n        },\n        startPhaseTimer: function startPhaseTimer(fiber, phase) {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          clearPendingPhaseMeasurement();\n\n          if (!beginFiberMark(fiber, phase)) {\n            return;\n          }\n\n          currentPhaseFiber = fiber;\n          currentPhase = phase;\n        },\n        stopPhaseTimer: function stopPhaseTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          if (currentPhase !== null && currentPhaseFiber !== null) {\n            var warning = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n            endFiberMark(currentPhaseFiber, currentPhase, warning);\n          }\n\n          currentPhase = null;\n          currentPhaseFiber = null;\n        },\n        startWorkLoopTimer: function startWorkLoopTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          commitCountInCurrentWorkLoop = 0; // This is top level call.\n          // Any other measurements are performed within.\n\n          beginMark('(React Tree Reconciliation)'); // Resume any measurements that were in progress during the last loop.\n\n          resumeTimers();\n        },\n        stopWorkLoopTimer: function stopWorkLoopTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          var warning = commitCountInCurrentWorkLoop > 1 ? 'There were cascading updates' : null;\n          commitCountInCurrentWorkLoop = 0; // Pause any measurements until the next loop.\n\n          pauseTimers();\n          endMark('(React Tree Reconciliation)', '(React Tree Reconciliation)', warning);\n        },\n        startCommitTimer: function startCommitTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          isCommitting = true;\n          hasScheduledUpdateInCurrentCommit = false;\n          labelsInCurrentCommit.clear();\n          beginMark('(Committing Changes)');\n        },\n        stopCommitTimer: function stopCommitTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          var warning = null;\n\n          if (hasScheduledUpdateInCurrentCommit) {\n            warning = 'Lifecycle hook scheduled a cascading update';\n          } else if (commitCountInCurrentWorkLoop > 0) {\n            warning = 'Caused by a cascading update in earlier commit';\n          }\n\n          hasScheduledUpdateInCurrentCommit = false;\n          commitCountInCurrentWorkLoop++;\n          isCommitting = false;\n          labelsInCurrentCommit.clear();\n          endMark('(Committing Changes)', '(Committing Changes)', warning);\n        },\n        startCommitHostEffectsTimer: function startCommitHostEffectsTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          effectCountInCurrentCommit = 0;\n          beginMark('(Committing Host Effects)');\n        },\n        stopCommitHostEffectsTimer: function stopCommitHostEffectsTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          var count = effectCountInCurrentCommit;\n          effectCountInCurrentCommit = 0;\n          endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n        },\n        startCommitLifeCyclesTimer: function startCommitLifeCyclesTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          effectCountInCurrentCommit = 0;\n          beginMark('(Calling Lifecycle Methods)');\n        },\n        stopCommitLifeCyclesTimer: function stopCommitLifeCyclesTimer() {\n          if (!supportsUserTiming) {\n            return;\n          }\n\n          var count = effectCountInCurrentCommit;\n          effectCountInCurrentCommit = 0;\n          endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n        }\n      };\n    }\n    var ReactDebugFiberPerf_1 = ReactDebugFiberPerf;\n    var isFiberMounted$1 = ReactFiberTreeReflection.isFiberMounted;\n    var ClassComponent$3 = ReactTypeOfWork.ClassComponent;\n    var HostRoot$3 = ReactTypeOfWork.HostRoot;\n    var createCursor = ReactFiberStack.createCursor;\n    var pop = ReactFiberStack.pop;\n    var push = ReactFiberStack.push;\n    {\n      var warning$20 = require$$0;\n      var checkPropTypes$1 = checkPropTypes;\n      var ReactDebugCurrentFiber$2 = ReactDebugCurrentFiber_1;\n      var _require4 = ReactDebugFiberPerf_1,\n          startPhaseTimer = _require4.startPhaseTimer,\n          stopPhaseTimer = _require4.stopPhaseTimer;\n      var warnedAboutMissingGetChildContext = {};\n    } // A cursor to the current merged context object on the stack.\n\n    var contextStackCursor = createCursor(emptyObject); // A cursor to a boolean indicating whether the context has changed.\n\n    var didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\n    // We use this to get access to the parent context after we have already\n    // pushed the next context provider, and now need to merge their contexts.\n\n    var previousContext = emptyObject;\n\n    function getUnmaskedContext(workInProgress) {\n      var hasOwnContext = isContextProvider$1(workInProgress);\n\n      if (hasOwnContext) {\n        // If the fiber is a context provider itself, when we read its context\n        // we have already pushed its own child context on the stack. A context\n        // provider should not \"see\" its own child context. Therefore we read the\n        // previous (parent) context instead for a context provider.\n        return previousContext;\n      }\n\n      return contextStackCursor.current;\n    }\n\n    var getUnmaskedContext_1 = getUnmaskedContext;\n\n    function cacheContext(workInProgress, unmaskedContext, maskedContext) {\n      var instance = workInProgress.stateNode;\n      instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n      instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n    }\n\n    var cacheContext_1 = cacheContext;\n\n    var getMaskedContext = function getMaskedContext(workInProgress, unmaskedContext) {\n      var type = workInProgress.type;\n      var contextTypes = type.contextTypes;\n\n      if (!contextTypes) {\n        return emptyObject;\n      } // Avoid recreating masked context unless unmasked context has changed.\n      // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n      // This may trigger infinite loops if componentWillReceiveProps calls setState.\n\n\n      var instance = workInProgress.stateNode;\n\n      if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n        return instance.__reactInternalMemoizedMaskedChildContext;\n      }\n\n      var context = {};\n\n      for (var key in contextTypes) {\n        context[key] = unmaskedContext[key];\n      }\n\n      {\n        var name = getComponentName_1(workInProgress) || 'Unknown';\n        ReactDebugCurrentFiber$2.setCurrentFiber(workInProgress, null);\n        checkPropTypes$1(contextTypes, context, 'context', name, ReactDebugCurrentFiber$2.getCurrentFiberStackAddendum);\n        ReactDebugCurrentFiber$2.resetCurrentFiber();\n      } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n      // Context is created before the class component is instantiated so check for instance.\n\n      if (instance) {\n        cacheContext(workInProgress, unmaskedContext, context);\n      }\n\n      return context;\n    };\n\n    var hasContextChanged = function hasContextChanged() {\n      return didPerformWorkStackCursor.current;\n    };\n\n    function isContextConsumer(fiber) {\n      return fiber.tag === ClassComponent$3 && fiber.type.contextTypes != null;\n    }\n\n    var isContextConsumer_1 = isContextConsumer;\n\n    function isContextProvider$1(fiber) {\n      return fiber.tag === ClassComponent$3 && fiber.type.childContextTypes != null;\n    }\n\n    var isContextProvider_1 = isContextProvider$1;\n\n    function popContextProvider(fiber) {\n      if (!isContextProvider$1(fiber)) {\n        return;\n      }\n\n      pop(didPerformWorkStackCursor, fiber);\n      pop(contextStackCursor, fiber);\n    }\n\n    var popContextProvider_1 = popContextProvider;\n\n    var popTopLevelContextObject = function popTopLevelContextObject(fiber) {\n      pop(didPerformWorkStackCursor, fiber);\n      pop(contextStackCursor, fiber);\n    };\n\n    var pushTopLevelContextObject = function pushTopLevelContextObject(fiber, context, didChange) {\n      !(contextStackCursor.cursor == null) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      push(contextStackCursor, context, fiber);\n      push(didPerformWorkStackCursor, didChange, fiber);\n    };\n\n    function processChildContext$1(fiber, parentContext, isReconciling) {\n      var instance = fiber.stateNode;\n      var childContextTypes = fiber.type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n      // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n\n      if (typeof instance.getChildContext !== 'function') {\n        {\n          var componentName = getComponentName_1(fiber) || 'Unknown';\n\n          if (!warnedAboutMissingGetChildContext[componentName]) {\n            warnedAboutMissingGetChildContext[componentName] = true;\n            warning$20(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n          }\n        }\n        return parentContext;\n      }\n\n      var childContext = void 0;\n      {\n        ReactDebugCurrentFiber$2.setCurrentFiber(fiber, 'getChildContext');\n        startPhaseTimer(fiber, 'getChildContext');\n        childContext = instance.getChildContext();\n        stopPhaseTimer();\n        ReactDebugCurrentFiber$2.resetCurrentFiber();\n      }\n\n      for (var contextKey in childContext) {\n        !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName_1(fiber) || 'Unknown', contextKey) : void 0;\n      }\n\n      {\n        var name = getComponentName_1(fiber) || 'Unknown'; // We can only provide accurate element stacks if we pass work-in-progress tree\n        // during the begin or complete phase. However currently this function is also\n        // called from unstable_renderSubtree legacy implementation. In this case it unsafe to\n        // assume anything about the given fiber. We won't pass it down if we aren't sure.\n        // TODO: remove this hack when we delete unstable_renderSubtree in Fiber.\n\n        var workInProgress = isReconciling ? fiber : null;\n        ReactDebugCurrentFiber$2.setCurrentFiber(workInProgress, null);\n        checkPropTypes$1(childContextTypes, childContext, 'child context', name, ReactDebugCurrentFiber$2.getCurrentFiberStackAddendum);\n        ReactDebugCurrentFiber$2.resetCurrentFiber();\n      }\n      return _assign({}, parentContext, childContext);\n    }\n\n    var processChildContext_1 = processChildContext$1;\n\n    var pushContextProvider = function pushContextProvider(workInProgress) {\n      if (!isContextProvider$1(workInProgress)) {\n        return false;\n      }\n\n      var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\n      // If the instance does not exist yet, we will push null at first,\n      // and replace it on the stack later when invalidating the context.\n\n      var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyObject; // Remember the parent context so we can merge with it later.\n      // Inherit the parent's did-perform-work value to avoid inadvertantly blocking updates.\n\n      previousContext = contextStackCursor.current;\n      push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n      push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n      return true;\n    };\n\n    var invalidateContextProvider = function invalidateContextProvider(workInProgress, didChange) {\n      var instance = workInProgress.stateNode;\n      !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n      if (didChange) {\n        // Merge parent and own context.\n        // Skip this if we're not updating due to sCU.\n        // This avoids unnecessarily recomputing memoized values.\n        var mergedContext = processChildContext$1(workInProgress, previousContext, true);\n        instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\n        // It is important to unwind the context in the reverse order.\n\n        pop(didPerformWorkStackCursor, workInProgress);\n        pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\n\n        push(contextStackCursor, mergedContext, workInProgress);\n        push(didPerformWorkStackCursor, didChange, workInProgress);\n      } else {\n        pop(didPerformWorkStackCursor, workInProgress);\n        push(didPerformWorkStackCursor, didChange, workInProgress);\n      }\n    };\n\n    var resetContext = function resetContext() {\n      previousContext = emptyObject;\n      contextStackCursor.current = emptyObject;\n      didPerformWorkStackCursor.current = false;\n    };\n\n    var findCurrentUnmaskedContext$1 = function findCurrentUnmaskedContext$1(fiber) {\n      // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n      // makes sense elsewhere\n      !(isFiberMounted$1(fiber) && fiber.tag === ClassComponent$3) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      var node = fiber;\n\n      while (node.tag !== HostRoot$3) {\n        if (isContextProvider$1(node)) {\n          return node.stateNode.__reactInternalMemoizedMergedChildContext;\n        }\n\n        var parent = node['return'];\n        !parent ? invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        node = parent;\n      }\n\n      return node.stateNode.context;\n    };\n\n    var ReactFiberContext = {\n      getUnmaskedContext: getUnmaskedContext_1,\n      cacheContext: cacheContext_1,\n      getMaskedContext: getMaskedContext,\n      hasContextChanged: hasContextChanged,\n      isContextConsumer: isContextConsumer_1,\n      isContextProvider: isContextProvider_1,\n      popContextProvider: popContextProvider_1,\n      popTopLevelContextObject: popTopLevelContextObject,\n      pushTopLevelContextObject: pushTopLevelContextObject,\n      processChildContext: processChildContext_1,\n      pushContextProvider: pushContextProvider,\n      invalidateContextProvider: invalidateContextProvider,\n      resetContext: resetContext,\n      findCurrentUnmaskedContext: findCurrentUnmaskedContext$1\n    };\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule ReactTypeOfInternalContext\n     * \n     */\n\n    var ReactTypeOfInternalContext = {\n      NoContext: 0,\n      AsyncUpdates: 1\n    };\n    var IndeterminateComponent$1 = ReactTypeOfWork.IndeterminateComponent;\n    var ClassComponent$4 = ReactTypeOfWork.ClassComponent;\n    var HostRoot$5 = ReactTypeOfWork.HostRoot;\n    var HostComponent$5 = ReactTypeOfWork.HostComponent;\n    var HostText$3 = ReactTypeOfWork.HostText;\n    var HostPortal$2 = ReactTypeOfWork.HostPortal;\n    var CoroutineComponent = ReactTypeOfWork.CoroutineComponent;\n    var YieldComponent$1 = ReactTypeOfWork.YieldComponent;\n    var Fragment$1 = ReactTypeOfWork.Fragment;\n    var NoWork$1 = ReactPriorityLevel.NoWork;\n    var NoContext = ReactTypeOfInternalContext.NoContext;\n    var NoEffect$1 = ReactTypeOfSideEffect.NoEffect;\n    {\n      var getComponentName$6 = getComponentName_1;\n      var hasBadMapPolyfill = false;\n\n      try {\n        var nonExtensibleObject = Object.preventExtensions({});\n        /* eslint-disable no-new */\n\n        new Map([[nonExtensibleObject, null]]);\n        new Set([nonExtensibleObject]);\n        /* eslint-enable no-new */\n      } catch (e) {\n        // TODO: Consider warning about bad polyfills\n        hasBadMapPolyfill = true;\n      }\n    } // A Fiber is work on a Component that needs to be done or was done. There can\n    // be more than one per component.\n\n    {\n      var debugCounter = 1;\n    }\n\n    function FiberNode(tag, key, internalContextTag) {\n      // Instance\n      this.tag = tag;\n      this.key = key;\n      this.type = null;\n      this.stateNode = null; // Fiber\n\n      this['return'] = null;\n      this.child = null;\n      this.sibling = null;\n      this.index = 0;\n      this.ref = null;\n      this.pendingProps = null;\n      this.memoizedProps = null;\n      this.updateQueue = null;\n      this.memoizedState = null;\n      this.internalContextTag = internalContextTag; // Effects\n\n      this.effectTag = NoEffect$1;\n      this.nextEffect = null;\n      this.firstEffect = null;\n      this.lastEffect = null;\n      this.pendingWorkPriority = NoWork$1;\n      this.alternate = null;\n      {\n        this._debugID = debugCounter++;\n        this._debugSource = null;\n        this._debugOwner = null;\n        this._debugIsCurrentlyTiming = false;\n\n        if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n          Object.preventExtensions(this);\n        }\n      }\n    } // This is a constructor function, rather than a POJO constructor, still\n    // please ensure we do the following:\n    // 1) Nobody should add any instance methods on this. Instance methods can be\n    //    more difficult to predict when they get optimized and they are almost\n    //    never inlined properly in static compilers.\n    // 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n    //    always know when it is a fiber.\n    // 3) We might want to experiment with using numeric keys since they are easier\n    //    to optimize in a non-JIT environment.\n    // 4) We can easily go from a constructor to a createFiber object literal if that\n    //    is faster.\n    // 5) It should be easy to port this to a C struct and keep a C implementation\n    //    compatible.\n\n\n    var createFiber = function createFiber(tag, key, internalContextTag) {\n      // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n      return new FiberNode(tag, key, internalContextTag);\n    };\n\n    function shouldConstruct(Component) {\n      return !!(Component.prototype && Component.prototype.isReactComponent);\n    } // This is used to create an alternate fiber to do work on.\n\n\n    var createWorkInProgress = function createWorkInProgress(current, renderPriority) {\n      var workInProgress = current.alternate;\n\n      if (workInProgress === null) {\n        // We use a double buffering pooling technique because we know that we'll\n        // only ever need at most two versions of a tree. We pool the \"other\" unused\n        // node that we're free to reuse. This is lazily created to avoid allocating\n        // extra objects for things that are never updated. It also allow us to\n        // reclaim the extra memory if needed.\n        workInProgress = createFiber(current.tag, current.key, current.internalContextTag);\n        workInProgress.type = current.type;\n        workInProgress.stateNode = current.stateNode;\n        {\n          // DEV-only fields\n          workInProgress._debugID = current._debugID;\n          workInProgress._debugSource = current._debugSource;\n          workInProgress._debugOwner = current._debugOwner;\n        }\n        workInProgress.alternate = current;\n        current.alternate = workInProgress;\n      } else {\n        // We already have an alternate.\n        // Reset the effect tag.\n        workInProgress.effectTag = NoEffect$1; // The effect list is no longer valid.\n\n        workInProgress.nextEffect = null;\n        workInProgress.firstEffect = null;\n        workInProgress.lastEffect = null;\n      }\n\n      workInProgress.pendingWorkPriority = renderPriority;\n      workInProgress.child = current.child;\n      workInProgress.memoizedProps = current.memoizedProps;\n      workInProgress.memoizedState = current.memoizedState;\n      workInProgress.updateQueue = current.updateQueue; // pendingProps is set by the parent during reconciliation.\n      // TODO: Pass this as an argument.\n      // These will be overridden during the parent's reconciliation\n\n      workInProgress.sibling = current.sibling;\n      workInProgress.index = current.index;\n      workInProgress.ref = current.ref;\n      return workInProgress;\n    };\n\n    var createHostRootFiber$1 = function createHostRootFiber$1() {\n      var fiber = createFiber(HostRoot$5, null, NoContext);\n      return fiber;\n    };\n\n    var createFiberFromElement = function createFiberFromElement(element, internalContextTag, priorityLevel) {\n      var owner = null;\n      {\n        owner = element._owner;\n      }\n      var fiber = createFiberFromElementType(element.type, element.key, internalContextTag, owner);\n      fiber.pendingProps = element.props;\n      fiber.pendingWorkPriority = priorityLevel;\n      {\n        fiber._debugSource = element._source;\n        fiber._debugOwner = element._owner;\n      }\n      return fiber;\n    };\n\n    var createFiberFromFragment = function createFiberFromFragment(elements, internalContextTag, priorityLevel) {\n      // TODO: Consider supporting keyed fragments. Technically, we accidentally\n      // support that in the existing React.\n      var fiber = createFiber(Fragment$1, null, internalContextTag);\n      fiber.pendingProps = elements;\n      fiber.pendingWorkPriority = priorityLevel;\n      return fiber;\n    };\n\n    var createFiberFromText = function createFiberFromText(content, internalContextTag, priorityLevel) {\n      var fiber = createFiber(HostText$3, null, internalContextTag);\n      fiber.pendingProps = content;\n      fiber.pendingWorkPriority = priorityLevel;\n      return fiber;\n    };\n\n    function createFiberFromElementType(type, key, internalContextTag, debugOwner) {\n      var fiber = void 0;\n\n      if (typeof type === 'function') {\n        fiber = shouldConstruct(type) ? createFiber(ClassComponent$4, key, internalContextTag) : createFiber(IndeterminateComponent$1, key, internalContextTag);\n        fiber.type = type;\n      } else if (typeof type === 'string') {\n        fiber = createFiber(HostComponent$5, key, internalContextTag);\n        fiber.type = type;\n      } else if (typeof type === 'object' && type !== null && typeof type.tag === 'number') {\n        // Currently assumed to be a continuation and therefore is a fiber already.\n        // TODO: The yield system is currently broken for updates in some cases.\n        // The reified yield stores a fiber, but we don't know which fiber that is;\n        // the current or a workInProgress? When the continuation gets rendered here\n        // we don't know if we can reuse that fiber or if we need to clone it.\n        // There is probably a clever way to restructure this.\n        fiber = type;\n      } else {\n        var info = '';\n        {\n          if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in.\";\n          }\n\n          var ownerName = debugOwner ? getComponentName$6(debugOwner) : null;\n\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n        }\n        invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n      }\n\n      return fiber;\n    }\n\n    var createFiberFromElementType_1 = createFiberFromElementType;\n\n    var createFiberFromHostInstanceForDeletion = function createFiberFromHostInstanceForDeletion() {\n      var fiber = createFiber(HostComponent$5, null, NoContext);\n      fiber.type = 'DELETED';\n      return fiber;\n    };\n\n    var createFiberFromCoroutine = function createFiberFromCoroutine(coroutine, internalContextTag, priorityLevel) {\n      var fiber = createFiber(CoroutineComponent, coroutine.key, internalContextTag);\n      fiber.type = coroutine.handler;\n      fiber.pendingProps = coroutine;\n      fiber.pendingWorkPriority = priorityLevel;\n      return fiber;\n    };\n\n    var createFiberFromYield = function createFiberFromYield(yieldNode, internalContextTag, priorityLevel) {\n      var fiber = createFiber(YieldComponent$1, null, internalContextTag);\n      return fiber;\n    };\n\n    var createFiberFromPortal = function createFiberFromPortal(portal, internalContextTag, priorityLevel) {\n      var fiber = createFiber(HostPortal$2, portal.key, internalContextTag);\n      fiber.pendingProps = portal.children || [];\n      fiber.pendingWorkPriority = priorityLevel;\n      fiber.stateNode = {\n        containerInfo: portal.containerInfo,\n        implementation: portal.implementation\n      };\n      return fiber;\n    };\n\n    var largerPriority = function largerPriority(p1, p2) {\n      return p1 !== NoWork$1 && (p2 === NoWork$1 || p2 > p1) ? p1 : p2;\n    };\n\n    var ReactFiber = {\n      createWorkInProgress: createWorkInProgress,\n      createHostRootFiber: createHostRootFiber$1,\n      createFiberFromElement: createFiberFromElement,\n      createFiberFromFragment: createFiberFromFragment,\n      createFiberFromText: createFiberFromText,\n      createFiberFromElementType: createFiberFromElementType_1,\n      createFiberFromHostInstanceForDeletion: createFiberFromHostInstanceForDeletion,\n      createFiberFromCoroutine: createFiberFromCoroutine,\n      createFiberFromYield: createFiberFromYield,\n      createFiberFromPortal: createFiberFromPortal,\n      largerPriority: largerPriority\n    };\n    var createHostRootFiber = ReactFiber.createHostRootFiber;\n\n    var createFiberRoot$1 = function createFiberRoot$1(containerInfo) {\n      // Cyclic construction. This cheats the type system right now because\n      // stateNode is any.\n      var uninitializedFiber = createHostRootFiber();\n      var root = {\n        current: uninitializedFiber,\n        containerInfo: containerInfo,\n        isScheduled: false,\n        nextScheduledRoot: null,\n        context: null,\n        pendingContext: null\n      };\n      uninitializedFiber.stateNode = root;\n      return root;\n    };\n\n    var ReactFiberRoot = {\n      createFiberRoot: createFiberRoot$1\n    };\n\n    var defaultShowDialog = function defaultShowDialog(capturedError) {\n      return true;\n    };\n\n    var showDialog = defaultShowDialog;\n\n    function logCapturedError$1(capturedError) {\n      var logError = showDialog(capturedError); // Allow injected showDialog() to prevent default console.error logging.\n      // This enables renderers like ReactNative to better manage redbox behavior.\n\n      if (logError === false) {\n        return;\n      }\n\n      var error = capturedError.error;\n      {\n        var componentName = capturedError.componentName,\n            componentStack = capturedError.componentStack,\n            errorBoundaryName = capturedError.errorBoundaryName,\n            errorBoundaryFound = capturedError.errorBoundaryFound,\n            willRetry = capturedError.willRetry;\n        var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n        var errorBoundaryMessage = void 0; // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n\n        if (errorBoundaryFound && errorBoundaryName) {\n          if (willRetry) {\n            errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n          } else {\n            errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n          }\n        } else {\n          errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'You can learn more about error boundaries at https://fb.me/react-error-boundaries.';\n        }\n\n        var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage); // In development, we provide our own message with just the component stack.\n        // We don't include the original error message and JS stack because the browser\n        // has already printed it. Even if the application swallows the error, it is still\n        // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n\n        console.error(combinedMessage);\n      }\n    }\n\n    var injection$1 = {\n      /**\n       * Display custom dialog for lifecycle errors.\n       * Return false to prevent default behavior of logging to console.error.\n       */\n      injectDialog: function injectDialog(fn) {\n        !(showDialog === defaultShowDialog) ? invariant(false, 'The custom dialog was already injected.') : void 0;\n        !(typeof fn === 'function') ? invariant(false, 'Injected showDialog() must be a function.') : void 0;\n        showDialog = fn;\n      }\n    };\n    var logCapturedError_1 = logCapturedError$1;\n    var ReactFiberErrorLogger = {\n      injection: injection$1,\n      logCapturedError: logCapturedError_1\n    };\n    /**\n     * Copyright (c) 2014-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule ReactCoroutine\n     * \n     */\n    // The Symbol used to tag the special React types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n    var REACT_COROUTINE_TYPE$1;\n    var REACT_YIELD_TYPE$1;\n\n    if (typeof Symbol === 'function' && Symbol['for']) {\n      REACT_COROUTINE_TYPE$1 = Symbol['for']('react.coroutine');\n      REACT_YIELD_TYPE$1 = Symbol['for']('react.yield');\n    } else {\n      REACT_COROUTINE_TYPE$1 = 0xeac8;\n      REACT_YIELD_TYPE$1 = 0xeac9;\n    }\n\n    var createCoroutine = function createCoroutine(children, handler, props) {\n      var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var coroutine = {\n        // This tag allow us to uniquely identify this as a React Coroutine\n        $$typeof: REACT_COROUTINE_TYPE$1,\n        key: key == null ? null : '' + key,\n        children: children,\n        handler: handler,\n        props: props\n      };\n      {\n        // TODO: Add _store property for marking this as validated.\n        if (Object.freeze) {\n          Object.freeze(coroutine.props);\n          Object.freeze(coroutine);\n        }\n      }\n      return coroutine;\n    };\n\n    var createYield = function createYield(value) {\n      var yieldNode = {\n        // This tag allow us to uniquely identify this as a React Yield\n        $$typeof: REACT_YIELD_TYPE$1,\n        value: value\n      };\n      {\n        // TODO: Add _store property for marking this as validated.\n        if (Object.freeze) {\n          Object.freeze(yieldNode);\n        }\n      }\n      return yieldNode;\n    };\n    /**\n     * Verifies the object is a coroutine object.\n     */\n\n\n    var isCoroutine = function isCoroutine(object) {\n      return typeof object === 'object' && object !== null && object.$$typeof === REACT_COROUTINE_TYPE$1;\n    };\n    /**\n     * Verifies the object is a yield object.\n     */\n\n\n    var isYield = function isYield(object) {\n      return typeof object === 'object' && object !== null && object.$$typeof === REACT_YIELD_TYPE$1;\n    };\n\n    var REACT_YIELD_TYPE_1 = REACT_YIELD_TYPE$1;\n    var REACT_COROUTINE_TYPE_1 = REACT_COROUTINE_TYPE$1;\n    var ReactCoroutine = {\n      createCoroutine: createCoroutine,\n      createYield: createYield,\n      isCoroutine: isCoroutine,\n      isYield: isYield,\n      REACT_YIELD_TYPE: REACT_YIELD_TYPE_1,\n      REACT_COROUTINE_TYPE: REACT_COROUTINE_TYPE_1\n    };\n    /**\n     * Copyright (c) 2014-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule ReactPortal\n     * \n     */\n    // The Symbol used to tag the special React types. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n    var REACT_PORTAL_TYPE$1 = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.portal') || 0xeaca;\n\n    var createPortal$1 = function createPortal$1(children, containerInfo, // TODO: figure out the API for cross-renderer implementation.\n    implementation) {\n      var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      return {\n        // This tag allow us to uniquely identify this as a React Portal\n        $$typeof: REACT_PORTAL_TYPE$1,\n        key: key == null ? null : '' + key,\n        children: children,\n        containerInfo: containerInfo,\n        implementation: implementation\n      };\n    };\n    /**\n     * Verifies the object is a portal object.\n     */\n\n\n    var isPortal = function isPortal(object) {\n      return typeof object === 'object' && object !== null && object.$$typeof === REACT_PORTAL_TYPE$1;\n    };\n\n    var REACT_PORTAL_TYPE_1 = REACT_PORTAL_TYPE$1;\n    var ReactPortal = {\n      createPortal: createPortal$1,\n      isPortal: isPortal,\n      REACT_PORTAL_TYPE: REACT_PORTAL_TYPE_1\n    };\n    var REACT_COROUTINE_TYPE = ReactCoroutine.REACT_COROUTINE_TYPE;\n    var REACT_YIELD_TYPE = ReactCoroutine.REACT_YIELD_TYPE;\n    var REACT_PORTAL_TYPE = ReactPortal.REACT_PORTAL_TYPE;\n    {\n      var _require3$4 = ReactDebugCurrentFiber_1,\n          getCurrentFiberStackAddendum$5 = _require3$4.getCurrentFiberStackAddendum;\n      var warning$24 = require$$0;\n      var didWarnAboutMaps = false;\n      /**\n       * Warn if there's no key explicitly set on dynamic arrays of children or\n       * object keys are not valid. This allows us to keep track of children between\n       * updates.\n       */\n\n      var ownerHasKeyUseWarning = {};\n\n      var warnForMissingKey = function warnForMissingKey(child) {\n        if (child === null || typeof child !== 'object') {\n          return;\n        }\n\n        if (!child._store || child._store.validated || child.key != null) {\n          return;\n        }\n\n        !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        child._store.validated = true;\n        var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + (getCurrentFiberStackAddendum$5() || '');\n\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n        warning$24(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.%s', getCurrentFiberStackAddendum$5());\n      };\n    }\n    var createWorkInProgress$2 = ReactFiber.createWorkInProgress;\n    var createFiberFromElement$1 = ReactFiber.createFiberFromElement;\n    var createFiberFromFragment$1 = ReactFiber.createFiberFromFragment;\n    var createFiberFromText$1 = ReactFiber.createFiberFromText;\n    var createFiberFromCoroutine$1 = ReactFiber.createFiberFromCoroutine;\n    var createFiberFromYield$1 = ReactFiber.createFiberFromYield;\n    var createFiberFromPortal$1 = ReactFiber.createFiberFromPortal;\n    var isArray = Array.isArray;\n    var FunctionalComponent$2 = ReactTypeOfWork.FunctionalComponent;\n    var ClassComponent$7 = ReactTypeOfWork.ClassComponent;\n    var HostText$5 = ReactTypeOfWork.HostText;\n    var HostPortal$5 = ReactTypeOfWork.HostPortal;\n    var CoroutineComponent$2 = ReactTypeOfWork.CoroutineComponent;\n    var YieldComponent$3 = ReactTypeOfWork.YieldComponent;\n    var Fragment$3 = ReactTypeOfWork.Fragment;\n    var NoEffect$2 = ReactTypeOfSideEffect.NoEffect;\n    var Placement$3 = ReactTypeOfSideEffect.Placement;\n    var Deletion$1 = ReactTypeOfSideEffect.Deletion;\n    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n    // The Symbol used to tag the ReactElement type. If there is no native Symbol\n    // nor polyfill, then a plain number is used for performance.\n\n    var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || typeof maybeIterable === 'undefined') {\n        return null;\n      }\n\n      var iteratorFn = ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof iteratorFn === 'function') {\n        return iteratorFn;\n      }\n\n      return null;\n    }\n\n    function coerceRef(current, element) {\n      var mixedRef = element.ref;\n\n      if (mixedRef !== null && typeof mixedRef !== 'function') {\n        if (element._owner) {\n          var owner = element._owner;\n          var inst = void 0;\n\n          if (owner) {\n            if (typeof owner.tag === 'number') {\n              var ownerFiber = owner;\n              !(ownerFiber.tag === ClassComponent$7) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n              inst = ownerFiber.stateNode;\n            } else {\n              // Stack\n              inst = owner.getPublicInstance();\n            }\n          }\n\n          !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n          var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref\n\n          if (current !== null && current.ref !== null && current.ref._stringRef === stringRef) {\n            return current.ref;\n          }\n\n          var ref = function ref(value) {\n            var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;\n\n            if (value === null) {\n              delete refs[stringRef];\n            } else {\n              refs[stringRef] = value;\n            }\n          };\n\n          ref._stringRef = stringRef;\n          return ref;\n        } else {\n          !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function or a string.') : void 0;\n          !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).', mixedRef) : void 0;\n        }\n      }\n\n      return mixedRef;\n    }\n\n    function throwOnInvalidObjectType(returnFiber, newChild) {\n      if (returnFiber.type !== 'textarea') {\n        var addendum = '';\n        {\n          addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + (getCurrentFiberStackAddendum$5() || '');\n        }\n        invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n      }\n    }\n\n    function warnOnFunctionType() {\n      warning$24(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.%s', getCurrentFiberStackAddendum$5() || '');\n    } // This wrapper function exists because I expect to clone the code in each path\n    // to be able to optimize each path individually by branching early. This needs\n    // a compiler or we can do it manually. Helpers that don't need this branching\n    // live outside of this function.\n\n\n    function ChildReconciler(shouldClone, shouldTrackSideEffects) {\n      function deleteChild(returnFiber, childToDelete) {\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return;\n        }\n\n        if (!shouldClone) {\n          // When we're reconciling in place we have a work in progress copy. We\n          // actually want the current copy. If there is no current copy, then we\n          // don't need to track deletion side-effects.\n          if (childToDelete.alternate === null) {\n            return;\n          }\n\n          childToDelete = childToDelete.alternate;\n        } // Deletions are added in reversed order so we add it to the front.\n        // At this point, the return fiber's effect list is empty except for\n        // deletions, so we can just append the deletion to the list. The remaining\n        // effects aren't added until the complete phase. Once we implement\n        // resuming, this may not be true.\n\n\n        var last = returnFiber.lastEffect;\n\n        if (last !== null) {\n          last.nextEffect = childToDelete;\n          returnFiber.lastEffect = childToDelete;\n        } else {\n          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n        }\n\n        childToDelete.nextEffect = null;\n        childToDelete.effectTag = Deletion$1;\n      }\n\n      function deleteRemainingChildren(returnFiber, currentFirstChild) {\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return null;\n        } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n        // assuming that after the first child we've already added everything.\n\n\n        var childToDelete = currentFirstChild;\n\n        while (childToDelete !== null) {\n          deleteChild(returnFiber, childToDelete);\n          childToDelete = childToDelete.sibling;\n        }\n\n        return null;\n      }\n\n      function mapRemainingChildren(returnFiber, currentFirstChild) {\n        // Add the remaining children to a temporary map so that we can find them by\n        // keys quickly. Implicit (null) keys get added to this set with their index\n        var existingChildren = new Map();\n        var existingChild = currentFirstChild;\n\n        while (existingChild !== null) {\n          if (existingChild.key !== null) {\n            existingChildren.set(existingChild.key, existingChild);\n          } else {\n            existingChildren.set(existingChild.index, existingChild);\n          }\n\n          existingChild = existingChild.sibling;\n        }\n\n        return existingChildren;\n      }\n\n      function useFiber(fiber, priority) {\n        // We currently set sibling to null and index to 0 here because it is easy\n        // to forget to do before returning it. E.g. for the single child case.\n        if (shouldClone) {\n          var clone = createWorkInProgress$2(fiber, priority);\n          clone.index = 0;\n          clone.sibling = null;\n          return clone;\n        } else {\n          // We override the pending priority even if it is higher, because if\n          // we're reconciling at a lower priority that means that this was\n          // down-prioritized.\n          fiber.pendingWorkPriority = priority;\n          fiber.effectTag = NoEffect$2;\n          fiber.index = 0;\n          fiber.sibling = null;\n          return fiber;\n        }\n      }\n\n      function placeChild(newFiber, lastPlacedIndex, newIndex) {\n        newFiber.index = newIndex;\n\n        if (!shouldTrackSideEffects) {\n          // Noop.\n          return lastPlacedIndex;\n        }\n\n        var current = newFiber.alternate;\n\n        if (current !== null) {\n          var oldIndex = current.index;\n\n          if (oldIndex < lastPlacedIndex) {\n            // This is a move.\n            newFiber.effectTag = Placement$3;\n            return lastPlacedIndex;\n          } else {\n            // This item can stay in place.\n            return oldIndex;\n          }\n        } else {\n          // This is an insertion.\n          newFiber.effectTag = Placement$3;\n          return lastPlacedIndex;\n        }\n      }\n\n      function placeSingleChild(newFiber) {\n        // This is simpler for the single child case. We only need to do a\n        // placement for inserting new children.\n        if (shouldTrackSideEffects && newFiber.alternate === null) {\n          newFiber.effectTag = Placement$3;\n        }\n\n        return newFiber;\n      }\n\n      function updateTextNode(returnFiber, current, textContent, priority) {\n        if (current === null || current.tag !== HostText$5) {\n          // Insert\n          var created = createFiberFromText$1(textContent, returnFiber.internalContextTag, priority);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, priority);\n          existing.pendingProps = textContent;\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updateElement(returnFiber, current, element, priority) {\n        if (current === null || current.type !== element.type) {\n          // Insert\n          var created = createFiberFromElement$1(element, returnFiber.internalContextTag, priority);\n          created.ref = coerceRef(current, element);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Move based on index\n          var existing = useFiber(current, priority);\n          existing.ref = coerceRef(current, element);\n          existing.pendingProps = element.props;\n          existing['return'] = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        }\n      }\n\n      function updateCoroutine(returnFiber, current, coroutine, priority) {\n        // TODO: Should this also compare handler to determine whether to reuse?\n        if (current === null || current.tag !== CoroutineComponent$2) {\n          // Insert\n          var created = createFiberFromCoroutine$1(coroutine, returnFiber.internalContextTag, priority);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Move based on index\n          var existing = useFiber(current, priority);\n          existing.pendingProps = coroutine;\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updateYield(returnFiber, current, yieldNode, priority) {\n        if (current === null || current.tag !== YieldComponent$3) {\n          // Insert\n          var created = createFiberFromYield$1(yieldNode, returnFiber.internalContextTag, priority);\n          created.type = yieldNode.value;\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Move based on index\n          var existing = useFiber(current, priority);\n          existing.type = yieldNode.value;\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updatePortal(returnFiber, current, portal, priority) {\n        if (current === null || current.tag !== HostPortal$5 || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n          // Insert\n          var created = createFiberFromPortal$1(portal, returnFiber.internalContextTag, priority);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, priority);\n          existing.pendingProps = portal.children || [];\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function updateFragment(returnFiber, current, fragment, priority) {\n        if (current === null || current.tag !== Fragment$3) {\n          // Insert\n          var created = createFiberFromFragment$1(fragment, returnFiber.internalContextTag, priority);\n          created['return'] = returnFiber;\n          return created;\n        } else {\n          // Update\n          var existing = useFiber(current, priority);\n          existing.pendingProps = fragment;\n          existing['return'] = returnFiber;\n          return existing;\n        }\n      }\n\n      function createChild(returnFiber, newChild, priority) {\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes doesn't have keys. If the previous node is implicitly keyed\n          // we can continue to replace it without aborting even if it is not a text\n          // node.\n          var created = createFiberFromText$1('' + newChild, returnFiber.internalContextTag, priority);\n          created['return'] = returnFiber;\n          return created;\n        }\n\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                var _created = createFiberFromElement$1(newChild, returnFiber.internalContextTag, priority);\n\n                _created.ref = coerceRef(null, newChild);\n                _created['return'] = returnFiber;\n                return _created;\n              }\n\n            case REACT_COROUTINE_TYPE:\n              {\n                var _created2 = createFiberFromCoroutine$1(newChild, returnFiber.internalContextTag, priority);\n\n                _created2['return'] = returnFiber;\n                return _created2;\n              }\n\n            case REACT_YIELD_TYPE:\n              {\n                var _created3 = createFiberFromYield$1(newChild, returnFiber.internalContextTag, priority);\n\n                _created3.type = newChild.value;\n                _created3['return'] = returnFiber;\n                return _created3;\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                var _created4 = createFiberFromPortal$1(newChild, returnFiber.internalContextTag, priority);\n\n                _created4['return'] = returnFiber;\n                return _created4;\n              }\n          }\n\n          if (isArray(newChild) || getIteratorFn(newChild)) {\n            var _created5 = createFiberFromFragment$1(newChild, returnFiber.internalContextTag, priority);\n\n            _created5['return'] = returnFiber;\n            return _created5;\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n\n      function updateSlot(returnFiber, oldFiber, newChild, priority) {\n        // Update the fiber if the keys match, otherwise return null.\n        var key = oldFiber !== null ? oldFiber.key : null;\n\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes doesn't have keys. If the previous node is implicitly keyed\n          // we can continue to replace it without aborting even if it is not a text\n          // node.\n          if (key !== null) {\n            return null;\n          }\n\n          return updateTextNode(returnFiber, oldFiber, '' + newChild, priority);\n        }\n\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                if (newChild.key === key) {\n                  return updateElement(returnFiber, oldFiber, newChild, priority);\n                } else {\n                  return null;\n                }\n              }\n\n            case REACT_COROUTINE_TYPE:\n              {\n                if (newChild.key === key) {\n                  return updateCoroutine(returnFiber, oldFiber, newChild, priority);\n                } else {\n                  return null;\n                }\n              }\n\n            case REACT_YIELD_TYPE:\n              {\n                // Yields doesn't have keys. If the previous node is implicitly keyed\n                // we can continue to replace it without aborting even if it is not a\n                // yield.\n                if (key === null) {\n                  return updateYield(returnFiber, oldFiber, newChild, priority);\n                } else {\n                  return null;\n                }\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                if (newChild.key === key) {\n                  return updatePortal(returnFiber, oldFiber, newChild, priority);\n                } else {\n                  return null;\n                }\n              }\n          }\n\n          if (isArray(newChild) || getIteratorFn(newChild)) {\n            // Fragments doesn't have keys so if the previous key is implicit we can\n            // update it.\n            if (key !== null) {\n              return null;\n            }\n\n            return updateFragment(returnFiber, oldFiber, newChild, priority);\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n\n      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, priority) {\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          // Text nodes doesn't have keys, so we neither have to check the old nor\n          // new node for the key. If both are text nodes, they match.\n          var matchedFiber = existingChildren.get(newIdx) || null;\n          return updateTextNode(returnFiber, matchedFiber, '' + newChild, priority);\n        }\n\n        if (typeof newChild === 'object' && newChild !== null) {\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              {\n                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n                return updateElement(returnFiber, _matchedFiber, newChild, priority);\n              }\n\n            case REACT_COROUTINE_TYPE:\n              {\n                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n                return updateCoroutine(returnFiber, _matchedFiber2, newChild, priority);\n              }\n\n            case REACT_YIELD_TYPE:\n              {\n                // Yields doesn't have keys, so we neither have to check the old nor\n                // new node for the key. If both are yields, they match.\n                var _matchedFiber3 = existingChildren.get(newIdx) || null;\n\n                return updateYield(returnFiber, _matchedFiber3, newChild, priority);\n              }\n\n            case REACT_PORTAL_TYPE:\n              {\n                var _matchedFiber4 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n                return updatePortal(returnFiber, _matchedFiber4, newChild, priority);\n              }\n          }\n\n          if (isArray(newChild) || getIteratorFn(newChild)) {\n            var _matchedFiber5 = existingChildren.get(newIdx) || null;\n\n            return updateFragment(returnFiber, _matchedFiber5, newChild, priority);\n          }\n\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n        return null;\n      }\n      /**\n       * Warns if there is a duplicate or missing key\n       */\n\n\n      function warnOnInvalidKey(child, knownKeys) {\n        {\n          if (typeof child !== 'object' || child === null) {\n            return knownKeys;\n          }\n\n          switch (child.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n            case REACT_COROUTINE_TYPE:\n            case REACT_PORTAL_TYPE:\n              warnForMissingKey(child);\n              var key = child.key;\n\n              if (typeof key !== 'string') {\n                break;\n              }\n\n              if (knownKeys === null) {\n                knownKeys = new Set();\n                knownKeys.add(key);\n                break;\n              }\n\n              if (!knownKeys.has(key)) {\n                knownKeys.add(key);\n                break;\n              }\n\n              warning$24(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.%s', key, getCurrentFiberStackAddendum$5());\n              break;\n\n            default:\n              break;\n          }\n        }\n        return knownKeys;\n      }\n\n      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, priority) {\n        // This algorithm can't optimize by searching from boths ends since we\n        // don't have backpointers on fibers. I'm trying to see how far we can get\n        // with that model. If it ends up not being worth the tradeoffs, we can\n        // add it later.\n        // Even with a two ended optimization, we'd want to optimize for the case\n        // where there are few changes and brute force the comparison instead of\n        // going for the Map. It'd like to explore hitting that path first in\n        // forward-only mode and only go for the Map once we notice that we need\n        // lots of look ahead. This doesn't handle reversal as well as two ended\n        // search but that's unusual. Besides, for the two ended optimization to\n        // work on Iterables, we'd need to copy the whole set.\n        // In this first iteration, we'll just live with hitting the bad case\n        // (adding everything to a Map) in for every insert/move.\n        // If you change this code, also update reconcileChildrenIterator() which\n        // uses the same algorithm.\n        {\n          // First, validate keys.\n          var knownKeys = null;\n\n          for (var i = 0; i < newChildren.length; i++) {\n            var child = newChildren[i];\n            knownKeys = warnOnInvalidKey(child, knownKeys);\n          }\n        }\n        var resultingFirstChild = null;\n        var previousNewFiber = null;\n        var oldFiber = currentFirstChild;\n        var lastPlacedIndex = 0;\n        var newIdx = 0;\n        var nextOldFiber = null;\n\n        for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n          if (oldFiber.index > newIdx) {\n            nextOldFiber = oldFiber;\n            oldFiber = null;\n          } else {\n            nextOldFiber = oldFiber.sibling;\n          }\n\n          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], priority);\n\n          if (newFiber === null) {\n            // TODO: This breaks on empty slots like null children. That's\n            // unfortunate because it triggers the slow path all the time. We need\n            // a better way to communicate whether this was a miss or null,\n            // boolean, undefined, etc.\n            if (oldFiber === null) {\n              oldFiber = nextOldFiber;\n            }\n\n            break;\n          }\n\n          if (shouldTrackSideEffects) {\n            if (oldFiber && newFiber.alternate === null) {\n              // We matched the slot, but we didn't reuse the existing fiber, so we\n              // need to delete the existing child.\n              deleteChild(returnFiber, oldFiber);\n            }\n          }\n\n          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n          if (previousNewFiber === null) {\n            // TODO: Move out of the loop. This only happens for the first run.\n            resultingFirstChild = newFiber;\n          } else {\n            // TODO: Defer siblings if we're not at the right index for this slot.\n            // I.e. if we had null values before, then we want to defer this\n            // for each null value. However, we also don't want to call updateSlot\n            // with the previous one.\n            previousNewFiber.sibling = newFiber;\n          }\n\n          previousNewFiber = newFiber;\n          oldFiber = nextOldFiber;\n        }\n\n        if (newIdx === newChildren.length) {\n          // We've reached the end of the new children. We can delete the rest.\n          deleteRemainingChildren(returnFiber, oldFiber);\n          return resultingFirstChild;\n        }\n\n        if (oldFiber === null) {\n          // If we don't have any more existing children we can choose a fast path\n          // since the rest will all be insertions.\n          for (; newIdx < newChildren.length; newIdx++) {\n            var _newFiber = createChild(returnFiber, newChildren[newIdx], priority);\n\n            if (!_newFiber) {\n              continue;\n            }\n\n            lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              // TODO: Move out of the loop. This only happens for the first run.\n              resultingFirstChild = _newFiber;\n            } else {\n              previousNewFiber.sibling = _newFiber;\n            }\n\n            previousNewFiber = _newFiber;\n          }\n\n          return resultingFirstChild;\n        } // Add all children to a key map for quick lookups.\n\n\n        var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n        for (; newIdx < newChildren.length; newIdx++) {\n          var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], priority);\n\n          if (_newFiber2) {\n            if (shouldTrackSideEffects) {\n              if (_newFiber2.alternate !== null) {\n                // The new fiber is a work in progress, but if there exists a\n                // current, that means that we reused the fiber. We need to delete\n                // it from the child list so that we don't add it to the deletion\n                // list.\n                existingChildren['delete'](_newFiber2.key === null ? newIdx : _newFiber2.key);\n              }\n            }\n\n            lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              resultingFirstChild = _newFiber2;\n            } else {\n              previousNewFiber.sibling = _newFiber2;\n            }\n\n            previousNewFiber = _newFiber2;\n          }\n        }\n\n        if (shouldTrackSideEffects) {\n          // Any existing children that weren't consumed above were deleted. We need\n          // to add them to the deletion list.\n          existingChildren.forEach(function (child) {\n            return deleteChild(returnFiber, child);\n          });\n        }\n\n        return resultingFirstChild;\n      }\n\n      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, priority) {\n        // This is the same implementation as reconcileChildrenArray(),\n        // but using the iterator instead.\n        var iteratorFn = getIteratorFn(newChildrenIterable);\n        !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        {\n          // Warn about using Maps as children\n          if (typeof newChildrenIterable.entries === 'function') {\n            var possibleMap = newChildrenIterable;\n\n            if (possibleMap.entries === iteratorFn) {\n              warning$24(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', getCurrentFiberStackAddendum$5());\n              didWarnAboutMaps = true;\n            }\n          } // First, validate keys.\n          // We'll get a different iterator later for the main pass.\n\n\n          var _newChildren = iteratorFn.call(newChildrenIterable);\n\n          if (_newChildren) {\n            var knownKeys = null;\n\n            var _step = _newChildren.next();\n\n            for (; !_step.done; _step = _newChildren.next()) {\n              var child = _step.value;\n              knownKeys = warnOnInvalidKey(child, knownKeys);\n            }\n          }\n        }\n        var newChildren = iteratorFn.call(newChildrenIterable);\n        !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n        var resultingFirstChild = null;\n        var previousNewFiber = null;\n        var oldFiber = currentFirstChild;\n        var lastPlacedIndex = 0;\n        var newIdx = 0;\n        var nextOldFiber = null;\n        var step = newChildren.next();\n\n        for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n          if (oldFiber.index > newIdx) {\n            nextOldFiber = oldFiber;\n            oldFiber = null;\n          } else {\n            nextOldFiber = oldFiber.sibling;\n          }\n\n          var newFiber = updateSlot(returnFiber, oldFiber, step.value, priority);\n\n          if (newFiber === null) {\n            // TODO: This breaks on empty slots like null children. That's\n            // unfortunate because it triggers the slow path all the time. We need\n            // a better way to communicate whether this was a miss or null,\n            // boolean, undefined, etc.\n            if (!oldFiber) {\n              oldFiber = nextOldFiber;\n            }\n\n            break;\n          }\n\n          if (shouldTrackSideEffects) {\n            if (oldFiber && newFiber.alternate === null) {\n              // We matched the slot, but we didn't reuse the existing fiber, so we\n              // need to delete the existing child.\n              deleteChild(returnFiber, oldFiber);\n            }\n          }\n\n          lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n          if (previousNewFiber === null) {\n            // TODO: Move out of the loop. This only happens for the first run.\n            resultingFirstChild = newFiber;\n          } else {\n            // TODO: Defer siblings if we're not at the right index for this slot.\n            // I.e. if we had null values before, then we want to defer this\n            // for each null value. However, we also don't want to call updateSlot\n            // with the previous one.\n            previousNewFiber.sibling = newFiber;\n          }\n\n          previousNewFiber = newFiber;\n          oldFiber = nextOldFiber;\n        }\n\n        if (step.done) {\n          // We've reached the end of the new children. We can delete the rest.\n          deleteRemainingChildren(returnFiber, oldFiber);\n          return resultingFirstChild;\n        }\n\n        if (oldFiber === null) {\n          // If we don't have any more existing children we can choose a fast path\n          // since the rest will all be insertions.\n          for (; !step.done; newIdx++, step = newChildren.next()) {\n            var _newFiber3 = createChild(returnFiber, step.value, priority);\n\n            if (_newFiber3 === null) {\n              continue;\n            }\n\n            lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              // TODO: Move out of the loop. This only happens for the first run.\n              resultingFirstChild = _newFiber3;\n            } else {\n              previousNewFiber.sibling = _newFiber3;\n            }\n\n            previousNewFiber = _newFiber3;\n          }\n\n          return resultingFirstChild;\n        } // Add all children to a key map for quick lookups.\n\n\n        var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n        for (; !step.done; newIdx++, step = newChildren.next()) {\n          var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, priority);\n\n          if (_newFiber4 !== null) {\n            if (shouldTrackSideEffects) {\n              if (_newFiber4.alternate !== null) {\n                // The new fiber is a work in progress, but if there exists a\n                // current, that means that we reused the fiber. We need to delete\n                // it from the child list so that we don't add it to the deletion\n                // list.\n                existingChildren['delete'](_newFiber4.key === null ? newIdx : _newFiber4.key);\n              }\n            }\n\n            lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n\n            if (previousNewFiber === null) {\n              resultingFirstChild = _newFiber4;\n            } else {\n              previousNewFiber.sibling = _newFiber4;\n            }\n\n            previousNewFiber = _newFiber4;\n          }\n        }\n\n        if (shouldTrackSideEffects) {\n          // Any existing children that weren't consumed above were deleted. We need\n          // to add them to the deletion list.\n          existingChildren.forEach(function (child) {\n            return deleteChild(returnFiber, child);\n          });\n        }\n\n        return resultingFirstChild;\n      }\n\n      function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, priority) {\n        // There's no need to check for keys on text nodes since we don't have a\n        // way to define them.\n        if (currentFirstChild !== null && currentFirstChild.tag === HostText$5) {\n          // We already have an existing node so let's just update it and delete\n          // the rest.\n          deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n          var existing = useFiber(currentFirstChild, priority);\n          existing.pendingProps = textContent;\n          existing['return'] = returnFiber;\n          return existing;\n        } // The existing first child is not a text node so we need to create one\n        // and delete the existing ones.\n\n\n        deleteRemainingChildren(returnFiber, currentFirstChild);\n        var created = createFiberFromText$1(textContent, returnFiber.internalContextTag, priority);\n        created['return'] = returnFiber;\n        return created;\n      }\n\n      function reconcileSingleElement(returnFiber, currentFirstChild, element, priority) {\n        var key = element.key;\n        var child = currentFirstChild;\n\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.type === element.type) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, priority);\n              existing.ref = coerceRef(child, element);\n              existing.pendingProps = element.props;\n              existing['return'] = returnFiber;\n              {\n                existing._debugSource = element._source;\n                existing._debugOwner = element._owner;\n              }\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n\n          child = child.sibling;\n        }\n\n        var created = createFiberFromElement$1(element, returnFiber.internalContextTag, priority);\n        created.ref = coerceRef(currentFirstChild, element);\n        created['return'] = returnFiber;\n        return created;\n      }\n\n      function reconcileSingleCoroutine(returnFiber, currentFirstChild, coroutine, priority) {\n        var key = coroutine.key;\n        var child = currentFirstChild;\n\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.tag === CoroutineComponent$2) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, priority);\n              existing.pendingProps = coroutine;\n              existing['return'] = returnFiber;\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n\n          child = child.sibling;\n        }\n\n        var created = createFiberFromCoroutine$1(coroutine, returnFiber.internalContextTag, priority);\n        created['return'] = returnFiber;\n        return created;\n      }\n\n      function reconcileSingleYield(returnFiber, currentFirstChild, yieldNode, priority) {\n        // There's no need to check for keys on yields since they're stateless.\n        var child = currentFirstChild;\n\n        if (child !== null) {\n          if (child.tag === YieldComponent$3) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            var existing = useFiber(child, priority);\n            existing.type = yieldNode.value;\n            existing['return'] = returnFiber;\n            return existing;\n          } else {\n            deleteRemainingChildren(returnFiber, child);\n          }\n        }\n\n        var created = createFiberFromYield$1(yieldNode, returnFiber.internalContextTag, priority);\n        created.type = yieldNode.value;\n        created['return'] = returnFiber;\n        return created;\n      }\n\n      function reconcileSinglePortal(returnFiber, currentFirstChild, portal, priority) {\n        var key = portal.key;\n        var child = currentFirstChild;\n\n        while (child !== null) {\n          // TODO: If key === null and child.key === null, then this only applies to\n          // the first item in the list.\n          if (child.key === key) {\n            if (child.tag === HostPortal$5 && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n              deleteRemainingChildren(returnFiber, child.sibling);\n              var existing = useFiber(child, priority);\n              existing.pendingProps = portal.children || [];\n              existing['return'] = returnFiber;\n              return existing;\n            } else {\n              deleteRemainingChildren(returnFiber, child);\n              break;\n            }\n          } else {\n            deleteChild(returnFiber, child);\n          }\n\n          child = child.sibling;\n        }\n\n        var created = createFiberFromPortal$1(portal, returnFiber.internalContextTag, priority);\n        created['return'] = returnFiber;\n        return created;\n      } // This API will tag the children with the side-effect of the reconciliation\n      // itself. They will be added to the side-effect list as we pass through the\n      // children and the parent.\n\n\n      function reconcileChildFibers(returnFiber, currentFirstChild, newChild, priority) {\n        // This function is not recursive.\n        // If the top level item is an array, we treat it as a set of children,\n        // not as a fragment. Nested arrays on the other hand will be treated as\n        // fragment nodes. Recursion happens at the normal flow.\n        // Handle object types\n        var isObject = typeof newChild === 'object' && newChild !== null;\n\n        if (isObject) {\n          // Support only the subset of return types that Stack supports. Treat\n          // everything else as empty, but log a warning.\n          switch (newChild.$$typeof) {\n            case REACT_ELEMENT_TYPE:\n              return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, priority));\n\n            case REACT_COROUTINE_TYPE:\n              return placeSingleChild(reconcileSingleCoroutine(returnFiber, currentFirstChild, newChild, priority));\n\n            case REACT_YIELD_TYPE:\n              return placeSingleChild(reconcileSingleYield(returnFiber, currentFirstChild, newChild, priority));\n\n            case REACT_PORTAL_TYPE:\n              return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, priority));\n          }\n        }\n\n        if (typeof newChild === 'string' || typeof newChild === 'number') {\n          return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, priority));\n        }\n\n        if (isArray(newChild)) {\n          return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, priority);\n        }\n\n        if (getIteratorFn(newChild)) {\n          return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, priority);\n        }\n\n        if (isObject) {\n          throwOnInvalidObjectType(returnFiber, newChild);\n        }\n\n        {\n          if (typeof newChild === 'function') {\n            warnOnFunctionType();\n          }\n        }\n\n        if (typeof newChild === 'undefined') {\n          // If the new child is undefined, and the return fiber is a composite\n          // component, throw an error. If Fiber return types are disabled,\n          // we already threw above.\n          switch (returnFiber.tag) {\n            case ClassComponent$7:\n              {\n                {\n                  var instance = returnFiber.stateNode;\n\n                  if (instance.render._isMockFunction) {\n                    // We allow auto-mocks to proceed as if they're returning null.\n                    break;\n                  }\n                }\n              }\n            // Intentionally fall through to the next case, which handles both\n            // functions and classes\n            // eslint-disable-next-lined no-fallthrough\n\n            case FunctionalComponent$2:\n              {\n                var Component = returnFiber.type;\n                invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n              }\n          }\n        } // Remaining cases are all treated as empty.\n\n\n        return deleteRemainingChildren(returnFiber, currentFirstChild);\n      }\n\n      return reconcileChildFibers;\n    }\n\n    var reconcileChildFibers$1 = ChildReconciler(true, true);\n    var reconcileChildFibersInPlace$1 = ChildReconciler(false, true);\n    var mountChildFibersInPlace$1 = ChildReconciler(false, false);\n\n    var cloneChildFibers$1 = function cloneChildFibers$1(current, workInProgress) {\n      !(current === null || workInProgress.child === current.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n      if (workInProgress.child === null) {\n        return;\n      }\n\n      var currentChild = workInProgress.child;\n      var newChild = createWorkInProgress$2(currentChild, currentChild.pendingWorkPriority); // TODO: Pass this as an argument, since it's easy to forget.\n\n      newChild.pendingProps = currentChild.pendingProps;\n      workInProgress.child = newChild;\n      newChild['return'] = workInProgress;\n\n      while (currentChild.sibling !== null) {\n        currentChild = currentChild.sibling;\n        newChild = newChild.sibling = createWorkInProgress$2(currentChild, currentChild.pendingWorkPriority);\n        newChild.pendingProps = currentChild.pendingProps;\n        newChild['return'] = workInProgress;\n      }\n\n      newChild.sibling = null;\n    };\n\n    var ReactChildFiber = {\n      reconcileChildFibers: reconcileChildFibers$1,\n      reconcileChildFibersInPlace: reconcileChildFibersInPlace$1,\n      mountChildFibersInPlace: mountChildFibersInPlace$1,\n      cloneChildFibers: cloneChildFibers$1\n    };\n    var Update$1 = ReactTypeOfSideEffect.Update;\n    var AsyncUpdates$1 = ReactTypeOfInternalContext.AsyncUpdates;\n    var cacheContext$1 = ReactFiberContext.cacheContext;\n    var getMaskedContext$2 = ReactFiberContext.getMaskedContext;\n    var getUnmaskedContext$2 = ReactFiberContext.getUnmaskedContext;\n    var isContextConsumer$1 = ReactFiberContext.isContextConsumer;\n    var addUpdate$1 = ReactFiberUpdateQueue.addUpdate;\n    var addReplaceUpdate$1 = ReactFiberUpdateQueue.addReplaceUpdate;\n    var addForceUpdate$1 = ReactFiberUpdateQueue.addForceUpdate;\n    var beginUpdateQueue$2 = ReactFiberUpdateQueue.beginUpdateQueue;\n    var _require5 = ReactFiberContext;\n    var hasContextChanged$2 = _require5.hasContextChanged;\n    var isMounted$1 = ReactFiberTreeReflection.isMounted;\n    var fakeInternalInstance = {};\n    var isArray$1 = Array.isArray;\n    {\n      var _require7$1 = ReactDebugFiberPerf_1,\n          startPhaseTimer$1 = _require7$1.startPhaseTimer,\n          stopPhaseTimer$1 = _require7$1.stopPhaseTimer;\n      var warning$25 = require$$0;\n\n      var warnOnInvalidCallback = function warnOnInvalidCallback(callback, callerName) {\n        warning$25(callback === null || typeof callback === 'function', '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n      }; // This is so gross but it's at least non-critical and can be removed if\n      // it causes problems. This is meant to give a nicer error message for\n      // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n      // ...)) which otherwise throws a \"_processChildContext is not a function\"\n      // exception.\n\n\n      Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n        enumerable: false,\n        value: function value() {\n          invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n        }\n      });\n      Object.freeze(fakeInternalInstance);\n    }\n\n    var ReactFiberClassComponent = function ReactFiberClassComponent(scheduleUpdate, getPriorityContext, memoizeProps, memoizeState) {\n      // Class component state updater\n      var updater = {\n        isMounted: isMounted$1,\n        enqueueSetState: function enqueueSetState(instance, partialState, callback) {\n          var fiber = ReactInstanceMap_1.get(instance);\n          var priorityLevel = getPriorityContext(fiber, false);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'setState');\n          }\n          addUpdate$1(fiber, partialState, callback, priorityLevel);\n          scheduleUpdate(fiber, priorityLevel);\n        },\n        enqueueReplaceState: function enqueueReplaceState(instance, state, callback) {\n          var fiber = ReactInstanceMap_1.get(instance);\n          var priorityLevel = getPriorityContext(fiber, false);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'replaceState');\n          }\n          addReplaceUpdate$1(fiber, state, callback, priorityLevel);\n          scheduleUpdate(fiber, priorityLevel);\n        },\n        enqueueForceUpdate: function enqueueForceUpdate(instance, callback) {\n          var fiber = ReactInstanceMap_1.get(instance);\n          var priorityLevel = getPriorityContext(fiber, false);\n          callback = callback === undefined ? null : callback;\n          {\n            warnOnInvalidCallback(callback, 'forceUpdate');\n          }\n          addForceUpdate$1(fiber, callback, priorityLevel);\n          scheduleUpdate(fiber, priorityLevel);\n        }\n      };\n\n      function checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext) {\n        if (oldProps === null || workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate) {\n          // If the workInProgress already has an Update effect, return true\n          return true;\n        }\n\n        var instance = workInProgress.stateNode;\n        var type = workInProgress.type;\n\n        if (typeof instance.shouldComponentUpdate === 'function') {\n          {\n            startPhaseTimer$1(workInProgress, 'shouldComponentUpdate');\n          }\n          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, newContext);\n          {\n            stopPhaseTimer$1();\n          }\n          {\n            warning$25(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName_1(workInProgress) || 'Unknown');\n          }\n          return shouldUpdate;\n        }\n\n        if (type.prototype && type.prototype.isPureReactComponent) {\n          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n        }\n\n        return true;\n      }\n\n      function checkClassInstance(workInProgress) {\n        var instance = workInProgress.stateNode;\n        var type = workInProgress.type;\n        {\n          var name = getComponentName_1(workInProgress);\n          var renderPresent = instance.render;\n          warning$25(renderPresent, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n          var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n          warning$25(noGetInitialStateOnES6, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n          var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n          warning$25(noGetDefaultPropsOnES6, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n          var noInstancePropTypes = !instance.propTypes;\n          warning$25(noInstancePropTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n          var noInstanceContextTypes = !instance.contextTypes;\n          warning$25(noInstanceContextTypes, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n          var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n          warning$25(noComponentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n\n          if (type.prototype && type.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n            warning$25(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName_1(workInProgress) || 'A pure component');\n          }\n\n          var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n          warning$25(noComponentDidUnmount, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n          var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n          warning$25(noComponentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n          var hasMutatedProps = instance.props !== workInProgress.pendingProps;\n          warning$25(instance.props === undefined || !hasMutatedProps, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n          var noInstanceDefaultProps = !instance.defaultProps;\n          warning$25(noInstanceDefaultProps, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n        }\n        var state = instance.state;\n\n        if (state && (typeof state !== 'object' || isArray$1(state))) {\n          invariant(false, '%s.state: must be set to an object or null', getComponentName_1(workInProgress));\n        }\n\n        if (typeof instance.getChildContext === 'function') {\n          !(typeof workInProgress.type.childContextTypes === 'object') ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', getComponentName_1(workInProgress)) : void 0;\n        }\n      }\n\n      function resetInputPointers(workInProgress, instance) {\n        instance.props = workInProgress.memoizedProps;\n        instance.state = workInProgress.memoizedState;\n      }\n\n      function adoptClassInstance(workInProgress, instance) {\n        instance.updater = updater;\n        workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n\n        ReactInstanceMap_1.set(instance, workInProgress);\n        {\n          instance._reactInternalInstance = fakeInternalInstance;\n        }\n      }\n\n      function constructClassInstance(workInProgress, props) {\n        var ctor = workInProgress.type;\n        var unmaskedContext = getUnmaskedContext$2(workInProgress);\n        var needsContext = isContextConsumer$1(workInProgress);\n        var context = needsContext ? getMaskedContext$2(workInProgress, unmaskedContext) : emptyObject;\n        var instance = new ctor(props, context);\n        adoptClassInstance(workInProgress, instance); // Cache unmasked context so we can avoid recreating masked context unless necessary.\n        // ReactFiberContext usually updates this cache but can't for newly-created instances.\n\n        if (needsContext) {\n          cacheContext$1(workInProgress, unmaskedContext, context);\n        }\n\n        return instance;\n      }\n\n      function callComponentWillMount(workInProgress, instance) {\n        {\n          startPhaseTimer$1(workInProgress, 'componentWillMount');\n        }\n        var oldState = instance.state;\n        instance.componentWillMount();\n        {\n          stopPhaseTimer$1();\n        }\n\n        if (oldState !== instance.state) {\n          {\n            warning$25(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName_1(workInProgress));\n          }\n          updater.enqueueReplaceState(instance, instance.state, null);\n        }\n      }\n\n      function callComponentWillReceiveProps(workInProgress, instance, newProps, newContext) {\n        {\n          startPhaseTimer$1(workInProgress, 'componentWillReceiveProps');\n        }\n        var oldState = instance.state;\n        instance.componentWillReceiveProps(newProps, newContext);\n        {\n          stopPhaseTimer$1();\n        }\n\n        if (instance.state !== oldState) {\n          {\n            warning$25(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName_1(workInProgress));\n          }\n          updater.enqueueReplaceState(instance, instance.state, null);\n        }\n      } // Invokes the mount life-cycles on a previously never rendered instance.\n\n\n      function mountClassInstance(workInProgress, priorityLevel) {\n        var current = workInProgress.alternate;\n        {\n          checkClassInstance(workInProgress);\n        }\n        var instance = workInProgress.stateNode;\n        var state = instance.state || null;\n        var props = workInProgress.pendingProps;\n        !props ? invariant(false, 'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        var unmaskedContext = getUnmaskedContext$2(workInProgress);\n        instance.props = props;\n        instance.state = state;\n        instance.refs = emptyObject;\n        instance.context = getMaskedContext$2(workInProgress, unmaskedContext);\n\n        if (ReactFeatureFlags_1.enableAsyncSubtreeAPI && workInProgress.type != null && workInProgress.type.prototype != null && workInProgress.type.prototype.unstable_isAsyncReactComponent === true) {\n          workInProgress.internalContextTag |= AsyncUpdates$1;\n        }\n\n        if (typeof instance.componentWillMount === 'function') {\n          callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n          // process them now.\n\n          var updateQueue = workInProgress.updateQueue;\n\n          if (updateQueue !== null) {\n            instance.state = beginUpdateQueue$2(current, workInProgress, updateQueue, instance, state, props, priorityLevel);\n          }\n        }\n\n        if (typeof instance.componentDidMount === 'function') {\n          workInProgress.effectTag |= Update$1;\n        }\n      } // Called on a preexisting class instance. Returns false if a resumed render\n      // could be reused.\n      // function resumeMountClassInstance(\n      //   workInProgress: Fiber,\n      //   priorityLevel: PriorityLevel,\n      // ): boolean {\n      //   const instance = workInProgress.stateNode;\n      //   resetInputPointers(workInProgress, instance);\n      //   let newState = workInProgress.memoizedState;\n      //   let newProps = workInProgress.pendingProps;\n      //   if (!newProps) {\n      //     // If there isn't any new props, then we'll reuse the memoized props.\n      //     // This could be from already completed work.\n      //     newProps = workInProgress.memoizedProps;\n      //     invariant(\n      //       newProps != null,\n      //       'There should always be pending or memoized props. This error is ' +\n      //         'likely caused by a bug in React. Please file an issue.',\n      //     );\n      //   }\n      //   const newUnmaskedContext = getUnmaskedContext(workInProgress);\n      //   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);\n      //   const oldContext = instance.context;\n      //   const oldProps = workInProgress.memoizedProps;\n      //   if (\n      //     typeof instance.componentWillReceiveProps === 'function' &&\n      //     (oldProps !== newProps || oldContext !== newContext)\n      //   ) {\n      //     callComponentWillReceiveProps(\n      //       workInProgress,\n      //       instance,\n      //       newProps,\n      //       newContext,\n      //     );\n      //   }\n      //   // Process the update queue before calling shouldComponentUpdate\n      //   const updateQueue = workInProgress.updateQueue;\n      //   if (updateQueue !== null) {\n      //     newState = beginUpdateQueue(\n      //       workInProgress,\n      //       updateQueue,\n      //       instance,\n      //       newState,\n      //       newProps,\n      //       priorityLevel,\n      //     );\n      //   }\n      //   // TODO: Should we deal with a setState that happened after the last\n      //   // componentWillMount and before this componentWillMount? Probably\n      //   // unsupported anyway.\n      //   if (\n      //     !checkShouldComponentUpdate(\n      //       workInProgress,\n      //       workInProgress.memoizedProps,\n      //       newProps,\n      //       workInProgress.memoizedState,\n      //       newState,\n      //       newContext,\n      //     )\n      //   ) {\n      //     // Update the existing instance's state, props, and context pointers even\n      //     // though we're bailing out.\n      //     instance.props = newProps;\n      //     instance.state = newState;\n      //     instance.context = newContext;\n      //     return false;\n      //   }\n      //   // Update the input pointers now so that they are correct when we call\n      //   // componentWillMount\n      //   instance.props = newProps;\n      //   instance.state = newState;\n      //   instance.context = newContext;\n      //   if (typeof instance.componentWillMount === 'function') {\n      //     callComponentWillMount(workInProgress, instance);\n      //     // componentWillMount may have called setState. Process the update queue.\n      //     const newUpdateQueue = workInProgress.updateQueue;\n      //     if (newUpdateQueue !== null) {\n      //       newState = beginUpdateQueue(\n      //         workInProgress,\n      //         newUpdateQueue,\n      //         instance,\n      //         newState,\n      //         newProps,\n      //         priorityLevel,\n      //       );\n      //     }\n      //   }\n      //   if (typeof instance.componentDidMount === 'function') {\n      //     workInProgress.effectTag |= Update;\n      //   }\n      //   instance.state = newState;\n      //   return true;\n      // }\n      // Invokes the update life-cycles and returns false if it shouldn't rerender.\n\n\n      function updateClassInstance(current, workInProgress, priorityLevel) {\n        var instance = workInProgress.stateNode;\n        resetInputPointers(workInProgress, instance);\n        var oldProps = workInProgress.memoizedProps;\n        var newProps = workInProgress.pendingProps;\n\n        if (!newProps) {\n          // If there aren't any new props, then we'll reuse the memoized props.\n          // This could be from already completed work.\n          newProps = oldProps;\n          !(newProps != null) ? invariant(false, 'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        }\n\n        var oldContext = instance.context;\n        var newUnmaskedContext = getUnmaskedContext$2(workInProgress);\n        var newContext = getMaskedContext$2(workInProgress, newUnmaskedContext); // Note: During these life-cycles, instance.props/instance.state are what\n        // ever the previously attempted to render - not the \"current\". However,\n        // during componentDidUpdate we pass the \"current\" props.\n\n        if (typeof instance.componentWillReceiveProps === 'function' && (oldProps !== newProps || oldContext !== newContext)) {\n          callComponentWillReceiveProps(workInProgress, instance, newProps, newContext);\n        } // Compute the next state using the memoized state and the update queue.\n\n\n        var oldState = workInProgress.memoizedState; // TODO: Previous state can be null.\n\n        var newState = void 0;\n\n        if (workInProgress.updateQueue !== null) {\n          newState = beginUpdateQueue$2(current, workInProgress, workInProgress.updateQueue, instance, oldState, newProps, priorityLevel);\n        } else {\n          newState = oldState;\n        }\n\n        if (oldProps === newProps && oldState === newState && !hasContextChanged$2() && !(workInProgress.updateQueue !== null && workInProgress.updateQueue.hasForceUpdate)) {\n          // If an update was already in progress, we should schedule an Update\n          // effect even though we're bailing out, so that cWU/cDU are called.\n          if (typeof instance.componentDidUpdate === 'function') {\n            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n              workInProgress.effectTag |= Update$1;\n            }\n          }\n\n          return false;\n        }\n\n        var shouldUpdate = checkShouldComponentUpdate(workInProgress, oldProps, newProps, oldState, newState, newContext);\n\n        if (shouldUpdate) {\n          if (typeof instance.componentWillUpdate === 'function') {\n            {\n              startPhaseTimer$1(workInProgress, 'componentWillUpdate');\n            }\n            instance.componentWillUpdate(newProps, newState, newContext);\n            {\n              stopPhaseTimer$1();\n            }\n          }\n\n          if (typeof instance.componentDidUpdate === 'function') {\n            workInProgress.effectTag |= Update$1;\n          }\n        } else {\n          // If an update was already in progress, we should schedule an Update\n          // effect even though we're bailing out, so that cWU/cDU are called.\n          if (typeof instance.componentDidUpdate === 'function') {\n            if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n              workInProgress.effectTag |= Update$1;\n            }\n          } // If shouldComponentUpdate returned false, we should still update the\n          // memoized props/state to indicate that this work can be reused.\n\n\n          memoizeProps(workInProgress, newProps);\n          memoizeState(workInProgress, newState);\n        } // Update the existing instance's state, props, and context pointers even\n        // if shouldComponentUpdate returns false.\n\n\n        instance.props = newProps;\n        instance.state = newState;\n        instance.context = newContext;\n        return shouldUpdate;\n      }\n\n      return {\n        adoptClassInstance: adoptClassInstance,\n        constructClassInstance: constructClassInstance,\n        mountClassInstance: mountClassInstance,\n        // resumeMountClassInstance,\n        updateClassInstance: updateClassInstance\n      };\n    };\n\n    var mountChildFibersInPlace = ReactChildFiber.mountChildFibersInPlace;\n    var reconcileChildFibers = ReactChildFiber.reconcileChildFibers;\n    var reconcileChildFibersInPlace = ReactChildFiber.reconcileChildFibersInPlace;\n    var cloneChildFibers = ReactChildFiber.cloneChildFibers;\n    var beginUpdateQueue$1 = ReactFiberUpdateQueue.beginUpdateQueue;\n    var getMaskedContext$1 = ReactFiberContext.getMaskedContext;\n    var getUnmaskedContext$1 = ReactFiberContext.getUnmaskedContext;\n    var hasContextChanged$1 = ReactFiberContext.hasContextChanged;\n    var pushContextProvider$1 = ReactFiberContext.pushContextProvider;\n    var pushTopLevelContextObject$1 = ReactFiberContext.pushTopLevelContextObject;\n    var invalidateContextProvider$1 = ReactFiberContext.invalidateContextProvider;\n    var IndeterminateComponent$2 = ReactTypeOfWork.IndeterminateComponent;\n    var FunctionalComponent$1 = ReactTypeOfWork.FunctionalComponent;\n    var ClassComponent$6 = ReactTypeOfWork.ClassComponent;\n    var HostRoot$7 = ReactTypeOfWork.HostRoot;\n    var HostComponent$7 = ReactTypeOfWork.HostComponent;\n    var HostText$4 = ReactTypeOfWork.HostText;\n    var HostPortal$4 = ReactTypeOfWork.HostPortal;\n    var CoroutineComponent$1 = ReactTypeOfWork.CoroutineComponent;\n    var CoroutineHandlerPhase = ReactTypeOfWork.CoroutineHandlerPhase;\n    var YieldComponent$2 = ReactTypeOfWork.YieldComponent;\n    var Fragment$2 = ReactTypeOfWork.Fragment;\n    var NoWork$3 = ReactPriorityLevel.NoWork;\n    var OffscreenPriority$1 = ReactPriorityLevel.OffscreenPriority;\n    var PerformedWork$1 = ReactTypeOfSideEffect.PerformedWork;\n    var Placement$2 = ReactTypeOfSideEffect.Placement;\n    var ContentReset$1 = ReactTypeOfSideEffect.ContentReset;\n    var Err$1 = ReactTypeOfSideEffect.Err;\n    var Ref$1 = ReactTypeOfSideEffect.Ref;\n    var ReactCurrentOwner$2 = ReactGlobalSharedState_1.ReactCurrentOwner;\n    {\n      var ReactDebugCurrentFiber$4 = ReactDebugCurrentFiber_1;\n      var _require7 = ReactDebugFiberPerf_1,\n          cancelWorkTimer = _require7.cancelWorkTimer;\n      var warning$23 = require$$0;\n      var warnedAboutStatelessRefs = {};\n    }\n\n    var ReactFiberBeginWork = function ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleUpdate, getPriorityContext) {\n      var shouldSetTextContent = config.shouldSetTextContent,\n          useSyncScheduling = config.useSyncScheduling,\n          shouldDeprioritizeSubtree = config.shouldDeprioritizeSubtree;\n      var pushHostContext = hostContext.pushHostContext,\n          pushHostContainer = hostContext.pushHostContainer;\n      var enterHydrationState = hydrationContext.enterHydrationState,\n          resetHydrationState = hydrationContext.resetHydrationState,\n          tryToClaimNextHydratableInstance = hydrationContext.tryToClaimNextHydratableInstance;\n\n      var _ReactFiberClassCompo = ReactFiberClassComponent(scheduleUpdate, getPriorityContext, memoizeProps, memoizeState),\n          adoptClassInstance = _ReactFiberClassCompo.adoptClassInstance,\n          constructClassInstance = _ReactFiberClassCompo.constructClassInstance,\n          mountClassInstance = _ReactFiberClassCompo.mountClassInstance,\n          updateClassInstance = _ReactFiberClassCompo.updateClassInstance;\n\n      function reconcileChildren(current, workInProgress, nextChildren) {\n        var priorityLevel = workInProgress.pendingWorkPriority;\n        reconcileChildrenAtPriority(current, workInProgress, nextChildren, priorityLevel);\n      }\n\n      function reconcileChildrenAtPriority(current, workInProgress, nextChildren, priorityLevel) {\n        if (current === null) {\n          // If this is a fresh new component that hasn't been rendered yet, we\n          // won't update its child set by applying minimal side-effects. Instead,\n          // we will add them all to the child before it gets rendered. That means\n          // we can optimize this reconciliation pass by not tracking side-effects.\n          workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, priorityLevel);\n        } else if (current.child === workInProgress.child) {\n          // If the current child is the same as the work in progress, it means that\n          // we haven't yet started any work on these children. Therefore, we use\n          // the clone algorithm to create a copy of all the current children.\n          // If we had any progressed work already, that is invalid at this point so\n          // let's throw it out.\n          workInProgress.child = reconcileChildFibers(workInProgress, workInProgress.child, nextChildren, priorityLevel);\n        } else {\n          // If, on the other hand, it is already using a clone, that means we've\n          // already begun some work on this tree and we can continue where we left\n          // off by reconciling against the existing children.\n          workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, priorityLevel);\n        }\n      }\n\n      function updateFragment(current, workInProgress) {\n        var nextChildren = workInProgress.pendingProps;\n\n        if (hasContextChanged$1()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextChildren === null) {\n            nextChildren = workInProgress.memoizedProps;\n          }\n        } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextChildren);\n        return workInProgress.child;\n      }\n\n      function markRef(current, workInProgress) {\n        var ref = workInProgress.ref;\n\n        if (ref !== null && (!current || current.ref !== ref)) {\n          // Schedule a Ref effect\n          workInProgress.effectTag |= Ref$1;\n        }\n      }\n\n      function updateFunctionalComponent(current, workInProgress) {\n        var fn = workInProgress.type;\n        var nextProps = workInProgress.pendingProps;\n        var memoizedProps = workInProgress.memoizedProps;\n\n        if (hasContextChanged$1()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextProps === null) {\n            nextProps = memoizedProps;\n          }\n        } else {\n          if (nextProps === null || memoizedProps === nextProps) {\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          } // TODO: consider bringing fn.shouldComponentUpdate() back.\n          // It used to be here.\n\n        }\n\n        var unmaskedContext = getUnmaskedContext$1(workInProgress);\n        var context = getMaskedContext$1(workInProgress, unmaskedContext);\n        var nextChildren;\n        {\n          ReactCurrentOwner$2.current = workInProgress;\n          ReactDebugCurrentFiber$4.setCurrentFiber(workInProgress, 'render');\n          nextChildren = fn(nextProps, context);\n          ReactDebugCurrentFiber$4.setCurrentFiber(workInProgress, null);\n        } // React DevTools reads this flag.\n\n        workInProgress.effectTag |= PerformedWork$1;\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextProps);\n        return workInProgress.child;\n      }\n\n      function updateClassComponent(current, workInProgress, priorityLevel) {\n        // Push context providers early to prevent context stack mismatches.\n        // During mounting we don't know the child context yet as the instance doesn't exist.\n        // We will invalidate the child context in finishClassComponent() right after rendering.\n        var hasContext = pushContextProvider$1(workInProgress);\n        var shouldUpdate = void 0;\n\n        if (current === null) {\n          if (!workInProgress.stateNode) {\n            // In the initial pass we might need to construct the instance.\n            constructClassInstance(workInProgress, workInProgress.pendingProps);\n            mountClassInstance(workInProgress, priorityLevel);\n            shouldUpdate = true;\n          } else {\n            invariant(false, 'Resuming work not yet implemented.'); // In a resume, we'll already have an instance we can reuse.\n            // shouldUpdate = resumeMountClassInstance(workInProgress, priorityLevel);\n          }\n        } else {\n          shouldUpdate = updateClassInstance(current, workInProgress, priorityLevel);\n        }\n\n        return finishClassComponent(current, workInProgress, shouldUpdate, hasContext);\n      }\n\n      function finishClassComponent(current, workInProgress, shouldUpdate, hasContext) {\n        // Refs should update even if shouldComponentUpdate returns false\n        markRef(current, workInProgress);\n\n        if (!shouldUpdate) {\n          // Context providers should defer to sCU for rendering\n          if (hasContext) {\n            invalidateContextProvider$1(workInProgress, false);\n          }\n\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        var instance = workInProgress.stateNode; // Rerender\n\n        ReactCurrentOwner$2.current = workInProgress;\n        var nextChildren = void 0;\n        {\n          ReactDebugCurrentFiber$4.setCurrentFiber(workInProgress, 'render');\n          nextChildren = instance.render();\n          ReactDebugCurrentFiber$4.setCurrentFiber(workInProgress, null);\n        } // React DevTools reads this flag.\n\n        workInProgress.effectTag |= PerformedWork$1;\n        reconcileChildren(current, workInProgress, nextChildren); // Memoize props and state using the values we just used to render.\n        // TODO: Restructure so we never read values from the instance.\n\n        memoizeState(workInProgress, instance.state);\n        memoizeProps(workInProgress, instance.props); // The context might have changed so we need to recalculate it.\n\n        if (hasContext) {\n          invalidateContextProvider$1(workInProgress, true);\n        }\n\n        return workInProgress.child;\n      }\n\n      function pushHostRootContext(workInProgress) {\n        var root = workInProgress.stateNode;\n\n        if (root.pendingContext) {\n          pushTopLevelContextObject$1(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n        } else if (root.context) {\n          // Should always be set\n          pushTopLevelContextObject$1(workInProgress, root.context, false);\n        }\n\n        pushHostContainer(workInProgress, root.containerInfo);\n      }\n\n      function updateHostRoot(current, workInProgress, priorityLevel) {\n        pushHostRootContext(workInProgress);\n        var updateQueue = workInProgress.updateQueue;\n\n        if (updateQueue !== null) {\n          var prevState = workInProgress.memoizedState;\n          var state = beginUpdateQueue$1(current, workInProgress, updateQueue, null, prevState, null, priorityLevel);\n\n          if (prevState === state) {\n            // If the state is the same as before, that's a bailout because we had\n            // no work matching this priority.\n            resetHydrationState();\n            return bailoutOnAlreadyFinishedWork(current, workInProgress);\n          }\n\n          var element = state.element;\n\n          if ((current === null || current.child === null) && enterHydrationState(workInProgress)) {\n            // If we don't have any current children this might be the first pass.\n            // We always try to hydrate. If this isn't a hydration pass there won't\n            // be any children to hydrate which is effectively the same thing as\n            // not hydrating.\n            // This is a bit of a hack. We track the host root as a placement to\n            // know that we're currently in a mounting state. That way isMounted\n            // works as expected. We must reset this before committing.\n            // TODO: Delete this when we delete isMounted and findDOMNode.\n            workInProgress.effectTag |= Placement$2; // Ensure that children mount into this root without tracking\n            // side-effects. This ensures that we don't store Placement effects on\n            // nodes that will be hydrated.\n\n            workInProgress.child = mountChildFibersInPlace(workInProgress, workInProgress.child, element, priorityLevel);\n          } else {\n            // Otherwise reset hydration state in case we aborted and resumed another\n            // root.\n            resetHydrationState();\n            reconcileChildren(current, workInProgress, element);\n          }\n\n          memoizeState(workInProgress, state);\n          return workInProgress.child;\n        }\n\n        resetHydrationState(); // If there is no update queue, that's a bailout because the root has no props.\n\n        return bailoutOnAlreadyFinishedWork(current, workInProgress);\n      }\n\n      function updateHostComponent(current, workInProgress, renderPriority) {\n        pushHostContext(workInProgress);\n\n        if (current === null) {\n          tryToClaimNextHydratableInstance(workInProgress);\n        }\n\n        var type = workInProgress.type;\n        var memoizedProps = workInProgress.memoizedProps;\n        var nextProps = workInProgress.pendingProps;\n\n        if (nextProps === null) {\n          nextProps = memoizedProps;\n          !(nextProps !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        }\n\n        var prevProps = current !== null ? current.memoizedProps : null;\n\n        if (hasContextChanged$1()) {// Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n        } else if (nextProps === null || memoizedProps === nextProps) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        var nextChildren = nextProps.children;\n        var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n        if (isDirectTextChild) {\n          // We special case a direct text child of a host node. This is a common\n          // case. We won't handle it as a reified child. We will instead handle\n          // this in the host environment that also have access to this prop. That\n          // avoids allocating another HostText fiber and traversing it.\n          nextChildren = null;\n        } else if (prevProps && shouldSetTextContent(type, prevProps)) {\n          // If we're switching from a direct text child to a normal child, or to\n          // empty, we need to schedule the text content to be reset.\n          workInProgress.effectTag |= ContentReset$1;\n        }\n\n        markRef(current, workInProgress); // Check the host config to see if the children are offscreen/hidden.\n\n        if (renderPriority !== OffscreenPriority$1 && !useSyncScheduling && shouldDeprioritizeSubtree(type, nextProps)) {\n          // Down-prioritize the children.\n          workInProgress.pendingWorkPriority = OffscreenPriority$1; // Bailout and come back to this fiber later at OffscreenPriority.\n\n          return null;\n        }\n\n        reconcileChildren(current, workInProgress, nextChildren);\n        memoizeProps(workInProgress, nextProps);\n        return workInProgress.child;\n      }\n\n      function updateHostText(current, workInProgress) {\n        if (current === null) {\n          tryToClaimNextHydratableInstance(workInProgress);\n        }\n\n        var nextProps = workInProgress.pendingProps;\n\n        if (nextProps === null) {\n          nextProps = workInProgress.memoizedProps;\n        }\n\n        memoizeProps(workInProgress, nextProps); // Nothing to do here. This is terminal. We'll do the completion step\n        // immediately after.\n\n        return null;\n      }\n\n      function mountIndeterminateComponent(current, workInProgress, priorityLevel) {\n        !(current === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        var fn = workInProgress.type;\n        var props = workInProgress.pendingProps;\n        var unmaskedContext = getUnmaskedContext$1(workInProgress);\n        var context = getMaskedContext$1(workInProgress, unmaskedContext);\n        var value;\n        {\n          ReactCurrentOwner$2.current = workInProgress;\n          value = fn(props, context);\n        } // React DevTools reads this flag.\n\n        workInProgress.effectTag |= PerformedWork$1;\n\n        if (typeof value === 'object' && value !== null && typeof value.render === 'function') {\n          // Proceed under the assumption that this is a class instance\n          workInProgress.tag = ClassComponent$6; // Push context providers early to prevent context stack mismatches.\n          // During mounting we don't know the child context yet as the instance doesn't exist.\n          // We will invalidate the child context in finishClassComponent() right after rendering.\n\n          var hasContext = pushContextProvider$1(workInProgress);\n          adoptClassInstance(workInProgress, value);\n          mountClassInstance(workInProgress, priorityLevel);\n          return finishClassComponent(current, workInProgress, true, hasContext);\n        } else {\n          // Proceed under the assumption that this is a functional component\n          workInProgress.tag = FunctionalComponent$1;\n          {\n            var Component = workInProgress.type;\n\n            if (Component) {\n              warning$23(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component');\n            }\n\n            if (workInProgress.ref !== null) {\n              var info = '';\n              var ownerName = ReactDebugCurrentFiber$4.getCurrentFiberOwnerName();\n\n              if (ownerName) {\n                info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n              }\n\n              var warningKey = ownerName || workInProgress._debugID || '';\n              var debugSource = workInProgress._debugSource;\n\n              if (debugSource) {\n                warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n              }\n\n              if (!warnedAboutStatelessRefs[warningKey]) {\n                warnedAboutStatelessRefs[warningKey] = true;\n                warning$23(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s%s', info, ReactDebugCurrentFiber$4.getCurrentFiberStackAddendum());\n              }\n            }\n          }\n          reconcileChildren(current, workInProgress, value);\n          memoizeProps(workInProgress, props);\n          return workInProgress.child;\n        }\n      }\n\n      function updateCoroutineComponent(current, workInProgress) {\n        var nextCoroutine = workInProgress.pendingProps;\n\n        if (hasContextChanged$1()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextCoroutine === null) {\n            nextCoroutine = current && current.memoizedProps;\n            !(nextCoroutine !== null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          }\n        } else if (nextCoroutine === null || workInProgress.memoizedProps === nextCoroutine) {\n          nextCoroutine = workInProgress.memoizedProps; // TODO: When bailing out, we might need to return the stateNode instead\n          // of the child. To check it for work.\n          // return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        var nextChildren = nextCoroutine.children;\n        var priorityLevel = workInProgress.pendingWorkPriority; // The following is a fork of reconcileChildrenAtPriority but using\n        // stateNode to store the child.\n\n        if (current === null) {\n          workInProgress.stateNode = mountChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, priorityLevel);\n        } else if (current.child === workInProgress.child) {\n          workInProgress.stateNode = reconcileChildFibers(workInProgress, workInProgress.stateNode, nextChildren, priorityLevel);\n        } else {\n          workInProgress.stateNode = reconcileChildFibersInPlace(workInProgress, workInProgress.stateNode, nextChildren, priorityLevel);\n        }\n\n        memoizeProps(workInProgress, nextCoroutine); // This doesn't take arbitrary time so we could synchronously just begin\n        // eagerly do the work of workInProgress.child as an optimization.\n\n        return workInProgress.stateNode;\n      }\n\n      function updatePortalComponent(current, workInProgress) {\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        var priorityLevel = workInProgress.pendingWorkPriority;\n        var nextChildren = workInProgress.pendingProps;\n\n        if (hasContextChanged$1()) {\n          // Normally we can bail out on props equality but if context has changed\n          // we don't do the bailout and we have to reuse existing props instead.\n          if (nextChildren === null) {\n            nextChildren = current && current.memoizedProps;\n            !(nextChildren != null) ? invariant(false, 'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n          }\n        } else if (nextChildren === null || workInProgress.memoizedProps === nextChildren) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress);\n        }\n\n        if (current === null) {\n          // Portals are special because we don't append the children during mount\n          // but at commit. Therefore we need to track insertions which the normal\n          // flow doesn't do during mount. This doesn't happen at the root because\n          // the root always starts with a \"current\" with a null child.\n          // TODO: Consider unifying this with how the root works.\n          workInProgress.child = reconcileChildFibersInPlace(workInProgress, workInProgress.child, nextChildren, priorityLevel);\n          memoizeProps(workInProgress, nextChildren);\n        } else {\n          reconcileChildren(current, workInProgress, nextChildren);\n          memoizeProps(workInProgress, nextChildren);\n        }\n\n        return workInProgress.child;\n      }\n      /*\n      function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n        let child = firstChild;\n        do {\n          // Ensure that the first and last effect of the parent corresponds\n          // to the children's first and last effect.\n          if (!returnFiber.firstEffect) {\n            returnFiber.firstEffect = child.firstEffect;\n          }\n          if (child.lastEffect) {\n            if (returnFiber.lastEffect) {\n              returnFiber.lastEffect.nextEffect = child.firstEffect;\n            }\n            returnFiber.lastEffect = child.lastEffect;\n          }\n        } while (child = child.sibling);\n      }\n      */\n\n\n      function bailoutOnAlreadyFinishedWork(current, workInProgress) {\n        {\n          cancelWorkTimer(workInProgress);\n        } // TODO: We should ideally be able to bail out early if the children have no\n        // more work to do. However, since we don't have a separation of this\n        // Fiber's priority and its children yet - we don't know without doing lots\n        // of the same work we do anyway. Once we have that separation we can just\n        // bail out here if the children has no more work at this priority level.\n        // if (workInProgress.priorityOfChildren <= priorityLevel) {\n        //   // If there are side-effects in these children that have not yet been\n        //   // committed we need to ensure that they get properly transferred up.\n        //   if (current && current.child !== workInProgress.child) {\n        //     reuseChildrenEffects(workInProgress, child);\n        //   }\n        //   return null;\n        // }\n\n        cloneChildFibers(current, workInProgress);\n        return workInProgress.child;\n      }\n\n      function bailoutOnLowPriority(current, workInProgress) {\n        {\n          cancelWorkTimer(workInProgress);\n        } // TODO: Handle HostComponent tags here as well and call pushHostContext()?\n        // See PR 8590 discussion for context\n\n        switch (workInProgress.tag) {\n          case HostRoot$7:\n            pushHostRootContext(workInProgress);\n            break;\n\n          case ClassComponent$6:\n            pushContextProvider$1(workInProgress);\n            break;\n\n          case HostPortal$4:\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n            break;\n        } // TODO: What if this is currently in progress?\n        // How can that happen? How is this not being cloned?\n\n\n        return null;\n      } // TODO: Delete memoizeProps/State and move to reconcile/bailout instead\n\n\n      function memoizeProps(workInProgress, nextProps) {\n        workInProgress.memoizedProps = nextProps;\n      }\n\n      function memoizeState(workInProgress, nextState) {\n        workInProgress.memoizedState = nextState; // Don't reset the updateQueue, in case there are pending updates. Resetting\n        // is handled by beginUpdateQueue.\n      }\n\n      function beginWork(current, workInProgress, priorityLevel) {\n        if (workInProgress.pendingWorkPriority === NoWork$3 || workInProgress.pendingWorkPriority > priorityLevel) {\n          return bailoutOnLowPriority(current, workInProgress);\n        }\n\n        {\n          ReactDebugCurrentFiber$4.setCurrentFiber(workInProgress, null);\n        }\n\n        switch (workInProgress.tag) {\n          case IndeterminateComponent$2:\n            return mountIndeterminateComponent(current, workInProgress, priorityLevel);\n\n          case FunctionalComponent$1:\n            return updateFunctionalComponent(current, workInProgress);\n\n          case ClassComponent$6:\n            return updateClassComponent(current, workInProgress, priorityLevel);\n\n          case HostRoot$7:\n            return updateHostRoot(current, workInProgress, priorityLevel);\n\n          case HostComponent$7:\n            return updateHostComponent(current, workInProgress, priorityLevel);\n\n          case HostText$4:\n            return updateHostText(current, workInProgress);\n\n          case CoroutineHandlerPhase:\n            // This is a restart. Reset the tag to the initial phase.\n            workInProgress.tag = CoroutineComponent$1;\n          // Intentionally fall through since this is now the same.\n\n          case CoroutineComponent$1:\n            return updateCoroutineComponent(current, workInProgress);\n\n          case YieldComponent$2:\n            // A yield component is just a placeholder, we can just run through the\n            // next one immediately.\n            return null;\n\n          case HostPortal$4:\n            return updatePortalComponent(current, workInProgress);\n\n          case Fragment$2:\n            return updateFragment(current, workInProgress);\n\n          default:\n            invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n\n      function beginFailedWork(current, workInProgress, priorityLevel) {\n        // Push context providers here to avoid a push/pop context mismatch.\n        switch (workInProgress.tag) {\n          case ClassComponent$6:\n            pushContextProvider$1(workInProgress);\n            break;\n\n          case HostRoot$7:\n            pushHostRootContext(workInProgress);\n            break;\n\n          default:\n            invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n        } // Add an error effect so we can handle the error during the commit phase\n\n\n        workInProgress.effectTag |= Err$1; // This is a weird case where we do \"resume\" work — work that failed on\n        // our first attempt. Because we no longer have a notion of \"progressed\n        // deletions,\" reset the child to the current child to make sure we delete\n        // it again. TODO: Find a better way to handle this, perhaps during a more\n        // general overhaul of error handling.\n\n        if (current === null) {\n          workInProgress.child = null;\n        } else if (workInProgress.child !== current.child) {\n          workInProgress.child = current.child;\n        }\n\n        if (workInProgress.pendingWorkPriority === NoWork$3 || workInProgress.pendingWorkPriority > priorityLevel) {\n          return bailoutOnLowPriority(current, workInProgress);\n        } // If we don't bail out, we're going be recomputing our children so we need\n        // to drop our effect list.\n\n\n        workInProgress.firstEffect = null;\n        workInProgress.lastEffect = null; // Unmount the current children as if the component rendered null\n\n        var nextChildren = null;\n        reconcileChildrenAtPriority(current, workInProgress, nextChildren, priorityLevel);\n\n        if (workInProgress.tag === ClassComponent$6) {\n          var instance = workInProgress.stateNode;\n          workInProgress.memoizedProps = instance.props;\n          workInProgress.memoizedState = instance.state;\n        }\n\n        return workInProgress.child;\n      }\n\n      return {\n        beginWork: beginWork,\n        beginFailedWork: beginFailedWork\n      };\n    };\n\n    var reconcileChildFibers$2 = ReactChildFiber.reconcileChildFibers;\n    var popContextProvider$2 = ReactFiberContext.popContextProvider;\n    var popTopLevelContextObject$1 = ReactFiberContext.popTopLevelContextObject;\n    var IndeterminateComponent$3 = ReactTypeOfWork.IndeterminateComponent;\n    var FunctionalComponent$3 = ReactTypeOfWork.FunctionalComponent;\n    var ClassComponent$8 = ReactTypeOfWork.ClassComponent;\n    var HostRoot$8 = ReactTypeOfWork.HostRoot;\n    var HostComponent$8 = ReactTypeOfWork.HostComponent;\n    var HostText$6 = ReactTypeOfWork.HostText;\n    var HostPortal$6 = ReactTypeOfWork.HostPortal;\n    var CoroutineComponent$3 = ReactTypeOfWork.CoroutineComponent;\n    var CoroutineHandlerPhase$1 = ReactTypeOfWork.CoroutineHandlerPhase;\n    var YieldComponent$4 = ReactTypeOfWork.YieldComponent;\n    var Fragment$4 = ReactTypeOfWork.Fragment;\n    var Placement$4 = ReactTypeOfSideEffect.Placement;\n    var Ref$2 = ReactTypeOfSideEffect.Ref;\n    var Update$2 = ReactTypeOfSideEffect.Update;\n    var OffscreenPriority$2 = ReactPriorityLevel.OffscreenPriority;\n    {\n      var ReactDebugCurrentFiber$5 = ReactDebugCurrentFiber_1;\n    }\n\n    var ReactFiberCompleteWork = function ReactFiberCompleteWork(config, hostContext, hydrationContext) {\n      var createInstance = config.createInstance,\n          createTextInstance = config.createTextInstance,\n          appendInitialChild = config.appendInitialChild,\n          finalizeInitialChildren = config.finalizeInitialChildren,\n          prepareUpdate = config.prepareUpdate;\n      var getRootHostContainer = hostContext.getRootHostContainer,\n          popHostContext = hostContext.popHostContext,\n          getHostContext = hostContext.getHostContext,\n          popHostContainer = hostContext.popHostContainer;\n      var prepareToHydrateHostInstance = hydrationContext.prepareToHydrateHostInstance,\n          prepareToHydrateHostTextInstance = hydrationContext.prepareToHydrateHostTextInstance,\n          popHydrationState = hydrationContext.popHydrationState;\n\n      function markUpdate(workInProgress) {\n        // Tag the fiber with an update effect. This turns a Placement into\n        // an UpdateAndPlacement.\n        workInProgress.effectTag |= Update$2;\n      }\n\n      function markRef(workInProgress) {\n        workInProgress.effectTag |= Ref$2;\n      }\n\n      function appendAllYields(yields, workInProgress) {\n        var node = workInProgress.stateNode;\n\n        if (node) {\n          node['return'] = workInProgress;\n        }\n\n        while (node !== null) {\n          if (node.tag === HostComponent$8 || node.tag === HostText$6 || node.tag === HostPortal$6) {\n            invariant(false, 'A coroutine cannot have host component children.');\n          } else if (node.tag === YieldComponent$4) {\n            yields.push(node.type);\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function moveCoroutineToHandlerPhase(current, workInProgress) {\n        var coroutine = workInProgress.memoizedProps;\n        !coroutine ? invariant(false, 'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.') : void 0; // First step of the coroutine has completed. Now we need to do the second.\n        // TODO: It would be nice to have a multi stage coroutine represented by a\n        // single component, or at least tail call optimize nested ones. Currently\n        // that requires additional fields that we don't want to add to the fiber.\n        // So this requires nested handlers.\n        // Note: This doesn't mutate the alternate node. I don't think it needs to\n        // since this stage is reset for every pass.\n\n        workInProgress.tag = CoroutineHandlerPhase$1; // Build up the yields.\n        // TODO: Compare this to a generator or opaque helpers like Children.\n\n        var yields = [];\n        appendAllYields(yields, workInProgress);\n        var fn = coroutine.handler;\n        var props = coroutine.props;\n        var nextChildren = fn(props, yields);\n        var currentFirstChild = current !== null ? current.child : null; // Inherit the priority of the returnFiber.\n\n        var priority = workInProgress.pendingWorkPriority;\n        workInProgress.child = reconcileChildFibers$2(workInProgress, currentFirstChild, nextChildren, priority);\n        return workInProgress.child;\n      }\n\n      function appendAllChildren(parent, workInProgress) {\n        // We only have the top Fiber that was created but we need recurse down its\n        // children to find all the terminal nodes.\n        var node = workInProgress.child;\n\n        while (node !== null) {\n          if (node.tag === HostComponent$8 || node.tag === HostText$6) {\n            appendInitialChild(parent, node.stateNode);\n          } else if (node.tag === HostPortal$6) {// If we have a portal child, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node = node.child;\n            continue;\n          }\n\n          if (node === workInProgress) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === workInProgress) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node = node.sibling;\n        }\n      }\n\n      function completeWork(current, workInProgress, renderPriority) {\n        {\n          ReactDebugCurrentFiber$5.setCurrentFiber(workInProgress, null);\n        } // Get the latest props.\n\n        var newProps = workInProgress.pendingProps;\n\n        if (newProps === null) {\n          newProps = workInProgress.memoizedProps;\n        } else if (workInProgress.pendingWorkPriority !== OffscreenPriority$2 || renderPriority === OffscreenPriority$2) {\n          // Reset the pending props, unless this was a down-prioritization.\n          workInProgress.pendingProps = null;\n        }\n\n        switch (workInProgress.tag) {\n          case FunctionalComponent$3:\n            return null;\n\n          case ClassComponent$8:\n            {\n              // We are leaving this subtree, so pop context if any.\n              popContextProvider$2(workInProgress);\n              return null;\n            }\n\n          case HostRoot$8:\n            {\n              popHostContainer(workInProgress);\n              popTopLevelContextObject$1(workInProgress);\n              var fiberRoot = workInProgress.stateNode;\n\n              if (fiberRoot.pendingContext) {\n                fiberRoot.context = fiberRoot.pendingContext;\n                fiberRoot.pendingContext = null;\n              }\n\n              if (current === null || current.child === null) {\n                // If we hydrated, pop so that we can delete any remaining children\n                // that weren't hydrated.\n                popHydrationState(workInProgress); // This resets the hacky state to fix isMounted before committing.\n                // TODO: Delete this when we delete isMounted and findDOMNode.\n\n                workInProgress.effectTag &= ~Placement$4;\n              }\n\n              return null;\n            }\n\n          case HostComponent$8:\n            {\n              popHostContext(workInProgress);\n              var rootContainerInstance = getRootHostContainer();\n              var type = workInProgress.type;\n\n              if (current !== null && workInProgress.stateNode != null) {\n                // If we have an alternate, that means this is an update and we need to\n                // schedule a side-effect to do the updates.\n                var oldProps = current.memoizedProps; // If we get updated because one of our children updated, we don't\n                // have newProps so we'll have to reuse them.\n                // TODO: Split the update API as separate for the props vs. children.\n                // Even better would be if children weren't special cased at all tho.\n\n                var instance = workInProgress.stateNode;\n                var currentHostContext = getHostContext();\n                var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.\n\n                workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n                // is a new ref we mark this as an update.\n\n                if (updatePayload) {\n                  markUpdate(workInProgress);\n                }\n\n                if (current.ref !== workInProgress.ref) {\n                  markRef(workInProgress);\n                }\n              } else {\n                if (!newProps) {\n                  !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0; // This can happen when we abort work.\n\n                  return null;\n                }\n\n                var _currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n                // \"stack\" as the parent. Then append children as we go in beginWork\n                // or completeWork depending on we want to add then top->down or\n                // bottom->up. Top->down is faster in IE11.\n\n\n                var wasHydrated = popHydrationState(workInProgress);\n\n                if (wasHydrated) {\n                  // TOOD: Move this and createInstance step into the beginPhase\n                  // to consolidate.\n                  if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, _currentHostContext)) {\n                    // If changes to the hydrated node needs to be applied at the\n                    // commit-phase we mark this as such.\n                    markUpdate(workInProgress);\n                  }\n                } else {\n                  var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);\n\n                  appendAllChildren(_instance, workInProgress); // Certain renderers require commit-time effects for initial mount.\n                  // (eg DOM renderer supports auto-focus for certain elements).\n                  // Make sure such renderers get scheduled for later work.\n\n                  if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance)) {\n                    markUpdate(workInProgress);\n                  }\n\n                  workInProgress.stateNode = _instance;\n                }\n\n                if (workInProgress.ref !== null) {\n                  // If there is a ref on a host node we need to schedule a callback\n                  markRef(workInProgress);\n                }\n              }\n\n              return null;\n            }\n\n          case HostText$6:\n            {\n              var newText = newProps;\n\n              if (current && workInProgress.stateNode != null) {\n                var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n                // to schedule a side-effect to do the updates.\n\n                if (oldText !== newText) {\n                  markUpdate(workInProgress);\n                }\n              } else {\n                if (typeof newText !== 'string') {\n                  !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0; // This can happen when we abort work.\n\n                  return null;\n                }\n\n                var _rootContainerInstance = getRootHostContainer();\n\n                var _currentHostContext2 = getHostContext();\n\n                var _wasHydrated = popHydrationState(workInProgress);\n\n                if (_wasHydrated) {\n                  if (prepareToHydrateHostTextInstance(workInProgress)) {\n                    markUpdate(workInProgress);\n                  }\n                } else {\n                  workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext2, workInProgress);\n                }\n              }\n\n              return null;\n            }\n\n          case CoroutineComponent$3:\n            return moveCoroutineToHandlerPhase(current, workInProgress);\n\n          case CoroutineHandlerPhase$1:\n            // Reset the tag to now be a first phase coroutine.\n            workInProgress.tag = CoroutineComponent$3;\n            return null;\n\n          case YieldComponent$4:\n            // Does nothing.\n            return null;\n\n          case Fragment$4:\n            return null;\n\n          case HostPortal$6:\n            // TODO: Only mark this as an update if we have any pending callbacks.\n            markUpdate(workInProgress);\n            popHostContainer(workInProgress);\n            return null;\n          // Error cases\n\n          case IndeterminateComponent$3:\n            invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n          // eslint-disable-next-line no-fallthrough\n\n          default:\n            invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n\n      return {\n        completeWork: completeWork\n      };\n    };\n\n    {\n      var warning$26 = require$$0;\n    }\n    var onCommitFiberRoot = null;\n    var onCommitFiberUnmount = null;\n    var hasLoggedError = false;\n\n    function catchErrors(fn) {\n      return function (arg) {\n        try {\n          return fn(arg);\n        } catch (err) {\n          if (true && !hasLoggedError) {\n            hasLoggedError = true;\n            warning$26(false, 'React DevTools encountered an error: %s', err);\n          }\n        }\n      };\n    }\n\n    function injectInternals$1(internals) {\n      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n        // No DevTools\n        return false;\n      }\n\n      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n      if (!hook.supportsFiber) {\n        {\n          warning$26(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');\n        } // DevTools exists, even though it doesn't support Fiber.\n\n        return true;\n      }\n\n      try {\n        var rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\n\n        onCommitFiberRoot = catchErrors(function (root) {\n          return hook.onCommitFiberRoot(rendererID, root);\n        });\n        onCommitFiberUnmount = catchErrors(function (fiber) {\n          return hook.onCommitFiberUnmount(rendererID, fiber);\n        });\n      } catch (err) {\n        // Catch all errors because it is unsafe to throw during initialization.\n        {\n          warning$26(false, 'React DevTools encountered an error: %s.', err);\n        }\n      } // DevTools exists\n\n\n      return true;\n    }\n\n    function onCommitRoot$1(root) {\n      if (typeof onCommitFiberRoot === 'function') {\n        onCommitFiberRoot(root);\n      }\n    }\n\n    function onCommitUnmount$1(fiber) {\n      if (typeof onCommitFiberUnmount === 'function') {\n        onCommitFiberUnmount(fiber);\n      }\n    }\n\n    var injectInternals_1 = injectInternals$1;\n    var onCommitRoot_1 = onCommitRoot$1;\n    var onCommitUnmount_1 = onCommitUnmount$1;\n    var ReactFiberDevToolsHook = {\n      injectInternals: injectInternals_1,\n      onCommitRoot: onCommitRoot_1,\n      onCommitUnmount: onCommitUnmount_1\n    };\n    var ClassComponent$9 = ReactTypeOfWork.ClassComponent;\n    var HostRoot$9 = ReactTypeOfWork.HostRoot;\n    var HostComponent$9 = ReactTypeOfWork.HostComponent;\n    var HostText$7 = ReactTypeOfWork.HostText;\n    var HostPortal$7 = ReactTypeOfWork.HostPortal;\n    var CoroutineComponent$4 = ReactTypeOfWork.CoroutineComponent;\n    var commitCallbacks$1 = ReactFiberUpdateQueue.commitCallbacks;\n    var onCommitUnmount = ReactFiberDevToolsHook.onCommitUnmount;\n    var invokeGuardedCallback$2 = ReactErrorUtils_1.invokeGuardedCallback;\n    var hasCaughtError$1 = ReactErrorUtils_1.hasCaughtError;\n    var clearCaughtError$1 = ReactErrorUtils_1.clearCaughtError;\n    var Placement$5 = ReactTypeOfSideEffect.Placement;\n    var Update$3 = ReactTypeOfSideEffect.Update;\n    var Callback$1 = ReactTypeOfSideEffect.Callback;\n    var ContentReset$2 = ReactTypeOfSideEffect.ContentReset;\n    {\n      var _require5$1 = ReactDebugFiberPerf_1,\n          startPhaseTimer$2 = _require5$1.startPhaseTimer,\n          stopPhaseTimer$2 = _require5$1.stopPhaseTimer;\n    }\n\n    var ReactFiberCommitWork = function ReactFiberCommitWork(config, captureError) {\n      var commitMount = config.commitMount,\n          commitUpdate = config.commitUpdate,\n          resetTextContent = config.resetTextContent,\n          commitTextUpdate = config.commitTextUpdate,\n          appendChild = config.appendChild,\n          appendChildToContainer = config.appendChildToContainer,\n          insertBefore = config.insertBefore,\n          insertInContainerBefore = config.insertInContainerBefore,\n          removeChild = config.removeChild,\n          removeChildFromContainer = config.removeChildFromContainer,\n          getPublicInstance = config.getPublicInstance;\n      {\n        var callComponentWillUnmountWithTimerInDev = function callComponentWillUnmountWithTimerInDev(current, instance) {\n          startPhaseTimer$2(current, 'componentWillUnmount');\n          instance.props = current.memoizedProps;\n          instance.state = current.memoizedState;\n          instance.componentWillUnmount();\n          stopPhaseTimer$2();\n        };\n      } // Capture errors so they don't interrupt unmounting.\n\n      function safelyCallComponentWillUnmount(current, instance) {\n        {\n          invokeGuardedCallback$2(null, callComponentWillUnmountWithTimerInDev, null, current, instance);\n\n          if (hasCaughtError$1()) {\n            var unmountError = clearCaughtError$1();\n            captureError(current, unmountError);\n          }\n        }\n      }\n\n      function safelyDetachRef(current) {\n        var ref = current.ref;\n\n        if (ref !== null) {\n          {\n            invokeGuardedCallback$2(null, ref, null, null);\n\n            if (hasCaughtError$1()) {\n              var refError = clearCaughtError$1();\n              captureError(current, refError);\n            }\n          }\n        }\n      }\n\n      function getHostParentFiber(fiber) {\n        var parent = fiber['return'];\n\n        while (parent !== null) {\n          if (isHostParent(parent)) {\n            return parent;\n          }\n\n          parent = parent['return'];\n        }\n\n        invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n      }\n\n      function isHostParent(fiber) {\n        return fiber.tag === HostComponent$9 || fiber.tag === HostRoot$9 || fiber.tag === HostPortal$7;\n      }\n\n      function getHostSibling(fiber) {\n        // We're going to search forward into the tree until we find a sibling host\n        // node. Unfortunately, if multiple insertions are done in a row we have to\n        // search past them. This leads to exponential search for the next sibling.\n        var node = fiber;\n\n        siblings: while (true) {\n          // If we didn't find anything, let's try the next sibling.\n          while (node.sibling === null) {\n            if (node['return'] === null || isHostParent(node['return'])) {\n              // If we pop out of the root or hit the parent the fiber we are the\n              // last sibling.\n              return null;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n\n          while (node.tag !== HostComponent$9 && node.tag !== HostText$7) {\n            // If it is not host node and, we might have a host node inside it.\n            // Try to search down until we find one.\n            if (node.effectTag & Placement$5) {\n              // If we don't have a child, try the siblings instead.\n              continue siblings;\n            } // If we don't have a child, try the siblings instead.\n            // We also skip portals because they are not part of this host tree.\n\n\n            if (node.child === null || node.tag === HostPortal$7) {\n              continue siblings;\n            } else {\n              node.child['return'] = node;\n              node = node.child;\n            }\n          } // Check if this host node is stable or about to be placed.\n\n\n          if (!(node.effectTag & Placement$5)) {\n            // Found it!\n            return node.stateNode;\n          }\n        }\n      }\n\n      function commitPlacement(finishedWork) {\n        // Recursively insert all host nodes into the parent.\n        var parentFiber = getHostParentFiber(finishedWork);\n        var parent = void 0;\n        var isContainer = void 0;\n\n        switch (parentFiber.tag) {\n          case HostComponent$9:\n            parent = parentFiber.stateNode;\n            isContainer = false;\n            break;\n\n          case HostRoot$9:\n            parent = parentFiber.stateNode.containerInfo;\n            isContainer = true;\n            break;\n\n          case HostPortal$7:\n            parent = parentFiber.stateNode.containerInfo;\n            isContainer = true;\n            break;\n\n          default:\n            invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n        }\n\n        if (parentFiber.effectTag & ContentReset$2) {\n          // Reset the text content of the parent before doing any insertions\n          resetTextContent(parent); // Clear ContentReset from the effect tag\n\n          parentFiber.effectTag &= ~ContentReset$2;\n        }\n\n        var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need recurse down its\n        // children to find all the terminal nodes.\n\n        var node = finishedWork;\n\n        while (true) {\n          if (node.tag === HostComponent$9 || node.tag === HostText$7) {\n            if (before) {\n              if (isContainer) {\n                insertInContainerBefore(parent, node.stateNode, before);\n              } else {\n                insertBefore(parent, node.stateNode, before);\n              }\n            } else {\n              if (isContainer) {\n                appendChildToContainer(parent, node.stateNode);\n              } else {\n                appendChild(parent, node.stateNode);\n              }\n            }\n          } else if (node.tag === HostPortal$7) {// If the insertion itself is a portal, then we don't want to traverse\n            // down its children. Instead, we'll get insertions from each child in\n            // the portal directly.\n          } else if (node.child !== null) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          if (node === finishedWork) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === finishedWork) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function commitNestedUnmounts(root) {\n        // While we're inside a removed host node we don't want to call\n        // removeChild on the inner nodes because they're removed by the top\n        // call anyway. We also want to call componentWillUnmount on all\n        // composites before this host node is removed from the tree. Therefore\n        var node = root;\n\n        while (true) {\n          commitUnmount(node); // Visit children because they may contain more composite or host nodes.\n          // Skip portals because commitUnmount() currently visits them recursively.\n\n          if (node.child !== null && node.tag !== HostPortal$7) {\n            node.child['return'] = node;\n            node = node.child;\n            continue;\n          }\n\n          if (node === root) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === root) {\n              return;\n            }\n\n            node = node['return'];\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function unmountHostComponents(current) {\n        // We only have the top Fiber that was inserted but we need recurse down its\n        var node = current; // Each iteration, currentParent is populated with node's host parent if not\n        // currentParentIsValid.\n\n        var currentParentIsValid = false;\n        var currentParent = void 0;\n        var currentParentIsContainer = void 0;\n\n        while (true) {\n          if (!currentParentIsValid) {\n            var parent = node['return'];\n\n            findParent: while (true) {\n              !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n              switch (parent.tag) {\n                case HostComponent$9:\n                  currentParent = parent.stateNode;\n                  currentParentIsContainer = false;\n                  break findParent;\n\n                case HostRoot$9:\n                  currentParent = parent.stateNode.containerInfo;\n                  currentParentIsContainer = true;\n                  break findParent;\n\n                case HostPortal$7:\n                  currentParent = parent.stateNode.containerInfo;\n                  currentParentIsContainer = true;\n                  break findParent;\n              }\n\n              parent = parent['return'];\n            }\n\n            currentParentIsValid = true;\n          }\n\n          if (node.tag === HostComponent$9 || node.tag === HostText$7) {\n            commitNestedUnmounts(node); // After all the children have unmounted, it is now safe to remove the\n            // node from the tree.\n\n            if (currentParentIsContainer) {\n              removeChildFromContainer(currentParent, node.stateNode);\n            } else {\n              removeChild(currentParent, node.stateNode);\n            } // Don't visit children because we already visited them.\n\n          } else if (node.tag === HostPortal$7) {\n            // When we go into a portal, it becomes the parent to remove from.\n            // We will reassign it back when we pop the portal on the way up.\n            currentParent = node.stateNode.containerInfo; // Visit children because portals might contain host components.\n\n            if (node.child !== null) {\n              node.child['return'] = node;\n              node = node.child;\n              continue;\n            }\n          } else {\n            commitUnmount(node); // Visit children because we may find more host components below.\n\n            if (node.child !== null) {\n              node.child['return'] = node;\n              node = node.child;\n              continue;\n            }\n          }\n\n          if (node === current) {\n            return;\n          }\n\n          while (node.sibling === null) {\n            if (node['return'] === null || node['return'] === current) {\n              return;\n            }\n\n            node = node['return'];\n\n            if (node.tag === HostPortal$7) {\n              // When we go out of the portal, we need to restore the parent.\n              // Since we don't keep a stack of them, we will search for it.\n              currentParentIsValid = false;\n            }\n          }\n\n          node.sibling['return'] = node['return'];\n          node = node.sibling;\n        }\n      }\n\n      function commitDeletion(current) {\n        // Recursively delete all host nodes from the parent.\n        // Detach refs and call componentWillUnmount() on the whole subtree.\n        unmountHostComponents(current); // Cut off the return pointers to disconnect it from the tree. Ideally, we\n        // should clear the child pointer of the parent alternate to let this\n        // get GC:ed but we don't know which for sure which parent is the current\n        // one so we'll settle for GC:ing the subtree of this child. This child\n        // itself will be GC:ed when the parent updates the next time.\n\n        current['return'] = null;\n        current.child = null;\n\n        if (current.alternate) {\n          current.alternate.child = null;\n          current.alternate['return'] = null;\n        }\n      } // User-originating errors (lifecycles and refs) should not interrupt\n      // deletion, so don't let them throw. Host-originating errors should\n      // interrupt deletion, so it's okay\n\n\n      function commitUnmount(current) {\n        if (typeof onCommitUnmount === 'function') {\n          onCommitUnmount(current);\n        }\n\n        switch (current.tag) {\n          case ClassComponent$9:\n            {\n              safelyDetachRef(current);\n              var instance = current.stateNode;\n\n              if (typeof instance.componentWillUnmount === 'function') {\n                safelyCallComponentWillUnmount(current, instance);\n              }\n\n              return;\n            }\n\n          case HostComponent$9:\n            {\n              safelyDetachRef(current);\n              return;\n            }\n\n          case CoroutineComponent$4:\n            {\n              commitNestedUnmounts(current.stateNode);\n              return;\n            }\n\n          case HostPortal$7:\n            {\n              // TODO: this is recursive.\n              // We are also not using this parent because\n              // the portal will get pushed immediately.\n              unmountHostComponents(current);\n              return;\n            }\n        }\n      }\n\n      function commitWork(current, finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent$9:\n            {\n              return;\n            }\n\n          case HostComponent$9:\n            {\n              var instance = finishedWork.stateNode;\n\n              if (instance != null) {\n                // Commit the work prepared earlier.\n                var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                // as the newProps. The updatePayload will contain the real change in\n                // this case.\n\n                var oldProps = current !== null ? current.memoizedProps : newProps;\n                var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n\n                var updatePayload = finishedWork.updateQueue;\n                finishedWork.updateQueue = null;\n\n                if (updatePayload !== null) {\n                  commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n                }\n              }\n\n              return;\n            }\n\n          case HostText$7:\n            {\n              !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n              var textInstance = finishedWork.stateNode;\n              var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n              // as the newProps. The updatePayload will contain the real change in\n              // this case.\n\n              var oldText = current !== null ? current.memoizedProps : newText;\n              commitTextUpdate(textInstance, oldText, newText);\n              return;\n            }\n\n          case HostRoot$9:\n            {\n              return;\n            }\n\n          case HostPortal$7:\n            {\n              return;\n            }\n\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      }\n\n      function commitLifeCycles(current, finishedWork) {\n        switch (finishedWork.tag) {\n          case ClassComponent$9:\n            {\n              var instance = finishedWork.stateNode;\n\n              if (finishedWork.effectTag & Update$3) {\n                if (current === null) {\n                  {\n                    startPhaseTimer$2(finishedWork, 'componentDidMount');\n                  }\n                  instance.props = finishedWork.memoizedProps;\n                  instance.state = finishedWork.memoizedState;\n                  instance.componentDidMount();\n                  {\n                    stopPhaseTimer$2();\n                  }\n                } else {\n                  var prevProps = current.memoizedProps;\n                  var prevState = current.memoizedState;\n                  {\n                    startPhaseTimer$2(finishedWork, 'componentDidUpdate');\n                  }\n                  instance.props = finishedWork.memoizedProps;\n                  instance.state = finishedWork.memoizedState;\n                  instance.componentDidUpdate(prevProps, prevState);\n                  {\n                    stopPhaseTimer$2();\n                  }\n                }\n              }\n\n              if (finishedWork.effectTag & Callback$1 && finishedWork.updateQueue !== null) {\n                commitCallbacks$1(finishedWork, finishedWork.updateQueue, instance);\n              }\n\n              return;\n            }\n\n          case HostRoot$9:\n            {\n              var updateQueue = finishedWork.updateQueue;\n\n              if (updateQueue !== null) {\n                var _instance = finishedWork.child && finishedWork.child.stateNode;\n\n                commitCallbacks$1(finishedWork, updateQueue, _instance);\n              }\n\n              return;\n            }\n\n          case HostComponent$9:\n            {\n              var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n              // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n              // These effects should only be committed when components are first mounted,\n              // aka when there is no current/alternate.\n\n              if (current === null && finishedWork.effectTag & Update$3) {\n                var type = finishedWork.type;\n                var props = finishedWork.memoizedProps;\n                commitMount(_instance2, type, props, finishedWork);\n              }\n\n              return;\n            }\n\n          case HostText$7:\n            {\n              // We have no life-cycles associated with text.\n              return;\n            }\n\n          case HostPortal$7:\n            {\n              // We have no life-cycles associated with portals.\n              return;\n            }\n\n          default:\n            {\n              invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n            }\n        }\n      }\n\n      function commitAttachRef(finishedWork) {\n        var ref = finishedWork.ref;\n\n        if (ref !== null) {\n          var instance = finishedWork.stateNode;\n\n          switch (finishedWork.tag) {\n            case HostComponent$9:\n              ref(getPublicInstance(instance));\n              break;\n\n            default:\n              ref(instance);\n          }\n        }\n      }\n\n      function commitDetachRef(current) {\n        var currentRef = current.ref;\n\n        if (currentRef !== null) {\n          currentRef(null);\n        }\n      }\n\n      return {\n        commitPlacement: commitPlacement,\n        commitDeletion: commitDeletion,\n        commitWork: commitWork,\n        commitLifeCycles: commitLifeCycles,\n        commitAttachRef: commitAttachRef,\n        commitDetachRef: commitDetachRef\n      };\n    };\n\n    var createCursor$2 = ReactFiberStack.createCursor;\n    var pop$2 = ReactFiberStack.pop;\n    var push$2 = ReactFiberStack.push;\n    var NO_CONTEXT = {};\n\n    var ReactFiberHostContext = function ReactFiberHostContext(config) {\n      var getChildHostContext = config.getChildHostContext,\n          getRootHostContext = config.getRootHostContext;\n      var contextStackCursor = createCursor$2(NO_CONTEXT);\n      var contextFiberStackCursor = createCursor$2(NO_CONTEXT);\n      var rootInstanceStackCursor = createCursor$2(NO_CONTEXT);\n\n      function requiredContext(c) {\n        !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        return c;\n      }\n\n      function getRootHostContainer() {\n        var rootInstance = requiredContext(rootInstanceStackCursor.current);\n        return rootInstance;\n      }\n\n      function pushHostContainer(fiber, nextRootInstance) {\n        // Push current root instance onto the stack;\n        // This allows us to reset root when portals are popped.\n        push$2(rootInstanceStackCursor, nextRootInstance, fiber);\n        var nextRootContext = getRootHostContext(nextRootInstance); // Track the context and the Fiber that provided it.\n        // This enables us to pop only Fibers that provide unique contexts.\n\n        push$2(contextFiberStackCursor, fiber, fiber);\n        push$2(contextStackCursor, nextRootContext, fiber);\n      }\n\n      function popHostContainer(fiber) {\n        pop$2(contextStackCursor, fiber);\n        pop$2(contextFiberStackCursor, fiber);\n        pop$2(rootInstanceStackCursor, fiber);\n      }\n\n      function getHostContext() {\n        var context = requiredContext(contextStackCursor.current);\n        return context;\n      }\n\n      function pushHostContext(fiber) {\n        var rootInstance = requiredContext(rootInstanceStackCursor.current);\n        var context = requiredContext(contextStackCursor.current);\n        var nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.\n\n        if (context === nextContext) {\n          return;\n        } // Track the context and the Fiber that provided it.\n        // This enables us to pop only Fibers that provide unique contexts.\n\n\n        push$2(contextFiberStackCursor, fiber, fiber);\n        push$2(contextStackCursor, nextContext, fiber);\n      }\n\n      function popHostContext(fiber) {\n        // Do not pop unless this Fiber provided the current context.\n        // pushHostContext() only pushes Fibers that provide unique contexts.\n        if (contextFiberStackCursor.current !== fiber) {\n          return;\n        }\n\n        pop$2(contextStackCursor, fiber);\n        pop$2(contextFiberStackCursor, fiber);\n      }\n\n      function resetHostContainer() {\n        contextStackCursor.current = NO_CONTEXT;\n        rootInstanceStackCursor.current = NO_CONTEXT;\n      }\n\n      return {\n        getHostContext: getHostContext,\n        getRootHostContainer: getRootHostContainer,\n        popHostContainer: popHostContainer,\n        popHostContext: popHostContext,\n        pushHostContainer: pushHostContainer,\n        pushHostContext: pushHostContext,\n        resetHostContainer: resetHostContainer\n      };\n    };\n\n    var HostComponent$10 = ReactTypeOfWork.HostComponent;\n    var HostText$8 = ReactTypeOfWork.HostText;\n    var HostRoot$10 = ReactTypeOfWork.HostRoot;\n    var Deletion$2 = ReactTypeOfSideEffect.Deletion;\n    var Placement$6 = ReactTypeOfSideEffect.Placement;\n    var createFiberFromHostInstanceForDeletion$1 = ReactFiber.createFiberFromHostInstanceForDeletion;\n\n    var ReactFiberHydrationContext = function ReactFiberHydrationContext(config) {\n      var shouldSetTextContent = config.shouldSetTextContent,\n          canHydrateInstance = config.canHydrateInstance,\n          canHydrateTextInstance = config.canHydrateTextInstance,\n          getNextHydratableSibling = config.getNextHydratableSibling,\n          getFirstHydratableChild = config.getFirstHydratableChild,\n          hydrateInstance = config.hydrateInstance,\n          hydrateTextInstance = config.hydrateTextInstance,\n          didNotHydrateInstance = config.didNotHydrateInstance,\n          didNotFindHydratableInstance = config.didNotFindHydratableInstance,\n          didNotFindHydratableTextInstance = config.didNotFindHydratableTextInstance; // If this doesn't have hydration mode.\n\n      if (!(canHydrateInstance && canHydrateTextInstance && getNextHydratableSibling && getFirstHydratableChild && hydrateInstance && hydrateTextInstance && didNotHydrateInstance && didNotFindHydratableInstance && didNotFindHydratableTextInstance)) {\n        return {\n          enterHydrationState: function enterHydrationState() {\n            return false;\n          },\n          resetHydrationState: function resetHydrationState() {},\n          tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance() {},\n          prepareToHydrateHostInstance: function prepareToHydrateHostInstance() {\n            invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n          },\n          prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance() {\n            invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n          },\n          popHydrationState: function popHydrationState(fiber) {\n            return false;\n          }\n        };\n      } // The deepest Fiber on the stack involved in a hydration context.\n      // This may have been an insertion or a hydration.\n\n\n      var hydrationParentFiber = null;\n      var nextHydratableInstance = null;\n      var isHydrating = false;\n\n      function enterHydrationState(fiber) {\n        var parentInstance = fiber.stateNode.containerInfo;\n        nextHydratableInstance = getFirstHydratableChild(parentInstance);\n        hydrationParentFiber = fiber;\n        isHydrating = true;\n        return true;\n      }\n\n      function deleteHydratableInstance(returnFiber, instance) {\n        {\n          switch (returnFiber.tag) {\n            case HostRoot$10:\n              didNotHydrateInstance(returnFiber.stateNode.containerInfo, instance);\n              break;\n\n            case HostComponent$10:\n              didNotHydrateInstance(returnFiber.stateNode, instance);\n              break;\n          }\n        }\n        var childToDelete = createFiberFromHostInstanceForDeletion$1();\n        childToDelete.stateNode = instance;\n        childToDelete['return'] = returnFiber;\n        childToDelete.effectTag = Deletion$2; // This might seem like it belongs on progressedFirstDeletion. However,\n        // these children are not part of the reconciliation list of children.\n        // Even if we abort and rereconcile the children, that will try to hydrate\n        // again and the nodes are still in the host tree so these will be\n        // recreated.\n\n        if (returnFiber.lastEffect !== null) {\n          returnFiber.lastEffect.nextEffect = childToDelete;\n          returnFiber.lastEffect = childToDelete;\n        } else {\n          returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n        }\n      }\n\n      function insertNonHydratedInstance(returnFiber, fiber) {\n        fiber.effectTag |= Placement$6;\n        {\n          var parentInstance;\n\n          switch (returnFiber.tag) {\n            // TODO: Currently we don't warn for insertions into the root because\n            // we always insert into the root in the non-hydrating case. We just\n            // delete the existing content. Reenable this once we have a better\n            // strategy for determining if we're hydrating or not.\n            // case HostRoot:\n            //   parentInstance = returnFiber.stateNode.containerInfo;\n            //   break;\n            case HostComponent$10:\n              parentInstance = returnFiber.stateNode;\n              break;\n\n            default:\n              return;\n          }\n\n          switch (fiber.tag) {\n            case HostComponent$10:\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              didNotFindHydratableInstance(parentInstance, type, props);\n              break;\n\n            case HostText$8:\n              var text = fiber.pendingProps;\n              didNotFindHydratableTextInstance(parentInstance, text);\n              break;\n          }\n        }\n      }\n\n      function canHydrate(fiber, nextInstance) {\n        switch (fiber.tag) {\n          case HostComponent$10:\n            {\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              return canHydrateInstance(nextInstance, type, props);\n            }\n\n          case HostText$8:\n            {\n              var text = fiber.pendingProps;\n              return canHydrateTextInstance(nextInstance, text);\n            }\n\n          default:\n            return false;\n        }\n      }\n\n      function tryToClaimNextHydratableInstance(fiber) {\n        if (!isHydrating) {\n          return;\n        }\n\n        var nextInstance = nextHydratableInstance;\n\n        if (!nextInstance) {\n          // Nothing to hydrate. Make it an insertion.\n          insertNonHydratedInstance(hydrationParentFiber, fiber);\n          isHydrating = false;\n          hydrationParentFiber = fiber;\n          return;\n        }\n\n        if (!canHydrate(fiber, nextInstance)) {\n          // If we can't hydrate this instance let's try the next one.\n          // We use this as a heuristic. It's based on intuition and not data so it\n          // might be flawed or unnecessary.\n          nextInstance = getNextHydratableSibling(nextInstance);\n\n          if (!nextInstance || !canHydrate(fiber, nextInstance)) {\n            // Nothing to hydrate. Make it an insertion.\n            insertNonHydratedInstance(hydrationParentFiber, fiber);\n            isHydrating = false;\n            hydrationParentFiber = fiber;\n            return;\n          } // We matched the next one, we'll now assume that the first one was\n          // superfluous and we'll delete it. Since we can't eagerly delete it\n          // we'll have to schedule a deletion. To do that, this node needs a dummy\n          // fiber associated with it.\n\n\n          deleteHydratableInstance(hydrationParentFiber, nextHydratableInstance);\n        }\n\n        fiber.stateNode = nextInstance;\n        hydrationParentFiber = fiber;\n        nextHydratableInstance = getFirstHydratableChild(nextInstance);\n      }\n\n      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n        var instance = fiber.stateNode;\n        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber); // TODO: Type this specific to this type of component.\n\n        fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n        // is a new ref we mark this as an update.\n\n        if (updatePayload !== null) {\n          return true;\n        }\n\n        return false;\n      }\n\n      function prepareToHydrateHostTextInstance(fiber) {\n        var textInstance = fiber.stateNode;\n        var shouldUpdate = hydrateTextInstance(textInstance, fiber.memoizedProps, fiber);\n        return shouldUpdate;\n      }\n\n      function popToNextHostParent(fiber) {\n        var parent = fiber['return'];\n\n        while (parent !== null && parent.tag !== HostComponent$10 && parent.tag !== HostRoot$10) {\n          parent = parent['return'];\n        }\n\n        hydrationParentFiber = parent;\n      }\n\n      function popHydrationState(fiber) {\n        if (fiber !== hydrationParentFiber) {\n          // We're deeper than the current hydration context, inside an inserted\n          // tree.\n          return false;\n        }\n\n        if (!isHydrating) {\n          // If we're not currently hydrating but we're in a hydration context, then\n          // we were an insertion and now need to pop up reenter hydration of our\n          // siblings.\n          popToNextHostParent(fiber);\n          isHydrating = true;\n          return false;\n        }\n\n        var type = fiber.type; // If we have any remaining hydratable nodes, we need to delete them now.\n        // We only do this deeper than head and body since they tend to have random\n        // other nodes in them. We also ignore components with pure text content in\n        // side of them.\n        // TODO: Better heuristic.\n\n        if (fiber.tag !== HostComponent$10 || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n          var nextInstance = nextHydratableInstance;\n\n          while (nextInstance) {\n            deleteHydratableInstance(fiber, nextInstance);\n            nextInstance = getNextHydratableSibling(nextInstance);\n          }\n        }\n\n        popToNextHostParent(fiber);\n        nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n        return true;\n      }\n\n      function resetHydrationState() {\n        hydrationParentFiber = null;\n        nextHydratableInstance = null;\n        isHydrating = false;\n      }\n\n      return {\n        enterHydrationState: enterHydrationState,\n        resetHydrationState: resetHydrationState,\n        tryToClaimNextHydratableInstance: tryToClaimNextHydratableInstance,\n        prepareToHydrateHostInstance: prepareToHydrateHostInstance,\n        prepareToHydrateHostTextInstance: prepareToHydrateHostTextInstance,\n        popHydrationState: popHydrationState\n      };\n    };\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule ReactFiberInstrumentation\n     * \n     */\n    // This lets us hook into Fiber to debug what it's doing.\n    // See https://github.com/facebook/react/pull/8033.\n    // This is not part of the public API, not even for React DevTools.\n    // You may only inject a debugTool if you work on React Fiber itself.\n\n\n    var ReactFiberInstrumentation$2 = {\n      debugTool: null\n    };\n    var ReactFiberInstrumentation_1 = ReactFiberInstrumentation$2;\n    var popContextProvider$1 = ReactFiberContext.popContextProvider;\n    var reset$1 = ReactFiberStack.reset;\n    var getStackAddendumByWorkInProgressFiber$2 = ReactFiberComponentTreeHook.getStackAddendumByWorkInProgressFiber;\n    var logCapturedError = ReactFiberErrorLogger.logCapturedError;\n    var invokeGuardedCallback$1 = ReactErrorUtils_1.invokeGuardedCallback;\n    var hasCaughtError = ReactErrorUtils_1.hasCaughtError;\n    var clearCaughtError = ReactErrorUtils_1.clearCaughtError;\n    var ReactCurrentOwner$1 = ReactGlobalSharedState_1.ReactCurrentOwner;\n    var createWorkInProgress$1 = ReactFiber.createWorkInProgress;\n    var largerPriority$1 = ReactFiber.largerPriority;\n    var onCommitRoot = ReactFiberDevToolsHook.onCommitRoot;\n    var NoWork$2 = ReactPriorityLevel.NoWork;\n    var SynchronousPriority$1 = ReactPriorityLevel.SynchronousPriority;\n    var TaskPriority$1 = ReactPriorityLevel.TaskPriority;\n    var HighPriority = ReactPriorityLevel.HighPriority;\n    var LowPriority = ReactPriorityLevel.LowPriority;\n    var OffscreenPriority = ReactPriorityLevel.OffscreenPriority;\n    var AsyncUpdates = ReactTypeOfInternalContext.AsyncUpdates;\n    var PerformedWork = ReactTypeOfSideEffect.PerformedWork;\n    var Placement$1 = ReactTypeOfSideEffect.Placement;\n    var Update = ReactTypeOfSideEffect.Update;\n    var PlacementAndUpdate = ReactTypeOfSideEffect.PlacementAndUpdate;\n    var Deletion = ReactTypeOfSideEffect.Deletion;\n    var ContentReset = ReactTypeOfSideEffect.ContentReset;\n    var Callback = ReactTypeOfSideEffect.Callback;\n    var Err = ReactTypeOfSideEffect.Err;\n    var Ref = ReactTypeOfSideEffect.Ref;\n    var HostRoot$6 = ReactTypeOfWork.HostRoot;\n    var HostComponent$6 = ReactTypeOfWork.HostComponent;\n    var HostPortal$3 = ReactTypeOfWork.HostPortal;\n    var ClassComponent$5 = ReactTypeOfWork.ClassComponent;\n    var getUpdatePriority$1 = ReactFiberUpdateQueue.getUpdatePriority;\n    var _require14 = ReactFiberContext;\n    var resetContext$1 = _require14.resetContext;\n    {\n      var warning$22 = require$$0;\n      var ReactFiberInstrumentation$1 = ReactFiberInstrumentation_1;\n      var ReactDebugCurrentFiber$3 = ReactDebugCurrentFiber_1;\n      var _require15 = ReactDebugFiberPerf_1,\n          recordEffect = _require15.recordEffect,\n          recordScheduleUpdate = _require15.recordScheduleUpdate,\n          startWorkTimer = _require15.startWorkTimer,\n          stopWorkTimer = _require15.stopWorkTimer,\n          stopFailedWorkTimer = _require15.stopFailedWorkTimer,\n          startWorkLoopTimer = _require15.startWorkLoopTimer,\n          stopWorkLoopTimer = _require15.stopWorkLoopTimer,\n          startCommitTimer = _require15.startCommitTimer,\n          stopCommitTimer = _require15.stopCommitTimer,\n          startCommitHostEffectsTimer = _require15.startCommitHostEffectsTimer,\n          stopCommitHostEffectsTimer = _require15.stopCommitHostEffectsTimer,\n          startCommitLifeCyclesTimer = _require15.startCommitLifeCyclesTimer,\n          stopCommitLifeCyclesTimer = _require15.stopCommitLifeCyclesTimer;\n\n      var warnAboutUpdateOnUnmounted = function warnAboutUpdateOnUnmounted(instance) {\n        var ctor = instance.constructor;\n        warning$22(false, 'Can only update a mounted or mounting component. This usually means ' + 'you called setState, replaceState, or forceUpdate on an unmounted ' + 'component. This is a no-op.\\n\\nPlease check the code for the ' + '%s component.', ctor && (ctor.displayName || ctor.name) || 'ReactClass');\n      };\n\n      var warnAboutInvalidUpdates = function warnAboutInvalidUpdates(instance) {\n        switch (ReactDebugCurrentFiber$3.phase) {\n          case 'getChildContext':\n            warning$22(false, 'setState(...): Cannot call setState() inside getChildContext()');\n            break;\n\n          case 'render':\n            warning$22(false, 'Cannot update during an existing state transition (such as within ' + \"`render` or another component's constructor). Render methods should \" + 'be a pure function of props and state; constructor side-effects are ' + 'an anti-pattern, but can be moved to `componentWillMount`.');\n            break;\n        }\n      };\n    }\n    var timeHeuristicForUnitOfWork = 1;\n\n    var ReactFiberScheduler = function ReactFiberScheduler(config) {\n      var hostContext = ReactFiberHostContext(config);\n      var hydrationContext = ReactFiberHydrationContext(config);\n      var popHostContainer = hostContext.popHostContainer,\n          popHostContext = hostContext.popHostContext,\n          resetHostContainer = hostContext.resetHostContainer;\n\n      var _ReactFiberBeginWork = ReactFiberBeginWork(config, hostContext, hydrationContext, scheduleUpdate, getPriorityContext),\n          beginWork = _ReactFiberBeginWork.beginWork,\n          beginFailedWork = _ReactFiberBeginWork.beginFailedWork;\n\n      var _ReactFiberCompleteWo = ReactFiberCompleteWork(config, hostContext, hydrationContext),\n          completeWork = _ReactFiberCompleteWo.completeWork;\n\n      var _ReactFiberCommitWork = ReactFiberCommitWork(config, captureError),\n          commitPlacement = _ReactFiberCommitWork.commitPlacement,\n          commitDeletion = _ReactFiberCommitWork.commitDeletion,\n          commitWork = _ReactFiberCommitWork.commitWork,\n          commitLifeCycles = _ReactFiberCommitWork.commitLifeCycles,\n          commitAttachRef = _ReactFiberCommitWork.commitAttachRef,\n          commitDetachRef = _ReactFiberCommitWork.commitDetachRef;\n\n      var scheduleDeferredCallback = config.scheduleDeferredCallback,\n          useSyncScheduling = config.useSyncScheduling,\n          prepareForCommit = config.prepareForCommit,\n          resetAfterCommit = config.resetAfterCommit; // The priority level to use when scheduling an update. We use NoWork to\n      // represent the default priority.\n      // TODO: Should we change this to an array instead of using the call stack?\n      // Might be less confusing.\n\n      var priorityContext = NoWork$2; // Keeps track of whether we're currently in a work loop.\n\n      var isPerformingWork = false; // Keeps track of whether the current deadline has expired.\n\n      var deadlineHasExpired = false; // Keeps track of whether we should should batch sync updates.\n\n      var isBatchingUpdates = false; // This is needed for the weird case where the initial mount is synchronous\n      // even inside batchedUpdates :(\n\n      var isUnbatchingUpdates = false; // The next work in progress fiber that we're currently working on.\n\n      var nextUnitOfWork = null;\n      var nextPriorityLevel = NoWork$2; // The next fiber with an effect that we're currently committing.\n\n      var nextEffect = null;\n      var pendingCommit = null; // Linked list of roots with scheduled work on them.\n\n      var nextScheduledRoot = null;\n      var lastScheduledRoot = null; // Keep track of which host environment callbacks are scheduled.\n\n      var isCallbackScheduled = false; // Keep track of which fibers have captured an error that need to be handled.\n      // Work is removed from this collection after componentDidCatch is called.\n\n      var capturedErrors = null; // Keep track of which fibers have failed during the current batch of work.\n      // This is a different set than capturedErrors, because it is not reset until\n      // the end of the batch. This is needed to propagate errors correctly if a\n      // subtree fails more than once.\n\n      var failedBoundaries = null; // Error boundaries that captured an error during the current commit.\n\n      var commitPhaseBoundaries = null;\n      var firstUncaughtError = null;\n      var didFatal = false;\n      var isCommitting = false;\n      var isUnmounting = false; // Use these to prevent an infinite loop of nested updates\n\n      var NESTED_UPDATE_LIMIT = 1000;\n      var nestedUpdateCount = 0;\n      var nextRenderedTree = null;\n\n      function resetContextStack() {\n        // Reset the stack\n        reset$1(); // Reset the cursors\n\n        resetContext$1();\n        resetHostContainer();\n      } // resetNextUnitOfWork mutates the current priority context. It is reset after\n      // after the workLoop exits, so never call resetNextUnitOfWork from outside\n      // the work loop.\n\n\n      function resetNextUnitOfWork() {\n        // Clear out roots with no more work on them, or if they have uncaught errors\n        while (nextScheduledRoot !== null && nextScheduledRoot.current.pendingWorkPriority === NoWork$2) {\n          // Unschedule this root.\n          nextScheduledRoot.isScheduled = false; // Read the next pointer now.\n          // We need to clear it in case this root gets scheduled again later.\n\n          var next = nextScheduledRoot.nextScheduledRoot;\n          nextScheduledRoot.nextScheduledRoot = null; // Exit if we cleared all the roots and there's no work to do.\n\n          if (nextScheduledRoot === lastScheduledRoot) {\n            nextScheduledRoot = null;\n            lastScheduledRoot = null;\n            nextPriorityLevel = NoWork$2;\n            return null;\n          } // Continue with the next root.\n          // If there's no work on it, it will get unscheduled too.\n\n\n          nextScheduledRoot = next;\n        }\n\n        var root = nextScheduledRoot;\n        var highestPriorityRoot = null;\n        var highestPriorityLevel = NoWork$2;\n\n        while (root !== null) {\n          if (root.current.pendingWorkPriority !== NoWork$2 && (highestPriorityLevel === NoWork$2 || highestPriorityLevel > root.current.pendingWorkPriority)) {\n            highestPriorityLevel = root.current.pendingWorkPriority;\n            highestPriorityRoot = root;\n          } // We didn't find anything to do in this root, so let's try the next one.\n\n\n          root = root.nextScheduledRoot;\n        }\n\n        if (highestPriorityRoot !== null) {\n          nextPriorityLevel = highestPriorityLevel; // Before we start any new work, let's make sure that we have a fresh\n          // stack to work from.\n          // TODO: This call is buried a bit too deep. It would be nice to have\n          // a single point which happens right before any new work and\n          // unfortunately this is it.\n\n          resetContextStack();\n          nextUnitOfWork = createWorkInProgress$1(highestPriorityRoot.current, highestPriorityLevel);\n\n          if (highestPriorityRoot !== nextRenderedTree) {\n            // We've switched trees. Reset the nested update counter.\n            nestedUpdateCount = 0;\n            nextRenderedTree = highestPriorityRoot;\n          }\n\n          return;\n        }\n\n        nextPriorityLevel = NoWork$2;\n        nextUnitOfWork = null;\n        nextRenderedTree = null;\n        return;\n      }\n\n      function commitAllHostEffects() {\n        while (nextEffect !== null) {\n          {\n            ReactDebugCurrentFiber$3.setCurrentFiber(nextEffect, null);\n            recordEffect();\n          }\n          var effectTag = nextEffect.effectTag;\n\n          if (effectTag & ContentReset) {\n            config.resetTextContent(nextEffect.stateNode);\n          }\n\n          if (effectTag & Ref) {\n            var current = nextEffect.alternate;\n\n            if (current !== null) {\n              commitDetachRef(current);\n            }\n          } // The following switch statement is only concerned about placement,\n          // updates, and deletions. To avoid needing to add a case for every\n          // possible bitmap value, we remove the secondary effects from the\n          // effect tag and switch on that value.\n\n\n          var primaryEffectTag = effectTag & ~(Callback | Err | ContentReset | Ref | PerformedWork);\n\n          switch (primaryEffectTag) {\n            case Placement$1:\n              {\n                commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n                // any life-cycles like componentDidMount gets called.\n                // TODO: findDOMNode doesn't rely on this any more but isMounted\n                // does and isMounted is deprecated anyway so we should be able\n                // to kill this.\n\n                nextEffect.effectTag &= ~Placement$1;\n                break;\n              }\n\n            case PlacementAndUpdate:\n              {\n                // Placement\n                commitPlacement(nextEffect); // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n                // any life-cycles like componentDidMount gets called.\n\n                nextEffect.effectTag &= ~Placement$1; // Update\n\n                var _current = nextEffect.alternate;\n                commitWork(_current, nextEffect);\n                break;\n              }\n\n            case Update:\n              {\n                var _current2 = nextEffect.alternate;\n                commitWork(_current2, nextEffect);\n                break;\n              }\n\n            case Deletion:\n              {\n                isUnmounting = true;\n                commitDeletion(nextEffect);\n                isUnmounting = false;\n                break;\n              }\n          }\n\n          nextEffect = nextEffect.nextEffect;\n        }\n\n        {\n          ReactDebugCurrentFiber$3.resetCurrentFiber();\n        }\n      }\n\n      function commitAllLifeCycles() {\n        while (nextEffect !== null) {\n          var effectTag = nextEffect.effectTag; // Use Task priority for lifecycle updates\n\n          if (effectTag & (Update | Callback)) {\n            {\n              recordEffect();\n            }\n            var current = nextEffect.alternate;\n            commitLifeCycles(current, nextEffect);\n          }\n\n          if (effectTag & Ref) {\n            {\n              recordEffect();\n            }\n            commitAttachRef(nextEffect);\n          }\n\n          if (effectTag & Err) {\n            {\n              recordEffect();\n            }\n            commitErrorHandling(nextEffect);\n          }\n\n          var next = nextEffect.nextEffect; // Ensure that we clean these up so that we don't accidentally keep them.\n          // I'm not actually sure this matters because we can't reset firstEffect\n          // and lastEffect since they're on every node, not just the effectful\n          // ones. So we have to clean everything as we reuse nodes anyway.\n\n          nextEffect.nextEffect = null; // Ensure that we reset the effectTag here so that we can rely on effect\n          // tags to reason about the current life-cycle.\n\n          nextEffect = next;\n        }\n      }\n\n      function commitAllWork(finishedWork) {\n        // We keep track of this so that captureError can collect any boundaries\n        // that capture an error during the commit phase. The reason these aren't\n        // local to this function is because errors that occur during cWU are\n        // captured elsewhere, to prevent the unmount from being interrupted.\n        isCommitting = true;\n        {\n          startCommitTimer();\n        }\n        pendingCommit = null;\n        var root = finishedWork.stateNode;\n        !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n        if (nextPriorityLevel === SynchronousPriority$1 || nextPriorityLevel === TaskPriority$1) {\n          // Keep track of the number of iterations to prevent an infinite\n          // update loop.\n          nestedUpdateCount++;\n        } // Reset this to null before calling lifecycles\n\n\n        ReactCurrentOwner$1.current = null;\n        var firstEffect = void 0;\n\n        if (finishedWork.effectTag > PerformedWork) {\n          // A fiber's effect list consists only of its children, not itself. So if\n          // the root has an effect, we need to add it to the end of the list. The\n          // resulting list is the set that would belong to the root's parent, if\n          // it had one; that is, all the effects in the tree including the root.\n          if (finishedWork.lastEffect !== null) {\n            finishedWork.lastEffect.nextEffect = finishedWork;\n            firstEffect = finishedWork.firstEffect;\n          } else {\n            firstEffect = finishedWork;\n          }\n        } else {\n          // There is no effect on the root.\n          firstEffect = finishedWork.firstEffect;\n        }\n\n        prepareForCommit(); // Commit all the side-effects within a tree. We'll do this in two passes.\n        // The first pass performs all the host insertions, updates, deletions and\n        // ref unmounts.\n\n        nextEffect = firstEffect;\n        {\n          startCommitHostEffectsTimer();\n        }\n\n        while (nextEffect !== null) {\n          var didError = false;\n\n          var _error = void 0;\n\n          {\n            invokeGuardedCallback$1(null, commitAllHostEffects, null);\n\n            if (hasCaughtError()) {\n              didError = true;\n              _error = clearCaughtError();\n            }\n          }\n\n          if (didError) {\n            !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            captureError(nextEffect, _error); // Clean-up\n\n            if (nextEffect !== null) {\n              nextEffect = nextEffect.nextEffect;\n            }\n          }\n        }\n\n        {\n          stopCommitHostEffectsTimer();\n        }\n        resetAfterCommit(); // The work-in-progress tree is now the current tree. This must come after\n        // the first pass of the commit phase, so that the previous tree is still\n        // current during componentWillUnmount, but before the second pass, so that\n        // the finished work is current during componentDidMount/Update.\n\n        root.current = finishedWork; // In the second pass we'll perform all life-cycles and ref callbacks.\n        // Life-cycles happen as a separate pass so that all placements, updates,\n        // and deletions in the entire tree have already been invoked.\n        // This pass also triggers any renderer-specific initial effects.\n\n        nextEffect = firstEffect;\n        {\n          startCommitLifeCyclesTimer();\n        }\n\n        while (nextEffect !== null) {\n          var _didError = false;\n\n          var _error2 = void 0;\n\n          {\n            invokeGuardedCallback$1(null, commitAllLifeCycles, null);\n\n            if (hasCaughtError()) {\n              _didError = true;\n              _error2 = clearCaughtError();\n            }\n          }\n\n          if (_didError) {\n            !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            captureError(nextEffect, _error2);\n\n            if (nextEffect !== null) {\n              nextEffect = nextEffect.nextEffect;\n            }\n          }\n        }\n\n        isCommitting = false;\n        {\n          stopCommitLifeCyclesTimer();\n          stopCommitTimer();\n        }\n\n        if (typeof onCommitRoot === 'function') {\n          onCommitRoot(finishedWork.stateNode);\n        }\n\n        if (true && ReactFiberInstrumentation$1.debugTool) {\n          ReactFiberInstrumentation$1.debugTool.onCommitWork(finishedWork);\n        } // If we caught any errors during this commit, schedule their boundaries\n        // to update.\n\n\n        if (commitPhaseBoundaries) {\n          commitPhaseBoundaries.forEach(scheduleErrorRecovery);\n          commitPhaseBoundaries = null;\n        } // This tree is done. Reset the unit of work pointer to the next highest\n        // priority root. If there's no more work left, the pointer is set to null.\n\n\n        resetNextUnitOfWork();\n      }\n\n      function resetWorkPriority(workInProgress, renderPriority) {\n        if (workInProgress.pendingWorkPriority !== NoWork$2 && workInProgress.pendingWorkPriority > renderPriority) {\n          // This was a down-prioritization. Don't bubble priority from children.\n          return;\n        } // Check for pending update priority.\n\n\n        var newPriority = getUpdatePriority$1(workInProgress); // TODO: Coroutines need to visit stateNode\n\n        var child = workInProgress.child;\n\n        while (child !== null) {\n          // Ensure that remaining work priority bubbles up.\n          newPriority = largerPriority$1(newPriority, child.pendingWorkPriority);\n          child = child.sibling;\n        }\n\n        workInProgress.pendingWorkPriority = newPriority;\n      }\n\n      function completeUnitOfWork(workInProgress) {\n        while (true) {\n          // The current, flushed, state of this fiber is the alternate.\n          // Ideally nothing should rely on this, but relying on it here\n          // means that we don't need an additional field on the work in\n          // progress.\n          var current = workInProgress.alternate;\n          var next = completeWork(current, workInProgress, nextPriorityLevel);\n          var returnFiber = workInProgress['return'];\n          var siblingFiber = workInProgress.sibling;\n          resetWorkPriority(workInProgress, nextPriorityLevel);\n\n          if (next !== null) {\n            {\n              stopWorkTimer(workInProgress);\n            }\n\n            if (true && ReactFiberInstrumentation$1.debugTool) {\n              ReactFiberInstrumentation$1.debugTool.onCompleteWork(workInProgress);\n            } // If completing this work spawned new work, do that next. We'll come\n            // back here again.\n\n\n            return next;\n          }\n\n          if (returnFiber !== null) {\n            // Append all the effects of the subtree and this fiber onto the effect\n            // list of the parent. The completion order of the children affects the\n            // side-effect order.\n            if (returnFiber.firstEffect === null) {\n              returnFiber.firstEffect = workInProgress.firstEffect;\n            }\n\n            if (workInProgress.lastEffect !== null) {\n              if (returnFiber.lastEffect !== null) {\n                returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n              }\n\n              returnFiber.lastEffect = workInProgress.lastEffect;\n            } // If this fiber had side-effects, we append it AFTER the children's\n            // side-effects. We can perform certain side-effects earlier if\n            // needed, by doing multiple passes over the effect list. We don't want\n            // to schedule our own side-effect on our own list because if end up\n            // reusing children we'll schedule this effect onto itself since we're\n            // at the end.\n\n\n            var effectTag = workInProgress.effectTag; // Skip both NoWork and PerformedWork tags when creating the effect list.\n            // PerformedWork effect is read by React DevTools but shouldn't be committed.\n\n            if (effectTag > PerformedWork) {\n              if (returnFiber.lastEffect !== null) {\n                returnFiber.lastEffect.nextEffect = workInProgress;\n              } else {\n                returnFiber.firstEffect = workInProgress;\n              }\n\n              returnFiber.lastEffect = workInProgress;\n            }\n          }\n\n          {\n            stopWorkTimer(workInProgress);\n          }\n\n          if (true && ReactFiberInstrumentation$1.debugTool) {\n            ReactFiberInstrumentation$1.debugTool.onCompleteWork(workInProgress);\n          }\n\n          if (siblingFiber !== null) {\n            // If there is more work to do in this returnFiber, do that next.\n            return siblingFiber;\n          } else if (returnFiber !== null) {\n            // If there's no more work in this returnFiber. Complete the returnFiber.\n            workInProgress = returnFiber;\n            continue;\n          } else {\n            // We've reached the root. Mark the root as pending commit. Depending\n            // on how much time we have left, we'll either commit it now or in\n            // the next frame.\n            pendingCommit = workInProgress;\n            return null;\n          }\n        } // Without this explicit null return Flow complains of invalid return type\n        // TODO Remove the above while(true) loop\n        // eslint-disable-next-line no-unreachable\n\n\n        return null;\n      }\n\n      function performUnitOfWork(workInProgress) {\n        // The current, flushed, state of this fiber is the alternate.\n        // Ideally nothing should rely on this, but relying on it here\n        // means that we don't need an additional field on the work in\n        // progress.\n        var current = workInProgress.alternate; // See if beginning this work spawns more work.\n\n        {\n          startWorkTimer(workInProgress);\n        }\n        var next = beginWork(current, workInProgress, nextPriorityLevel);\n\n        if (true && ReactFiberInstrumentation$1.debugTool) {\n          ReactFiberInstrumentation$1.debugTool.onBeginWork(workInProgress);\n        }\n\n        if (next === null) {\n          // If this doesn't spawn new work, complete the current work.\n          next = completeUnitOfWork(workInProgress);\n        }\n\n        ReactCurrentOwner$1.current = null;\n        {\n          ReactDebugCurrentFiber$3.resetCurrentFiber();\n        }\n        return next;\n      }\n\n      function performFailedUnitOfWork(workInProgress) {\n        // The current, flushed, state of this fiber is the alternate.\n        // Ideally nothing should rely on this, but relying on it here\n        // means that we don't need an additional field on the work in\n        // progress.\n        var current = workInProgress.alternate; // See if beginning this work spawns more work.\n\n        {\n          startWorkTimer(workInProgress);\n        }\n        var next = beginFailedWork(current, workInProgress, nextPriorityLevel);\n\n        if (true && ReactFiberInstrumentation$1.debugTool) {\n          ReactFiberInstrumentation$1.debugTool.onBeginWork(workInProgress);\n        }\n\n        if (next === null) {\n          // If this doesn't spawn new work, complete the current work.\n          next = completeUnitOfWork(workInProgress);\n        }\n\n        ReactCurrentOwner$1.current = null;\n        {\n          ReactDebugCurrentFiber$3.resetCurrentFiber();\n        }\n        return next;\n      }\n\n      function performDeferredWork(deadline) {\n        performWork(OffscreenPriority, deadline);\n      }\n\n      function handleCommitPhaseErrors() {\n        // This is a special work loop for handling commit phase errors. It's\n        // similar to the syncrhonous work loop, but does an additional check on\n        // each fiber to see if it's an error boundary with an unhandled error. If\n        // so, it uses a forked version of performUnitOfWork that unmounts the\n        // failed subtree.\n        //\n        // The loop stops once the children have unmounted and error lifecycles are\n        // called. Then we return to the regular flow.\n        if (capturedErrors !== null && capturedErrors.size > 0 && nextPriorityLevel === TaskPriority$1) {\n          while (nextUnitOfWork !== null) {\n            if (hasCapturedError(nextUnitOfWork)) {\n              // Use a forked version of performUnitOfWork\n              nextUnitOfWork = performFailedUnitOfWork(nextUnitOfWork);\n            } else {\n              nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n            }\n\n            if (nextUnitOfWork === null) {\n              !(pendingCommit !== null) ? invariant(false, 'Should have a pending commit. This error is likely caused by a bug in React. Please file an issue.') : void 0; // We just completed a root. Commit it now.\n\n              priorityContext = TaskPriority$1;\n              commitAllWork(pendingCommit);\n              priorityContext = nextPriorityLevel;\n\n              if (capturedErrors === null || capturedErrors.size === 0 || nextPriorityLevel !== TaskPriority$1) {\n                // There are no more unhandled errors. We can exit this special\n                // work loop. If there's still additional work, we'll perform it\n                // using one of the normal work loops.\n                break;\n              } // The commit phase produced additional errors. Continue working.\n\n            }\n          }\n        }\n      }\n\n      function workLoop(minPriorityLevel, deadline) {\n        if (pendingCommit !== null) {\n          priorityContext = TaskPriority$1;\n          commitAllWork(pendingCommit);\n          handleCommitPhaseErrors();\n        } else if (nextUnitOfWork === null) {\n          resetNextUnitOfWork();\n        }\n\n        if (nextPriorityLevel === NoWork$2 || nextPriorityLevel > minPriorityLevel) {\n          return;\n        } // During the render phase, updates should have the same priority at which\n        // we're rendering.\n\n\n        priorityContext = nextPriorityLevel;\n\n        loop: do {\n          if (nextPriorityLevel <= TaskPriority$1) {\n            // Flush all synchronous and task work.\n            while (nextUnitOfWork !== null) {\n              nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n\n              if (nextUnitOfWork === null) {\n                !(pendingCommit !== null) ? invariant(false, 'Should have a pending commit. This error is likely caused by a bug in React. Please file an issue.') : void 0; // We just completed a root. Commit it now.\n\n                priorityContext = TaskPriority$1;\n                commitAllWork(pendingCommit);\n                priorityContext = nextPriorityLevel; // Clear any errors that were scheduled during the commit phase.\n\n                handleCommitPhaseErrors(); // The priority level may have changed. Check again.\n\n                if (nextPriorityLevel === NoWork$2 || nextPriorityLevel > minPriorityLevel || nextPriorityLevel > TaskPriority$1) {\n                  // The priority level does not match.\n                  break;\n                }\n              }\n            }\n          } else if (deadline !== null) {\n            // Flush asynchronous work until the deadline expires.\n            while (nextUnitOfWork !== null && !deadlineHasExpired) {\n              if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n                nextUnitOfWork = performUnitOfWork(nextUnitOfWork); // In a deferred work batch, iff nextUnitOfWork returns null, we just\n                // completed a root and a pendingCommit exists. Logically, we could\n                // omit either of the checks in the following condition, but we need\n                // both to satisfy Flow.\n\n                if (nextUnitOfWork === null) {\n                  !(pendingCommit !== null) ? invariant(false, 'Should have a pending commit. This error is likely caused by a bug in React. Please file an issue.') : void 0; // We just completed a root. If we have time, commit it now.\n                  // Otherwise, we'll commit it in the next frame.\n\n                  if (deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n                    priorityContext = TaskPriority$1;\n                    commitAllWork(pendingCommit);\n                    priorityContext = nextPriorityLevel; // Clear any errors that were scheduled during the commit phase.\n\n                    handleCommitPhaseErrors(); // The priority level may have changed. Check again.\n\n                    if (nextPriorityLevel === NoWork$2 || nextPriorityLevel > minPriorityLevel || nextPriorityLevel < HighPriority) {\n                      // The priority level does not match.\n                      break;\n                    }\n                  } else {\n                    deadlineHasExpired = true;\n                  }\n                }\n              } else {\n                deadlineHasExpired = true;\n              }\n            }\n          } // There might be work left. Depending on the priority, we should\n          // either perform it now or schedule a callback to perform it later.\n\n\n          switch (nextPriorityLevel) {\n            case SynchronousPriority$1:\n            case TaskPriority$1:\n              // We have remaining synchronous or task work. Keep performing it,\n              // regardless of whether we're inside a callback.\n              if (nextPriorityLevel <= minPriorityLevel) {\n                continue loop;\n              }\n\n              break loop;\n\n            case HighPriority:\n            case LowPriority:\n            case OffscreenPriority:\n              // We have remaining async work.\n              if (deadline === null) {\n                // We're not inside a callback. Exit and perform the work during\n                // the next callback.\n                break loop;\n              } // We are inside a callback.\n\n\n              if (!deadlineHasExpired && nextPriorityLevel <= minPriorityLevel) {\n                // We still have time. Keep working.\n                continue loop;\n              } // We've run out of time. Exit.\n\n\n              break loop;\n\n            case NoWork$2:\n              // No work left. We can exit.\n              break loop;\n\n            default:\n              invariant(false, 'Switch statement should be exhuastive. This error is likely caused by a bug in React. Please file an issue.');\n          }\n        } while (true);\n      }\n\n      function performWorkCatchBlock(failedWork, boundary, minPriorityLevel, deadline) {\n        // We're going to restart the error boundary that captured the error.\n        // Conceptually, we're unwinding the stack. We need to unwind the\n        // context stack, too.\n        unwindContexts(failedWork, boundary); // Restart the error boundary using a forked version of\n        // performUnitOfWork that deletes the boundary's children. The entire\n        // failed subree will be unmounted. During the commit phase, a special\n        // lifecycle method is called on the error boundary, which triggers\n        // a re-render.\n\n        nextUnitOfWork = performFailedUnitOfWork(boundary); // Continue working.\n\n        workLoop(minPriorityLevel, deadline);\n      }\n\n      function performWork(minPriorityLevel, deadline) {\n        {\n          startWorkLoopTimer();\n        }\n        !!isPerformingWork ? invariant(false, 'performWork was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        isPerformingWork = true; // The priority context changes during the render phase. We'll need to\n        // reset it at the end.\n\n        var previousPriorityContext = priorityContext;\n        var didError = false;\n        var error = null;\n        {\n          invokeGuardedCallback$1(null, workLoop, null, minPriorityLevel, deadline);\n\n          if (hasCaughtError()) {\n            didError = true;\n            error = clearCaughtError();\n          }\n        } // An error was thrown during the render phase.\n\n        while (didError) {\n          if (didFatal) {\n            // This was a fatal error. Don't attempt to recover from it.\n            firstUncaughtError = error;\n            break;\n          }\n\n          var failedWork = nextUnitOfWork;\n\n          if (failedWork === null) {\n            // An error was thrown but there's no current unit of work. This can\n            // happen during the commit phase if there's a bug in the renderer.\n            didFatal = true;\n            continue;\n          } // \"Capture\" the error by finding the nearest boundary. If there is no\n          // error boundary, we use the root.\n\n\n          var boundary = captureError(failedWork, error);\n          !(boundary !== null) ? invariant(false, 'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n          if (didFatal) {\n            // The error we just captured was a fatal error. This happens\n            // when the error propagates to the root more than once.\n            continue;\n          }\n\n          didError = false;\n          error = null;\n          {\n            invokeGuardedCallback$1(null, performWorkCatchBlock, null, failedWork, boundary, minPriorityLevel, deadline);\n\n            if (hasCaughtError()) {\n              didError = true;\n              error = clearCaughtError();\n              continue;\n            }\n          } // We're finished working. Exit the error loop.\n\n          break;\n        } // Reset the priority context to its previous value.\n\n\n        priorityContext = previousPriorityContext; // If we're inside a callback, set this to false, since we just flushed it.\n\n        if (deadline !== null) {\n          isCallbackScheduled = false;\n        } // If there's remaining async work, make sure we schedule another callback.\n\n\n        if (nextPriorityLevel > TaskPriority$1 && !isCallbackScheduled) {\n          scheduleDeferredCallback(performDeferredWork);\n          isCallbackScheduled = true;\n        }\n\n        var errorToThrow = firstUncaughtError; // We're done performing work. Time to clean up.\n\n        isPerformingWork = false;\n        deadlineHasExpired = false;\n        didFatal = false;\n        firstUncaughtError = null;\n        capturedErrors = null;\n        failedBoundaries = null;\n        nextRenderedTree = null;\n        nestedUpdateCount = 0;\n        {\n          stopWorkLoopTimer();\n        } // It's safe to throw any unhandled errors.\n\n        if (errorToThrow !== null) {\n          throw errorToThrow;\n        }\n      } // Returns the boundary that captured the error, or null if the error is ignored\n\n\n      function captureError(failedWork, error) {\n        // It is no longer valid because we exited the user code.\n        ReactCurrentOwner$1.current = null;\n        {\n          ReactDebugCurrentFiber$3.resetCurrentFiber();\n        } // Search for the nearest error boundary.\n\n        var boundary = null; // Passed to logCapturedError()\n\n        var errorBoundaryFound = false;\n        var willRetry = false;\n        var errorBoundaryName = null; // Host containers are a special case. If the failed work itself is a host\n        // container, then it acts as its own boundary. In all other cases, we\n        // ignore the work itself and only search through the parents.\n\n        if (failedWork.tag === HostRoot$6) {\n          boundary = failedWork;\n\n          if (isFailedBoundary(failedWork)) {\n            // If this root already failed, there must have been an error when\n            // attempting to unmount it. This is a worst-case scenario and\n            // should only be possible if there's a bug in the renderer.\n            didFatal = true;\n          }\n        } else {\n          var node = failedWork['return'];\n\n          while (node !== null && boundary === null) {\n            if (node.tag === ClassComponent$5) {\n              var instance = node.stateNode;\n\n              if (typeof instance.componentDidCatch === 'function') {\n                errorBoundaryFound = true;\n                errorBoundaryName = getComponentName_1(node); // Found an error boundary!\n\n                boundary = node;\n                willRetry = true;\n              }\n            } else if (node.tag === HostRoot$6) {\n              // Treat the root like a no-op error boundary\n              boundary = node;\n            }\n\n            if (isFailedBoundary(node)) {\n              // This boundary is already in a failed state.\n              // If we're currently unmounting, that means this error was\n              // thrown while unmounting a failed subtree. We should ignore\n              // the error.\n              if (isUnmounting) {\n                return null;\n              } // If we're in the commit phase, we should check to see if\n              // this boundary already captured an error during this commit.\n              // This case exists because multiple errors can be thrown during\n              // a single commit without interruption.\n\n\n              if (commitPhaseBoundaries !== null && (commitPhaseBoundaries.has(node) || node.alternate !== null && commitPhaseBoundaries.has(node.alternate))) {\n                // If so, we should ignore this error.\n                return null;\n              } // The error should propagate to the next boundary -— we keep looking.\n\n\n              boundary = null;\n              willRetry = false;\n            }\n\n            node = node['return'];\n          }\n        }\n\n        if (boundary !== null) {\n          // Add to the collection of failed boundaries. This lets us know that\n          // subsequent errors in this subtree should propagate to the next boundary.\n          if (failedBoundaries === null) {\n            failedBoundaries = new Set();\n          }\n\n          failedBoundaries.add(boundary); // This method is unsafe outside of the begin and complete phases.\n          // We might be in the commit phase when an error is captured.\n          // The risk is that the return path from this Fiber may not be accurate.\n          // That risk is acceptable given the benefit of providing users more context.\n\n          var _componentStack = getStackAddendumByWorkInProgressFiber$2(failedWork);\n\n          var _componentName = getComponentName_1(failedWork); // Add to the collection of captured errors. This is stored as a global\n          // map of errors and their component stack location keyed by the boundaries\n          // that capture them. We mostly use this Map as a Set; it's a Map only to\n          // avoid adding a field to Fiber to store the error.\n\n\n          if (capturedErrors === null) {\n            capturedErrors = new Map();\n          }\n\n          var capturedError = {\n            componentName: _componentName,\n            componentStack: _componentStack,\n            error: error,\n            errorBoundary: errorBoundaryFound ? boundary.stateNode : null,\n            errorBoundaryFound: errorBoundaryFound,\n            errorBoundaryName: errorBoundaryName,\n            willRetry: willRetry\n          };\n          capturedErrors.set(boundary, capturedError);\n\n          try {\n            logCapturedError(capturedError);\n          } catch (e) {\n            // Prevent cycle if logCapturedError() throws.\n            // A cycle may still occur if logCapturedError renders a component that throws.\n            console.error(e);\n          } // If we're in the commit phase, defer scheduling an update on the\n          // boundary until after the commit is complete\n\n\n          if (isCommitting) {\n            if (commitPhaseBoundaries === null) {\n              commitPhaseBoundaries = new Set();\n            }\n\n            commitPhaseBoundaries.add(boundary);\n          } else {\n            // Otherwise, schedule an update now.\n            // TODO: Is this actually necessary during the render phase? Is it\n            // possible to unwind and continue rendering at the same priority,\n            // without corrupting internal state?\n            scheduleErrorRecovery(boundary);\n          }\n\n          return boundary;\n        } else if (firstUncaughtError === null) {\n          // If no boundary is found, we'll need to throw the error\n          firstUncaughtError = error;\n        }\n\n        return null;\n      }\n\n      function hasCapturedError(fiber) {\n        // TODO: capturedErrors should store the boundary instance, to avoid needing\n        // to check the alternate.\n        return capturedErrors !== null && (capturedErrors.has(fiber) || fiber.alternate !== null && capturedErrors.has(fiber.alternate));\n      }\n\n      function isFailedBoundary(fiber) {\n        // TODO: failedBoundaries should store the boundary instance, to avoid\n        // needing to check the alternate.\n        return failedBoundaries !== null && (failedBoundaries.has(fiber) || fiber.alternate !== null && failedBoundaries.has(fiber.alternate));\n      }\n\n      function commitErrorHandling(effectfulFiber) {\n        var capturedError = void 0;\n\n        if (capturedErrors !== null) {\n          capturedError = capturedErrors.get(effectfulFiber);\n          capturedErrors['delete'](effectfulFiber);\n\n          if (capturedError == null) {\n            if (effectfulFiber.alternate !== null) {\n              effectfulFiber = effectfulFiber.alternate;\n              capturedError = capturedErrors.get(effectfulFiber);\n              capturedErrors['delete'](effectfulFiber);\n            }\n          }\n        }\n\n        !(capturedError != null) ? invariant(false, 'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n        switch (effectfulFiber.tag) {\n          case ClassComponent$5:\n            var instance = effectfulFiber.stateNode;\n            var info = {\n              componentStack: capturedError.componentStack\n            }; // Allow the boundary to handle the error, usually by scheduling\n            // an update to itself\n\n            instance.componentDidCatch(capturedError.error, info);\n            return;\n\n          case HostRoot$6:\n            if (firstUncaughtError === null) {\n              // If this is the host container, we treat it as a no-op error\n              // boundary. We'll throw the first uncaught error once it's safe to\n              // do so, at the end of the batch.\n              firstUncaughtError = capturedError.error;\n            }\n\n            return;\n\n          default:\n            invariant(false, 'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');\n        }\n      }\n\n      function unwindContexts(from, to) {\n        var node = from;\n\n        while (node !== null) {\n          switch (node.tag) {\n            case ClassComponent$5:\n              popContextProvider$1(node);\n              break;\n\n            case HostComponent$6:\n              popHostContext(node);\n              break;\n\n            case HostRoot$6:\n              popHostContainer(node);\n              break;\n\n            case HostPortal$3:\n              popHostContainer(node);\n              break;\n          }\n\n          if (node === to || node.alternate === to) {\n            {\n              stopFailedWorkTimer(node);\n            }\n            break;\n          } else {\n            stopWorkTimer(node);\n          }\n\n          node = node['return'];\n        }\n      }\n\n      function scheduleRoot(root, priorityLevel) {\n        if (priorityLevel === NoWork$2) {\n          return;\n        }\n\n        if (!root.isScheduled) {\n          root.isScheduled = true;\n\n          if (lastScheduledRoot) {\n            // Schedule ourselves to the end.\n            lastScheduledRoot.nextScheduledRoot = root;\n            lastScheduledRoot = root;\n          } else {\n            // We're the only work scheduled.\n            nextScheduledRoot = root;\n            lastScheduledRoot = root;\n          }\n        }\n      }\n\n      function scheduleUpdate(fiber, priorityLevel) {\n        return scheduleUpdateImpl(fiber, priorityLevel, false);\n      }\n\n      function scheduleUpdateImpl(fiber, priorityLevel, isErrorRecovery) {\n        {\n          recordScheduleUpdate();\n        }\n\n        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n          didFatal = true;\n          invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n        }\n\n        if (!isPerformingWork && priorityLevel <= nextPriorityLevel) {\n          // We must reset the current unit of work pointer so that we restart the\n          // search from the root during the next tick, in case there is now higher\n          // priority work somewhere earlier than before.\n          nextUnitOfWork = null;\n        }\n\n        {\n          if (!isErrorRecovery && fiber.tag === ClassComponent$5) {\n            var instance = fiber.stateNode;\n            warnAboutInvalidUpdates(instance);\n          }\n        }\n        var node = fiber;\n        var shouldContinue = true;\n\n        while (node !== null && shouldContinue) {\n          // Walk the parent path to the root and update each node's priority. Once\n          // we reach a node whose priority matches (and whose alternate's priority\n          // matches) we can exit safely knowing that the rest of the path is correct.\n          shouldContinue = false;\n\n          if (node.pendingWorkPriority === NoWork$2 || node.pendingWorkPriority > priorityLevel) {\n            // Priority did not match. Update and keep going.\n            shouldContinue = true;\n            node.pendingWorkPriority = priorityLevel;\n          }\n\n          if (node.alternate !== null) {\n            if (node.alternate.pendingWorkPriority === NoWork$2 || node.alternate.pendingWorkPriority > priorityLevel) {\n              // Priority did not match. Update and keep going.\n              shouldContinue = true;\n              node.alternate.pendingWorkPriority = priorityLevel;\n            }\n          }\n\n          if (node['return'] === null) {\n            if (node.tag === HostRoot$6) {\n              var root = node.stateNode;\n              scheduleRoot(root, priorityLevel);\n\n              if (!isPerformingWork) {\n                switch (priorityLevel) {\n                  case SynchronousPriority$1:\n                    // Perform this update now.\n                    if (isUnbatchingUpdates) {\n                      // We're inside unbatchedUpdates, which is inside either\n                      // batchedUpdates or a lifecycle. We should only flush\n                      // synchronous work, not task work.\n                      performWork(SynchronousPriority$1, null);\n                    } else {\n                      // Flush both synchronous and task work.\n                      performWork(TaskPriority$1, null);\n                    }\n\n                    break;\n\n                  case TaskPriority$1:\n                    !isBatchingUpdates ? invariant(false, 'Task updates can only be scheduled as a nested update or inside batchedUpdates.') : void 0;\n                    break;\n\n                  default:\n                    // Schedule a callback to perform the work later.\n                    if (!isCallbackScheduled) {\n                      scheduleDeferredCallback(performDeferredWork);\n                      isCallbackScheduled = true;\n                    }\n\n                }\n              }\n            } else {\n              {\n                if (!isErrorRecovery && fiber.tag === ClassComponent$5) {\n                  warnAboutUpdateOnUnmounted(fiber.stateNode);\n                }\n              }\n              return;\n            }\n          }\n\n          node = node['return'];\n        }\n      }\n\n      function getPriorityContext(fiber, forceAsync) {\n        var priorityLevel = priorityContext;\n\n        if (priorityLevel === NoWork$2) {\n          if (!useSyncScheduling || fiber.internalContextTag & AsyncUpdates || forceAsync) {\n            priorityLevel = LowPriority;\n          } else {\n            priorityLevel = SynchronousPriority$1;\n          }\n        } // If we're in a batch, or if we're already performing work, downgrade sync\n        // priority to task priority\n\n\n        if (priorityLevel === SynchronousPriority$1 && (isPerformingWork || isBatchingUpdates)) {\n          return TaskPriority$1;\n        }\n\n        return priorityLevel;\n      }\n\n      function scheduleErrorRecovery(fiber) {\n        scheduleUpdateImpl(fiber, TaskPriority$1, true);\n      }\n\n      function batchedUpdates(fn, a) {\n        var previousIsBatchingUpdates = isBatchingUpdates;\n        isBatchingUpdates = true;\n\n        try {\n          return fn(a);\n        } finally {\n          isBatchingUpdates = previousIsBatchingUpdates; // If we're not already inside a batch, we need to flush any task work\n          // that was created by the user-provided function.\n\n          if (!isPerformingWork && !isBatchingUpdates) {\n            performWork(TaskPriority$1, null);\n          }\n        }\n      }\n\n      function unbatchedUpdates(fn) {\n        var previousIsUnbatchingUpdates = isUnbatchingUpdates;\n        var previousIsBatchingUpdates = isBatchingUpdates; // This is only true if we're nested inside batchedUpdates.\n\n        isUnbatchingUpdates = isBatchingUpdates;\n        isBatchingUpdates = false;\n\n        try {\n          return fn();\n        } finally {\n          isBatchingUpdates = previousIsBatchingUpdates;\n          isUnbatchingUpdates = previousIsUnbatchingUpdates;\n        }\n      }\n\n      function flushSync(batch) {\n        var previousIsBatchingUpdates = isBatchingUpdates;\n        var previousPriorityContext = priorityContext;\n        isBatchingUpdates = true;\n        priorityContext = SynchronousPriority$1;\n\n        try {\n          return batch();\n        } finally {\n          isBatchingUpdates = previousIsBatchingUpdates;\n          priorityContext = previousPriorityContext;\n          !!isPerformingWork ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n          performWork(TaskPriority$1, null);\n        }\n      }\n\n      function deferredUpdates(fn) {\n        var previousPriorityContext = priorityContext;\n        priorityContext = LowPriority;\n\n        try {\n          return fn();\n        } finally {\n          priorityContext = previousPriorityContext;\n        }\n      }\n\n      return {\n        scheduleUpdate: scheduleUpdate,\n        getPriorityContext: getPriorityContext,\n        batchedUpdates: batchedUpdates,\n        unbatchedUpdates: unbatchedUpdates,\n        flushSync: flushSync,\n        deferredUpdates: deferredUpdates\n      };\n    };\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule getContextForSubtree\n     * \n     */\n\n\n    var getContextFiber = function getContextFiber(arg) {\n      invariant(false, 'Missing injection for fiber getContextForSubtree');\n    };\n\n    function getContextForSubtree(parentComponent) {\n      if (!parentComponent) {\n        return emptyObject;\n      }\n\n      var instance = ReactInstanceMap_1.get(parentComponent);\n\n      if (typeof instance.tag === 'number') {\n        return getContextFiber(instance);\n      } else {\n        return instance._processChildContext(instance._context);\n      }\n    }\n\n    getContextForSubtree._injectFiber = function (fn) {\n      getContextFiber = fn;\n    };\n\n    var getContextForSubtree_1 = getContextForSubtree;\n    var addTopLevelUpdate = ReactFiberUpdateQueue.addTopLevelUpdate;\n    var findCurrentUnmaskedContext = ReactFiberContext.findCurrentUnmaskedContext;\n    var isContextProvider = ReactFiberContext.isContextProvider;\n    var processChildContext = ReactFiberContext.processChildContext;\n    var createFiberRoot = ReactFiberRoot.createFiberRoot;\n    var HostComponent$3 = ReactTypeOfWork.HostComponent;\n    {\n      var warning$18 = require$$0;\n      var ReactFiberInstrumentation = ReactFiberInstrumentation_1;\n      var ReactDebugCurrentFiber$1 = ReactDebugCurrentFiber_1;\n      var getComponentName$4 = getComponentName_1;\n    }\n    var findCurrentHostFiber$1 = ReactFiberTreeReflection.findCurrentHostFiber;\n    var findCurrentHostFiberWithNoPortals$1 = ReactFiberTreeReflection.findCurrentHostFiberWithNoPortals;\n\n    getContextForSubtree_1._injectFiber(function (fiber) {\n      var parentContext = findCurrentUnmaskedContext(fiber);\n      return isContextProvider(fiber) ? processChildContext(fiber, parentContext, false) : parentContext;\n    });\n\n    var ReactFiberReconciler = function ReactFiberReconciler(config) {\n      var getPublicInstance = config.getPublicInstance;\n\n      var _ReactFiberScheduler = ReactFiberScheduler(config),\n          scheduleUpdate = _ReactFiberScheduler.scheduleUpdate,\n          getPriorityContext = _ReactFiberScheduler.getPriorityContext,\n          batchedUpdates = _ReactFiberScheduler.batchedUpdates,\n          unbatchedUpdates = _ReactFiberScheduler.unbatchedUpdates,\n          flushSync = _ReactFiberScheduler.flushSync,\n          deferredUpdates = _ReactFiberScheduler.deferredUpdates;\n\n      function scheduleTopLevelUpdate(current, element, callback) {\n        {\n          if (ReactDebugCurrentFiber$1.phase === 'render' && ReactDebugCurrentFiber$1.current !== null) {\n            warning$18(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName$4(ReactDebugCurrentFiber$1.current) || 'Unknown');\n          }\n        } // Check if the top-level element is an async wrapper component. If so, treat\n        // updates to the root as async. This is a bit weird but lets us avoid a separate\n        // `renderAsync` API.\n\n        var forceAsync = ReactFeatureFlags_1.enableAsyncSubtreeAPI && element != null && element.type != null && element.type.prototype != null && element.type.prototype.unstable_isAsyncReactComponent === true;\n        var priorityLevel = getPriorityContext(current, forceAsync);\n        var nextState = {\n          element: element\n        };\n        callback = callback === undefined ? null : callback;\n        {\n          warning$18(callback === null || typeof callback === 'function', 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n        }\n        addTopLevelUpdate(current, nextState, callback, priorityLevel);\n        scheduleUpdate(current, priorityLevel);\n      }\n\n      return {\n        createContainer: function createContainer(containerInfo) {\n          return createFiberRoot(containerInfo);\n        },\n        updateContainer: function updateContainer(element, container, parentComponent, callback) {\n          // TODO: If this is a nested container, this won't be the root.\n          var current = container.current;\n          {\n            if (ReactFiberInstrumentation.debugTool) {\n              if (current.alternate === null) {\n                ReactFiberInstrumentation.debugTool.onMountContainer(container);\n              } else if (element === null) {\n                ReactFiberInstrumentation.debugTool.onUnmountContainer(container);\n              } else {\n                ReactFiberInstrumentation.debugTool.onUpdateContainer(container);\n              }\n            }\n          }\n          var context = getContextForSubtree_1(parentComponent);\n\n          if (container.context === null) {\n            container.context = context;\n          } else {\n            container.pendingContext = context;\n          }\n\n          scheduleTopLevelUpdate(current, element, callback);\n        },\n        batchedUpdates: batchedUpdates,\n        unbatchedUpdates: unbatchedUpdates,\n        deferredUpdates: deferredUpdates,\n        flushSync: flushSync,\n        getPublicRootInstance: function getPublicRootInstance(container) {\n          var containerFiber = container.current;\n\n          if (!containerFiber.child) {\n            return null;\n          }\n\n          switch (containerFiber.child.tag) {\n            case HostComponent$3:\n              return getPublicInstance(containerFiber.child.stateNode);\n\n            default:\n              return containerFiber.child.stateNode;\n          }\n        },\n        findHostInstance: function findHostInstance(fiber) {\n          var hostFiber = findCurrentHostFiber$1(fiber);\n\n          if (hostFiber === null) {\n            return null;\n          }\n\n          return hostFiber.stateNode;\n        },\n        findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(fiber) {\n          var hostFiber = findCurrentHostFiberWithNoPortals$1(fiber);\n\n          if (hostFiber === null) {\n            return null;\n          }\n\n          return hostFiber.stateNode;\n        }\n      };\n    };\n\n    var TEXT_NODE$3 = HTMLNodeType_1.TEXT_NODE;\n    /**\n     * Given any node return the first leaf node without children.\n     *\n     * @param {DOMElement|DOMTextNode} node\n     * @return {DOMElement|DOMTextNode}\n     */\n\n    function getLeafNode(node) {\n      while (node && node.firstChild) {\n        node = node.firstChild;\n      }\n\n      return node;\n    }\n    /**\n     * Get the next sibling within a container. This will walk up the\n     * DOM if a node's siblings have been exhausted.\n     *\n     * @param {DOMElement|DOMTextNode} node\n     * @return {?DOMElement|DOMTextNode}\n     */\n\n\n    function getSiblingNode(node) {\n      while (node) {\n        if (node.nextSibling) {\n          return node.nextSibling;\n        }\n\n        node = node.parentNode;\n      }\n    }\n    /**\n     * Get object describing the nodes which contain characters at offset.\n     *\n     * @param {DOMElement|DOMTextNode} root\n     * @param {number} offset\n     * @return {?object}\n     */\n\n\n    function getNodeForCharacterOffset(root, offset) {\n      var node = getLeafNode(root);\n      var nodeStart = 0;\n      var nodeEnd = 0;\n\n      while (node) {\n        if (node.nodeType === TEXT_NODE$3) {\n          nodeEnd = nodeStart + node.textContent.length;\n\n          if (nodeStart <= offset && nodeEnd >= offset) {\n            return {\n              node: node,\n              offset: offset - nodeStart\n            };\n          }\n\n          nodeStart = nodeEnd;\n        }\n\n        node = getLeafNode(getSiblingNode(node));\n      }\n    }\n\n    var getNodeForCharacterOffset_1 = getNodeForCharacterOffset;\n    var contentKey = null;\n    /**\n     * Gets the key used to access text content on a DOM node.\n     *\n     * @return {?string} Key used to access text content.\n     * @internal\n     */\n\n    function getTextContentAccessor() {\n      if (!contentKey && ExecutionEnvironment.canUseDOM) {\n        // Prefer textContent to innerText because many browsers support both but\n        // SVG <text> elements don't support innerText even when <div> does.\n        contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';\n      }\n\n      return contentKey;\n    }\n\n    var getTextContentAccessor_1 = getTextContentAccessor;\n    /**\n     * While `isCollapsed` is available on the Selection object and `collapsed`\n     * is available on the Range object, IE11 sometimes gets them wrong.\n     * If the anchor/focus nodes and offsets are the same, the range is collapsed.\n     */\n\n    function isCollapsed(anchorNode, anchorOffset, focusNode$$1, focusOffset) {\n      return anchorNode === focusNode$$1 && anchorOffset === focusOffset;\n    }\n    /**\n     * @param {DOMElement} node\n     * @return {?object}\n     */\n\n\n    function getModernOffsets(node) {\n      var selection = window.getSelection && window.getSelection();\n\n      if (!selection || selection.rangeCount === 0) {\n        return null;\n      }\n\n      var anchorNode = selection.anchorNode;\n      var anchorOffset = selection.anchorOffset;\n      var focusNode$$1 = selection.focusNode;\n      var focusOffset = selection.focusOffset;\n      var currentRange = selection.getRangeAt(0); // In Firefox, range.startContainer and range.endContainer can be \"anonymous\n      // divs\", e.g. the up/down buttons on an <input type=\"number\">. Anonymous\n      // divs do not seem to expose properties, triggering a \"Permission denied\n      // error\" if any of its properties are accessed. The only seemingly possible\n      // way to avoid erroring is to access a property that typically works for\n      // non-anonymous divs and catch any error that may otherwise arise. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n\n      try {\n        /* eslint-disable no-unused-expressions */\n        currentRange.startContainer.nodeType;\n        currentRange.endContainer.nodeType;\n        /* eslint-enable no-unused-expressions */\n      } catch (e) {\n        return null;\n      } // If the node and offset values are the same, the selection is collapsed.\n      // `Selection.isCollapsed` is available natively, but IE sometimes gets\n      // this value wrong.\n\n\n      var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);\n      var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;\n      var tempRange = currentRange.cloneRange();\n      tempRange.selectNodeContents(node);\n      tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);\n      var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);\n      var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;\n      var end = start + rangeLength; // Detect whether the selection is backward.\n\n      var detectionRange = document.createRange();\n      detectionRange.setStart(anchorNode, anchorOffset);\n      detectionRange.setEnd(focusNode$$1, focusOffset);\n      var isBackward = detectionRange.collapsed;\n      return {\n        start: isBackward ? end : start,\n        end: isBackward ? start : end\n      };\n    }\n    /**\n     * In modern non-IE browsers, we can support both forward and backward\n     * selections.\n     *\n     * Note: IE10+ supports the Selection object, but it does not support\n     * the `extend` method, which means that even in modern IE, it's not possible\n     * to programmatically create a backward selection. Thus, for all IE\n     * versions, we use the old IE API to create our selections.\n     *\n     * @param {DOMElement|DOMTextNode} node\n     * @param {object} offsets\n     */\n\n\n    function setModernOffsets(node, offsets) {\n      if (!window.getSelection) {\n        return;\n      }\n\n      var selection = window.getSelection();\n      var length = node[getTextContentAccessor_1()].length;\n      var start = Math.min(offsets.start, length);\n      var end = offsets.end === undefined ? start : Math.min(offsets.end, length); // IE 11 uses modern selection, but doesn't support the extend method.\n      // Flip backward selections, so we can set with a single range.\n\n      if (!selection.extend && start > end) {\n        var temp = end;\n        end = start;\n        start = temp;\n      }\n\n      var startMarker = getNodeForCharacterOffset_1(node, start);\n      var endMarker = getNodeForCharacterOffset_1(node, end);\n\n      if (startMarker && endMarker) {\n        var range = document.createRange();\n        range.setStart(startMarker.node, startMarker.offset);\n        selection.removeAllRanges();\n\n        if (start > end) {\n          selection.addRange(range);\n          selection.extend(endMarker.node, endMarker.offset);\n        } else {\n          range.setEnd(endMarker.node, endMarker.offset);\n          selection.addRange(range);\n        }\n      }\n    }\n\n    var ReactDOMSelection = {\n      /**\n       * @param {DOMElement} node\n       */\n      getOffsets: getModernOffsets,\n\n      /**\n       * @param {DOMElement|DOMTextNode} node\n       * @param {object} offsets\n       */\n      setOffsets: setModernOffsets\n    };\n    var ReactDOMSelection_1 = ReactDOMSelection;\n    var ELEMENT_NODE$2 = HTMLNodeType_1.ELEMENT_NODE;\n\n    function isInDocument(node) {\n      return containsNode(document.documentElement, node);\n    }\n    /**\n     * @ReactInputSelection: React input selection module. Based on Selection.js,\n     * but modified to be suitable for react and has a couple of bug fixes (doesn't\n     * assume buttons have range selections allowed).\n     * Input selection module for React.\n     */\n\n\n    var ReactInputSelection = {\n      hasSelectionCapabilities: function hasSelectionCapabilities(elem) {\n        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n        return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');\n      },\n      getSelectionInformation: function getSelectionInformation() {\n        var focusedElem = getActiveElement();\n        return {\n          focusedElem: focusedElem,\n          selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null\n        };\n      },\n\n      /**\n       * @restoreSelection: If any selection information was potentially lost,\n       * restore it. This is useful when performing operations that could remove dom\n       * nodes and place them back in, resulting in focus being lost.\n       */\n      restoreSelection: function restoreSelection(priorSelectionInformation) {\n        var curFocusedElem = getActiveElement();\n        var priorFocusedElem = priorSelectionInformation.focusedElem;\n        var priorSelectionRange = priorSelectionInformation.selectionRange;\n\n        if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n          if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {\n            ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);\n          } // Focusing a node can change the scroll position, which is undesirable\n\n\n          var ancestors = [];\n          var ancestor = priorFocusedElem;\n\n          while (ancestor = ancestor.parentNode) {\n            if (ancestor.nodeType === ELEMENT_NODE$2) {\n              ancestors.push({\n                element: ancestor,\n                left: ancestor.scrollLeft,\n                top: ancestor.scrollTop\n              });\n            }\n          }\n\n          focusNode(priorFocusedElem);\n\n          for (var i = 0; i < ancestors.length; i++) {\n            var info = ancestors[i];\n            info.element.scrollLeft = info.left;\n            info.element.scrollTop = info.top;\n          }\n        }\n      },\n\n      /**\n       * @getSelection: Gets the selection bounds of a focused textarea, input or\n       * contentEditable node.\n       * -@input: Look up selection bounds of this input\n       * -@return {start: selectionStart, end: selectionEnd}\n       */\n      getSelection: function getSelection(input) {\n        var selection;\n\n        if ('selectionStart' in input) {\n          // Modern browser with input or textarea.\n          selection = {\n            start: input.selectionStart,\n            end: input.selectionEnd\n          };\n        } else {\n          // Content editable or old IE textarea.\n          selection = ReactDOMSelection_1.getOffsets(input);\n        }\n\n        return selection || {\n          start: 0,\n          end: 0\n        };\n      },\n\n      /**\n       * @setSelection: Sets the selection bounds of a textarea or input and focuses\n       * the input.\n       * -@input     Set selection bounds of this input or textarea\n       * -@offsets   Object of same form that is returned from get*\n       */\n      setSelection: function setSelection(input, offsets) {\n        var start = offsets.start;\n        var end = offsets.end;\n\n        if (end === undefined) {\n          end = start;\n        }\n\n        if ('selectionStart' in input) {\n          input.selectionStart = start;\n          input.selectionEnd = Math.min(end, input.value.length);\n        } else {\n          ReactDOMSelection_1.setOffsets(input, offsets);\n        }\n      }\n    };\n    var ReactInputSelection_1 = ReactInputSelection;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule ReactVersion\n     */\n\n    var ReactVersion = '16.0.0';\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule findDOMNode\n     * \n     */\n\n    var ELEMENT_NODE$3 = HTMLNodeType_1.ELEMENT_NODE;\n    var ReactCurrentOwner$3 = ReactGlobalSharedState_1.ReactCurrentOwner;\n    {\n      var warning$27 = require$$0;\n    }\n\n    var findFiber = function findFiber(arg) {\n      invariant(false, 'Missing injection for fiber findDOMNode');\n    };\n\n    var findStack = function findStack(arg) {\n      invariant(false, 'Missing injection for stack findDOMNode');\n    };\n\n    var findDOMNode = function findDOMNode(componentOrElement) {\n      {\n        var owner = ReactCurrentOwner$3.current;\n\n        if (owner !== null) {\n          var isFiber = typeof owner.tag === 'number';\n          var warnedAboutRefsInRender = isFiber ? owner.stateNode._warnedAboutRefsInRender : owner._warnedAboutRefsInRender;\n          warning$27(warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName_1(owner) || 'A component');\n\n          if (isFiber) {\n            owner.stateNode._warnedAboutRefsInRender = true;\n          } else {\n            owner._warnedAboutRefsInRender = true;\n          }\n        }\n      }\n\n      if (componentOrElement == null) {\n        return null;\n      }\n\n      if (componentOrElement.nodeType === ELEMENT_NODE$3) {\n        return componentOrElement;\n      }\n\n      var inst = ReactInstanceMap_1.get(componentOrElement);\n\n      if (inst) {\n        if (typeof inst.tag === 'number') {\n          return findFiber(inst);\n        } else {\n          return findStack(inst);\n        }\n      }\n\n      if (typeof componentOrElement.render === 'function') {\n        invariant(false, 'Unable to find node on an unmounted component.');\n      } else {\n        invariant(false, 'Element appears to be neither ReactComponent nor DOMNode. Keys: %s', Object.keys(componentOrElement));\n      }\n    };\n\n    findDOMNode._injectFiber = function (fn) {\n      findFiber = fn;\n    };\n\n    findDOMNode._injectStack = function (fn) {\n      findStack = fn;\n    };\n\n    var findDOMNode_1 = findDOMNode;\n    /**\n     * Copyright (c) 2014-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule lowPriorityWarning\n     */\n\n    /**\n     * Forked from fbjs/warning:\n     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n     *\n     * Only change is we use console.warn instead of console.error,\n     * and do nothing when 'console' is not supported.\n     * This really simplifies the code.\n     * ---\n     * Similar to invariant but only logs a warning if the condition is not met.\n     * This can be used to log issues in development environments in critical\n     * paths. Removing the logging code for production environments will keep the\n     * same logic and follow the same code paths.\n     */\n\n    var lowPriorityWarning$1 = function lowPriorityWarning$1() {};\n\n    {\n      var printWarning = function printWarning(format) {\n        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        var argIndex = 0;\n        var message = 'Warning: ' + format.replace(/%s/g, function () {\n          return args[argIndex++];\n        });\n\n        if (typeof console !== 'undefined') {\n          console.warn(message);\n        }\n\n        try {\n          // --- Welcome to debugging React ---\n          // This error was thrown as a convenience so that you can use this stack\n          // to find the callsite that caused this warning to fire.\n          throw new Error(message);\n        } catch (x) {}\n      };\n\n      lowPriorityWarning$1 = function lowPriorityWarning$1(condition, format) {\n        if (format === undefined) {\n          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n        }\n\n        if (!condition) {\n          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n            args[_key2 - 2] = arguments[_key2];\n          }\n\n          printWarning.apply(undefined, [format].concat(args));\n        }\n      };\n    }\n    var lowPriorityWarning_1 = lowPriorityWarning$1;\n    var validateDOMNesting$1 = emptyFunction;\n    {\n      var warning$28 = require$$0;\n      var _require$13 = ReactDebugCurrentFiber_1,\n          getCurrentFiberStackAddendum$6 = _require$13.getCurrentFiberStackAddendum; // This validation code was written based on the HTML5 parsing spec:\n      // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n      //\n      // Note: this does not catch all invalid nesting, nor does it try to (as it's\n      // not clear what practical benefit doing so provides); instead, we warn only\n      // for cases where the parser will give a parse tree differing from what React\n      // intended. For example, <b><div></div></b> is invalid but we don't warn\n      // because it still parses correctly; we do warn for other cases like nested\n      // <p> tags where the beginning of the second element implicitly closes the\n      // first, causing a confusing mess.\n      // https://html.spec.whatwg.org/multipage/syntax.html#special\n\n      var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp']; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n\n      var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template', // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n      // TODO: Distinguish by namespace here -- for <title>, including it here\n      // errs on the side of fewer warnings\n      'foreignObject', 'desc', 'title']; // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\n\n      var buttonScopeTags = inScopeTags.concat(['button']); // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\n\n      var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n      var emptyAncestorInfo = {\n        current: null,\n        formTag: null,\n        aTagInScope: null,\n        buttonTagInScope: null,\n        nobrTagInScope: null,\n        pTagInButtonScope: null,\n        listItemTagAutoclosing: null,\n        dlItemTagAutoclosing: null\n      };\n\n      var updatedAncestorInfo$1 = function updatedAncestorInfo$1(oldInfo, tag, instance) {\n        var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);\n\n        var info = {\n          tag: tag,\n          instance: instance\n        };\n\n        if (inScopeTags.indexOf(tag) !== -1) {\n          ancestorInfo.aTagInScope = null;\n          ancestorInfo.buttonTagInScope = null;\n          ancestorInfo.nobrTagInScope = null;\n        }\n\n        if (buttonScopeTags.indexOf(tag) !== -1) {\n          ancestorInfo.pTagInButtonScope = null;\n        } // See rules for 'li', 'dd', 'dt' start tags in\n        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n\n\n        if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {\n          ancestorInfo.listItemTagAutoclosing = null;\n          ancestorInfo.dlItemTagAutoclosing = null;\n        }\n\n        ancestorInfo.current = info;\n\n        if (tag === 'form') {\n          ancestorInfo.formTag = info;\n        }\n\n        if (tag === 'a') {\n          ancestorInfo.aTagInScope = info;\n        }\n\n        if (tag === 'button') {\n          ancestorInfo.buttonTagInScope = info;\n        }\n\n        if (tag === 'nobr') {\n          ancestorInfo.nobrTagInScope = info;\n        }\n\n        if (tag === 'p') {\n          ancestorInfo.pTagInButtonScope = info;\n        }\n\n        if (tag === 'li') {\n          ancestorInfo.listItemTagAutoclosing = info;\n        }\n\n        if (tag === 'dd' || tag === 'dt') {\n          ancestorInfo.dlItemTagAutoclosing = info;\n        }\n\n        return ancestorInfo;\n      };\n      /**\n       * Returns whether\n       */\n\n\n      var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {\n        // First, let's check if we're in an unusual parsing mode...\n        switch (parentTag) {\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n          case 'select':\n            return tag === 'option' || tag === 'optgroup' || tag === '#text';\n\n          case 'optgroup':\n            return tag === 'option' || tag === '#text';\n          // Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n          // but\n\n          case 'option':\n            return tag === '#text';\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n          // No special behavior since these rules fall back to \"in body\" mode for\n          // all except special table nodes which cause bad parsing behavior anyway.\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n\n          case 'tr':\n            return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n\n          case 'tbody':\n          case 'thead':\n          case 'tfoot':\n            return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n\n          case 'colgroup':\n            return tag === 'col' || tag === 'template';\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n\n          case 'table':\n            return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';\n          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n\n          case 'head':\n            return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';\n          // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n\n          case 'html':\n            return tag === 'head' || tag === 'body';\n\n          case '#document':\n            return tag === 'html';\n        } // Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n        // where the parsing rules cause implicit opens or closes to be added.\n        // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n\n\n        switch (tag) {\n          case 'h1':\n          case 'h2':\n          case 'h3':\n          case 'h4':\n          case 'h5':\n          case 'h6':\n            return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';\n\n          case 'rp':\n          case 'rt':\n            return impliedEndTags.indexOf(parentTag) === -1;\n\n          case 'body':\n          case 'caption':\n          case 'col':\n          case 'colgroup':\n          case 'frame':\n          case 'head':\n          case 'html':\n          case 'tbody':\n          case 'td':\n          case 'tfoot':\n          case 'th':\n          case 'thead':\n          case 'tr':\n            // These tags are only valid with a few parents that have special child\n            // parsing rules -- if we're down here, then none of those matched and\n            // so we allow it only if we don't know what the parent is, as all other\n            // cases are invalid.\n            return parentTag == null;\n        }\n\n        return true;\n      };\n      /**\n       * Returns whether\n       */\n\n\n      var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {\n        switch (tag) {\n          case 'address':\n          case 'article':\n          case 'aside':\n          case 'blockquote':\n          case 'center':\n          case 'details':\n          case 'dialog':\n          case 'dir':\n          case 'div':\n          case 'dl':\n          case 'fieldset':\n          case 'figcaption':\n          case 'figure':\n          case 'footer':\n          case 'header':\n          case 'hgroup':\n          case 'main':\n          case 'menu':\n          case 'nav':\n          case 'ol':\n          case 'p':\n          case 'section':\n          case 'summary':\n          case 'ul':\n          case 'pre':\n          case 'listing':\n          case 'table':\n          case 'hr':\n          case 'xmp':\n          case 'h1':\n          case 'h2':\n          case 'h3':\n          case 'h4':\n          case 'h5':\n          case 'h6':\n            return ancestorInfo.pTagInButtonScope;\n\n          case 'form':\n            return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n\n          case 'li':\n            return ancestorInfo.listItemTagAutoclosing;\n\n          case 'dd':\n          case 'dt':\n            return ancestorInfo.dlItemTagAutoclosing;\n\n          case 'button':\n            return ancestorInfo.buttonTagInScope;\n\n          case 'a':\n            // Spec says something about storing a list of markers, but it sounds\n            // equivalent to this check.\n            return ancestorInfo.aTagInScope;\n\n          case 'nobr':\n            return ancestorInfo.nobrTagInScope;\n        }\n\n        return null;\n      };\n      /**\n       * Given a ReactCompositeComponent instance, return a list of its recursive\n       * owners, starting at the root and ending with the instance itself.\n       */\n\n\n      var findOwnerStack = function findOwnerStack(instance) {\n        if (!instance) {\n          return [];\n        }\n\n        var stack = [];\n\n        do {\n          stack.push(instance);\n        } while (instance = instance._currentElement._owner);\n\n        stack.reverse();\n        return stack;\n      };\n\n      var getOwnerInfo = function getOwnerInfo(childInstance, childTag, ancestorInstance, ancestorTag, isParent) {\n        var childOwner = childInstance && childInstance._currentElement._owner;\n        var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;\n        var childOwners = findOwnerStack(childOwner);\n        var ancestorOwners = findOwnerStack(ancestorOwner);\n        var minStackLen = Math.min(childOwners.length, ancestorOwners.length);\n        var i;\n        var deepestCommon = -1;\n\n        for (i = 0; i < minStackLen; i++) {\n          if (childOwners[i] === ancestorOwners[i]) {\n            deepestCommon = i;\n          } else {\n            break;\n          }\n        }\n\n        var UNKNOWN = '(unknown)';\n        var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {\n          return getComponentName_1(inst) || UNKNOWN;\n        });\n        var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {\n          return getComponentName_1(inst) || UNKNOWN;\n        });\n        var ownerInfo = [].concat( // If the parent and child instances have a common owner ancestor, start\n        // with that -- otherwise we just start with the parent's owners.\n        deepestCommon !== -1 ? getComponentName_1(childOwners[deepestCommon]) || UNKNOWN : [], ancestorOwnerNames, ancestorTag, // If we're warning about an invalid (non-parent) ancestry, add '...'\n        isParent ? [] : ['...'], childOwnerNames, childTag).join(' > ');\n        return ownerInfo;\n      };\n\n      var didWarn = {};\n\n      validateDOMNesting$1 = function validateDOMNesting$1(childTag, childText, childInstance, ancestorInfo) {\n        ancestorInfo = ancestorInfo || emptyAncestorInfo;\n        var parentInfo = ancestorInfo.current;\n        var parentTag = parentInfo && parentInfo.tag;\n\n        if (childText != null) {\n          warning$28(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null');\n          childTag = '#text';\n        }\n\n        var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n        var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n        var invalidParentOrAncestor = invalidParent || invalidAncestor;\n\n        if (!invalidParentOrAncestor) {\n          return;\n        }\n\n        var ancestorInstance = invalidParentOrAncestor.instance;\n        var ancestorTag = invalidParentOrAncestor.tag;\n        var addendum;\n\n        if (childInstance != null) {\n          addendum = ' See ' + getOwnerInfo(childInstance, childTag, ancestorInstance, ancestorTag, !!invalidParent) + '.';\n        } else {\n          addendum = getCurrentFiberStackAddendum$6();\n        }\n\n        var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;\n\n        if (didWarn[warnKey]) {\n          return;\n        }\n\n        didWarn[warnKey] = true;\n        var tagDisplayName = childTag;\n        var whitespaceInfo = '';\n\n        if (childTag === '#text') {\n          if (/\\S/.test(childText)) {\n            tagDisplayName = 'Text nodes';\n          } else {\n            tagDisplayName = 'Whitespace text nodes';\n            whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on \" + 'each line of your source code.';\n          }\n        } else {\n          tagDisplayName = '<' + childTag + '>';\n        }\n\n        if (invalidParent) {\n          var info = '';\n\n          if (ancestorTag === 'table' && childTag === 'tr') {\n            info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';\n          }\n\n          warning$28(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);\n        } else {\n          warning$28(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);\n        }\n      };\n\n      validateDOMNesting$1.updatedAncestorInfo = updatedAncestorInfo$1; // For testing\n\n      validateDOMNesting$1.isTagValidInContext = function (tag, ancestorInfo) {\n        ancestorInfo = ancestorInfo || emptyAncestorInfo;\n        var parentInfo = ancestorInfo.current;\n        var parentTag = parentInfo && parentInfo.tag;\n        return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);\n      };\n    }\n    var validateDOMNesting_1 = validateDOMNesting$1;\n    var HostComponent$11 = ReactTypeOfWork.HostComponent;\n\n    function getParent(inst) {\n      if (inst._hostParent !== undefined) {\n        return inst._hostParent;\n      }\n\n      if (typeof inst.tag === 'number') {\n        do {\n          inst = inst['return']; // TODO: If this is a HostRoot we might want to bail out.\n          // That is depending on if we want nested subtrees (layers) to bubble\n          // events to their parent. We could also go through parentNode on the\n          // host node but that wouldn't work for React Native and doesn't let us\n          // do the portal feature.\n        } while (inst && inst.tag !== HostComponent$11);\n\n        if (inst) {\n          return inst;\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Return the lowest common ancestor of A and B, or null if they are in\n     * different trees.\n     */\n\n\n    function getLowestCommonAncestor(instA, instB) {\n      var depthA = 0;\n\n      for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n        depthA++;\n      }\n\n      var depthB = 0;\n\n      for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n        depthB++;\n      } // If A is deeper, crawl up.\n\n\n      while (depthA - depthB > 0) {\n        instA = getParent(instA);\n        depthA--;\n      } // If B is deeper, crawl up.\n\n\n      while (depthB - depthA > 0) {\n        instB = getParent(instB);\n        depthB--;\n      } // Walk in lockstep until we find a match.\n\n\n      var depth = depthA;\n\n      while (depth--) {\n        if (instA === instB || instA === instB.alternate) {\n          return instA;\n        }\n\n        instA = getParent(instA);\n        instB = getParent(instB);\n      }\n\n      return null;\n    }\n    /**\n     * Return if A is an ancestor of B.\n     */\n\n\n    function isAncestor(instA, instB) {\n      while (instB) {\n        if (instA === instB || instA === instB.alternate) {\n          return true;\n        }\n\n        instB = getParent(instB);\n      }\n\n      return false;\n    }\n    /**\n     * Return the parent instance of the passed-in instance.\n     */\n\n\n    function getParentInstance(inst) {\n      return getParent(inst);\n    }\n    /**\n     * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n     */\n\n\n    function traverseTwoPhase(inst, fn, arg) {\n      var path = [];\n\n      while (inst) {\n        path.push(inst);\n        inst = getParent(inst);\n      }\n\n      var i;\n\n      for (i = path.length; i-- > 0;) {\n        fn(path[i], 'captured', arg);\n      }\n\n      for (i = 0; i < path.length; i++) {\n        fn(path[i], 'bubbled', arg);\n      }\n    }\n    /**\n     * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n     * should would receive a `mouseEnter` or `mouseLeave` event.\n     *\n     * Does not invoke the callback on the nearest common ancestor because nothing\n     * \"entered\" or \"left\" that element.\n     */\n\n\n    function traverseEnterLeave(from, to, fn, argFrom, argTo) {\n      var common = from && to ? getLowestCommonAncestor(from, to) : null;\n      var pathFrom = [];\n\n      while (from && from !== common) {\n        pathFrom.push(from);\n        from = getParent(from);\n      }\n\n      var pathTo = [];\n\n      while (to && to !== common) {\n        pathTo.push(to);\n        to = getParent(to);\n      }\n\n      var i;\n\n      for (i = 0; i < pathFrom.length; i++) {\n        fn(pathFrom[i], 'bubbled', argFrom);\n      }\n\n      for (i = pathTo.length; i-- > 0;) {\n        fn(pathTo[i], 'captured', argTo);\n      }\n    }\n\n    var ReactTreeTraversal = {\n      isAncestor: isAncestor,\n      getLowestCommonAncestor: getLowestCommonAncestor,\n      getParentInstance: getParentInstance,\n      traverseTwoPhase: traverseTwoPhase,\n      traverseEnterLeave: traverseEnterLeave\n    };\n    var getListener = EventPluginHub_1.getListener;\n    {\n      var warning$29 = require$$0;\n    }\n    /**\n     * Some event types have a notion of different registration names for different\n     * \"phases\" of propagation. This finds listeners by a given phase.\n     */\n\n    function listenerAtPhase(inst, event, propagationPhase) {\n      var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n      return getListener(inst, registrationName);\n    }\n    /**\n     * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n     * here, allows us to not have to bind or create functions for each event.\n     * Mutating the event's members allows us to not have to create a wrapping\n     * \"dispatch\" object that pairs the event with the listener.\n     */\n\n\n    function accumulateDirectionalDispatches(inst, phase, event) {\n      {\n        warning$29(inst, 'Dispatching inst must not be null');\n      }\n      var listener = listenerAtPhase(inst, event, phase);\n\n      if (listener) {\n        event._dispatchListeners = accumulateInto_1(event._dispatchListeners, listener);\n        event._dispatchInstances = accumulateInto_1(event._dispatchInstances, inst);\n      }\n    }\n    /**\n     * Collect dispatches (must be entirely collected before dispatching - see unit\n     * tests). Lazily allocate the array to conserve memory.  We must loop through\n     * each event and perform the traversal for each one. We cannot perform a\n     * single traversal for the entire collection of events because each event may\n     * have a different target.\n     */\n\n\n    function accumulateTwoPhaseDispatchesSingle(event) {\n      if (event && event.dispatchConfig.phasedRegistrationNames) {\n        ReactTreeTraversal.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n      }\n    }\n    /**\n     * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n     */\n\n\n    function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n      if (event && event.dispatchConfig.phasedRegistrationNames) {\n        var targetInst = event._targetInst;\n        var parentInst = targetInst ? ReactTreeTraversal.getParentInstance(targetInst) : null;\n        ReactTreeTraversal.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n      }\n    }\n    /**\n     * Accumulates without regard to direction, does not look for phased\n     * registration names. Same as `accumulateDirectDispatchesSingle` but without\n     * requiring that the `dispatchMarker` be the same as the dispatched ID.\n     */\n\n\n    function accumulateDispatches(inst, ignoredDirection, event) {\n      if (inst && event && event.dispatchConfig.registrationName) {\n        var registrationName = event.dispatchConfig.registrationName;\n        var listener = getListener(inst, registrationName);\n\n        if (listener) {\n          event._dispatchListeners = accumulateInto_1(event._dispatchListeners, listener);\n          event._dispatchInstances = accumulateInto_1(event._dispatchInstances, inst);\n        }\n      }\n    }\n    /**\n     * Accumulates dispatches on an `SyntheticEvent`, but only for the\n     * `dispatchMarker`.\n     * @param {SyntheticEvent} event\n     */\n\n\n    function accumulateDirectDispatchesSingle(event) {\n      if (event && event.dispatchConfig.registrationName) {\n        accumulateDispatches(event._targetInst, null, event);\n      }\n    }\n\n    function accumulateTwoPhaseDispatches(events) {\n      forEachAccumulated_1(events, accumulateTwoPhaseDispatchesSingle);\n    }\n\n    function accumulateTwoPhaseDispatchesSkipTarget(events) {\n      forEachAccumulated_1(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n    }\n\n    function accumulateEnterLeaveDispatches(leave, enter, from, to) {\n      ReactTreeTraversal.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n    }\n\n    function accumulateDirectDispatches(events) {\n      forEachAccumulated_1(events, accumulateDirectDispatchesSingle);\n    }\n    /**\n     * A small set of propagation patterns, each of which will accept a small amount\n     * of information, and generate a set of \"dispatch ready event objects\" - which\n     * are sets of events that have already been annotated with a set of dispatched\n     * listener functions/ids. The API is designed this way to discourage these\n     * propagation strategies from actually executing the dispatches, since we\n     * always want to collect the entire set of dispatches before executing even a\n     * single one.\n     *\n     * @constructor EventPropagators\n     */\n\n\n    var EventPropagators = {\n      accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n      accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n      accumulateDirectDispatches: accumulateDirectDispatches,\n      accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n    };\n    var EventPropagators_1 = EventPropagators;\n    /**\n     * This helper object stores information about text content of a target node,\n     * allowing comparison of content before and after a given event.\n     *\n     * Identify the node where selection currently begins, then observe\n     * both its text content and its current position in the DOM. Since the\n     * browser may natively replace the target node during composition, we can\n     * use its position to find its replacement.\n     * \n     *\n     */\n\n    var compositionState = {\n      _root: null,\n      _startText: null,\n      _fallbackText: null\n    };\n    var FallbackCompositionState = {\n      initialize: function initialize(nativeEventTarget) {\n        compositionState._root = nativeEventTarget;\n        compositionState._startText = FallbackCompositionState.getText();\n        return true;\n      },\n      reset: function reset() {\n        compositionState._root = null;\n        compositionState._startText = null;\n        compositionState._fallbackText = null;\n      },\n      getData: function getData() {\n        if (compositionState._fallbackText) {\n          return compositionState._fallbackText;\n        }\n\n        var start;\n        var startValue = compositionState._startText;\n        var startLength = startValue.length;\n        var end;\n        var endValue = FallbackCompositionState.getText();\n        var endLength = endValue.length;\n\n        for (start = 0; start < startLength; start++) {\n          if (startValue[start] !== endValue[start]) {\n            break;\n          }\n        }\n\n        var minEnd = startLength - start;\n\n        for (end = 1; end <= minEnd; end++) {\n          if (startValue[startLength - end] !== endValue[endLength - end]) {\n            break;\n          }\n        }\n\n        var sliceTail = end > 1 ? 1 - end : undefined;\n        compositionState._fallbackText = endValue.slice(start, sliceTail);\n        return compositionState._fallbackText;\n      },\n      getText: function getText() {\n        if ('value' in compositionState._root) {\n          return compositionState._root.value;\n        }\n\n        return compositionState._root[getTextContentAccessor_1()];\n      }\n    };\n    var FallbackCompositionState_1 = FallbackCompositionState;\n    var didWarnForAddedNewProperty = false;\n    var isProxySupported = typeof Proxy === 'function';\n    var EVENT_POOL_SIZE = 10;\n    {\n      var warning$30 = require$$0;\n    }\n    var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];\n    /**\n     * @interface Event\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n    var EventInterface = {\n      type: null,\n      target: null,\n      // currentTarget is set when dispatching; no use in copying it here\n      currentTarget: emptyFunction.thatReturnsNull,\n      eventPhase: null,\n      bubbles: null,\n      cancelable: null,\n      timeStamp: function timeStamp(event) {\n        return event.timeStamp || Date.now();\n      },\n      defaultPrevented: null,\n      isTrusted: null\n    };\n    /**\n     * Synthetic events are dispatched by event plugins, typically in response to a\n     * top-level event delegation handler.\n     *\n     * These systems should generally use pooling to reduce the frequency of garbage\n     * collection. The system should check `isPersistent` to determine whether the\n     * event should be released into the pool after being dispatched. Users that\n     * need a persisted event should invoke `persist`.\n     *\n     * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n     * normalizing browser quirks. Subclasses do not necessarily have to implement a\n     * DOM interface; custom application-specific events can also subclass this.\n     *\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {*} targetInst Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @param {DOMEventTarget} nativeEventTarget Target node.\n     */\n\n    function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n      {\n        // these have a getter/setter for warnings\n        delete this.nativeEvent;\n        delete this.preventDefault;\n        delete this.stopPropagation;\n      }\n      this.dispatchConfig = dispatchConfig;\n      this._targetInst = targetInst;\n      this.nativeEvent = nativeEvent;\n      var Interface = this.constructor.Interface;\n\n      for (var propName in Interface) {\n        if (!Interface.hasOwnProperty(propName)) {\n          continue;\n        }\n\n        {\n          delete this[propName]; // this has a getter/setter for warnings\n        }\n        var normalize = Interface[propName];\n\n        if (normalize) {\n          this[propName] = normalize(nativeEvent);\n        } else {\n          if (propName === 'target') {\n            this.target = nativeEventTarget;\n          } else {\n            this[propName] = nativeEvent[propName];\n          }\n        }\n      }\n\n      var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n\n      if (defaultPrevented) {\n        this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n      } else {\n        this.isDefaultPrevented = emptyFunction.thatReturnsFalse;\n      }\n\n      this.isPropagationStopped = emptyFunction.thatReturnsFalse;\n      return this;\n    }\n\n    _assign(SyntheticEvent.prototype, {\n      preventDefault: function preventDefault() {\n        this.defaultPrevented = true;\n        var event = this.nativeEvent;\n\n        if (!event) {\n          return;\n        }\n\n        if (event.preventDefault) {\n          event.preventDefault();\n        } else if (typeof event.returnValue !== 'unknown') {\n          event.returnValue = false;\n        }\n\n        this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n      },\n      stopPropagation: function stopPropagation() {\n        var event = this.nativeEvent;\n\n        if (!event) {\n          return;\n        }\n\n        if (event.stopPropagation) {\n          event.stopPropagation();\n        } else if (typeof event.cancelBubble !== 'unknown') {\n          // The ChangeEventPlugin registers a \"propertychange\" event for\n          // IE. This event does not support bubbling or cancelling, and\n          // any references to cancelBubble throw \"Member not found\".  A\n          // typeof check of \"unknown\" circumvents this issue (and is also\n          // IE specific).\n          event.cancelBubble = true;\n        }\n\n        this.isPropagationStopped = emptyFunction.thatReturnsTrue;\n      },\n\n      /**\n       * We release all dispatched `SyntheticEvent`s after each event loop, adding\n       * them back into the pool. This allows a way to hold onto a reference that\n       * won't be added back into the pool.\n       */\n      persist: function persist() {\n        this.isPersistent = emptyFunction.thatReturnsTrue;\n      },\n\n      /**\n       * Checks if this event should be released back into the pool.\n       *\n       * @return {boolean} True if this should not be released, false otherwise.\n       */\n      isPersistent: emptyFunction.thatReturnsFalse,\n\n      /**\n       * `PooledClass` looks for `destructor` on each instance it releases.\n       */\n      destructor: function destructor() {\n        var Interface = this.constructor.Interface;\n\n        for (var propName in Interface) {\n          {\n            Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n          }\n        }\n\n        for (var i = 0; i < shouldBeReleasedProperties.length; i++) {\n          this[shouldBeReleasedProperties[i]] = null;\n        }\n\n        {\n          Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n          Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));\n          Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));\n        }\n      }\n    });\n\n    SyntheticEvent.Interface = EventInterface;\n    /**\n     * Helper to reduce boilerplate when creating subclasses.\n     *\n     * @param {function} Class\n     * @param {?object} Interface\n     */\n\n    SyntheticEvent.augmentClass = function (Class, Interface) {\n      var Super = this;\n\n      var E = function E() {};\n\n      E.prototype = Super.prototype;\n      var prototype = new E();\n\n      _assign(prototype, Class.prototype);\n\n      Class.prototype = prototype;\n      Class.prototype.constructor = Class;\n      Class.Interface = _assign({}, Super.Interface, Interface);\n      Class.augmentClass = Super.augmentClass;\n      addEventPoolingTo(Class);\n    };\n    /** Proxying after everything set on SyntheticEvent\n      * to resolve Proxy issue on some WebKit browsers\n      * in which some Event properties are set to undefined (GH#10010)\n      */\n\n\n    {\n      if (isProxySupported) {\n        /*eslint-disable no-func-assign */\n        SyntheticEvent = new Proxy(SyntheticEvent, {\n          construct: function construct(target, args) {\n            return this.apply(target, Object.create(target.prototype), args);\n          },\n          apply: function apply(constructor, that, args) {\n            return new Proxy(constructor.apply(that, args), {\n              set: function set(target, prop, value) {\n                if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {\n                  warning$30(didWarnForAddedNewProperty || target.isPersistent(), \"This synthetic event is reused for performance reasons. If you're \" + \"seeing this, you're adding a new property in the synthetic event object. \" + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');\n                  didWarnForAddedNewProperty = true;\n                }\n\n                target[prop] = value;\n                return true;\n              }\n            });\n          }\n        });\n        /*eslint-enable no-func-assign */\n      }\n    }\n    addEventPoolingTo(SyntheticEvent);\n    var SyntheticEvent_1 = SyntheticEvent;\n    /**\n      * Helper to nullify syntheticEvent instance properties when destructing\n      *\n      * @param {String} propName\n      * @param {?object} getVal\n      * @return {object} defineProperty object\n      */\n\n    function getPooledWarningPropertyDefinition(propName, getVal) {\n      var isFunction = typeof getVal === 'function';\n      return {\n        configurable: true,\n        set: set,\n        get: get\n      };\n\n      function set(val) {\n        var action = isFunction ? 'setting the method' : 'setting the property';\n        warn(action, 'This is effectively a no-op');\n        return val;\n      }\n\n      function get() {\n        var action = isFunction ? 'accessing the method' : 'accessing the property';\n        var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n        warn(action, result);\n        return getVal;\n      }\n\n      function warn(action, result) {\n        var warningCondition = false;\n        warning$30(warningCondition, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);\n      }\n    }\n\n    function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n      var EventConstructor = this;\n\n      if (EventConstructor.eventPool.length) {\n        var instance = EventConstructor.eventPool.pop();\n        EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n        return instance;\n      }\n\n      return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n    }\n\n    function releasePooledEvent(event) {\n      var EventConstructor = this;\n      !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;\n      event.destructor();\n\n      if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n        EventConstructor.eventPool.push(event);\n      }\n    }\n\n    function addEventPoolingTo(EventConstructor) {\n      EventConstructor.eventPool = [];\n      EventConstructor.getPooled = getPooledEvent;\n      EventConstructor.release = releasePooledEvent;\n    }\n    /**\n     * @interface Event\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n     */\n\n\n    var CompositionEventInterface = {\n      data: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticUIEvent}\n     */\n\n    function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticEvent_1.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);\n    var SyntheticCompositionEvent_1 = SyntheticCompositionEvent;\n    /**\n     * @interface Event\n     * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n     *      /#events-inputevents\n     */\n\n    var InputEventInterface = {\n      data: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticUIEvent}\n     */\n\n    function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticEvent_1.augmentClass(SyntheticInputEvent, InputEventInterface);\n    var SyntheticInputEvent_1 = SyntheticInputEvent;\n    var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\n\n    var START_KEYCODE = 229;\n    var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;\n    var documentMode = null;\n\n    if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {\n      documentMode = document.documentMode;\n    } // Webkit offers a very useful `textInput` event that can be used to\n    // directly represent `beforeInput`. The IE `textinput` event is not as\n    // useful, so we don't use it.\n\n\n    var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto(); // In IE9+, we have access to composition events, but the data supplied\n    // by the native compositionend event may be incorrect. Japanese ideographic\n    // spaces, for instance (\\u3000) are not recorded correctly.\n\n    var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n    /**\n     * Opera <= 12 includes TextEvent in window, but does not fire\n     * text input events. Rely on keypress instead.\n     */\n\n    function isPresto() {\n      var opera = window.opera;\n      return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;\n    }\n\n    var SPACEBAR_CODE = 32;\n    var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE); // Events and their corresponding property names.\n\n    var eventTypes = {\n      beforeInput: {\n        phasedRegistrationNames: {\n          bubbled: 'onBeforeInput',\n          captured: 'onBeforeInputCapture'\n        },\n        dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']\n      },\n      compositionEnd: {\n        phasedRegistrationNames: {\n          bubbled: 'onCompositionEnd',\n          captured: 'onCompositionEndCapture'\n        },\n        dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n      },\n      compositionStart: {\n        phasedRegistrationNames: {\n          bubbled: 'onCompositionStart',\n          captured: 'onCompositionStartCapture'\n        },\n        dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n      },\n      compositionUpdate: {\n        phasedRegistrationNames: {\n          bubbled: 'onCompositionUpdate',\n          captured: 'onCompositionUpdateCapture'\n        },\n        dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']\n      }\n    }; // Track whether we've ever handled a keypress on the space key.\n\n    var hasSpaceKeypress = false;\n    /**\n     * Return whether a native keypress event is assumed to be a command.\n     * This is required because Firefox fires `keypress` events for key commands\n     * (cut, copy, select-all, etc.) even though no character is inserted.\n     */\n\n    function isKeypressCommand(nativeEvent) {\n      return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n      !(nativeEvent.ctrlKey && nativeEvent.altKey);\n    }\n    /**\n     * Translate native top level events into event types.\n     *\n     * @param {string} topLevelType\n     * @return {object}\n     */\n\n\n    function getCompositionEventType(topLevelType) {\n      switch (topLevelType) {\n        case 'topCompositionStart':\n          return eventTypes.compositionStart;\n\n        case 'topCompositionEnd':\n          return eventTypes.compositionEnd;\n\n        case 'topCompositionUpdate':\n          return eventTypes.compositionUpdate;\n      }\n    }\n    /**\n     * Does our fallback best-guess model think this event signifies that\n     * composition has begun?\n     *\n     * @param {string} topLevelType\n     * @param {object} nativeEvent\n     * @return {boolean}\n     */\n\n\n    function isFallbackCompositionStart(topLevelType, nativeEvent) {\n      return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;\n    }\n    /**\n     * Does our fallback mode think that this event is the end of composition?\n     *\n     * @param {string} topLevelType\n     * @param {object} nativeEvent\n     * @return {boolean}\n     */\n\n\n    function isFallbackCompositionEnd(topLevelType, nativeEvent) {\n      switch (topLevelType) {\n        case 'topKeyUp':\n          // Command keys insert or clear IME input.\n          return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n\n        case 'topKeyDown':\n          // Expect IME keyCode on each keydown. If we get any other\n          // code we must have exited earlier.\n          return nativeEvent.keyCode !== START_KEYCODE;\n\n        case 'topKeyPress':\n        case 'topMouseDown':\n        case 'topBlur':\n          // Events are not possible without cancelling IME.\n          return true;\n\n        default:\n          return false;\n      }\n    }\n    /**\n     * Google Input Tools provides composition data via a CustomEvent,\n     * with the `data` property populated in the `detail` object. If this\n     * is available on the event object, use it. If not, this is a plain\n     * composition event and we have nothing special to extract.\n     *\n     * @param {object} nativeEvent\n     * @return {?string}\n     */\n\n\n    function getDataFromCustomEvent(nativeEvent) {\n      var detail = nativeEvent.detail;\n\n      if (typeof detail === 'object' && 'data' in detail) {\n        return detail.data;\n      }\n\n      return null;\n    } // Track the current IME composition status, if any.\n\n\n    var isComposing = false;\n    /**\n     * @return {?object} A SyntheticCompositionEvent.\n     */\n\n    function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n      var eventType;\n      var fallbackData;\n\n      if (canUseCompositionEvent) {\n        eventType = getCompositionEventType(topLevelType);\n      } else if (!isComposing) {\n        if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n          eventType = eventTypes.compositionStart;\n        }\n      } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n        eventType = eventTypes.compositionEnd;\n      }\n\n      if (!eventType) {\n        return null;\n      }\n\n      if (useFallbackCompositionData) {\n        // The current composition is stored statically and must not be\n        // overwritten while composition continues.\n        if (!isComposing && eventType === eventTypes.compositionStart) {\n          isComposing = FallbackCompositionState_1.initialize(nativeEventTarget);\n        } else if (eventType === eventTypes.compositionEnd) {\n          if (isComposing) {\n            fallbackData = FallbackCompositionState_1.getData();\n          }\n        }\n      }\n\n      var event = SyntheticCompositionEvent_1.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);\n\n      if (fallbackData) {\n        // Inject data generated from fallback path into the synthetic event.\n        // This matches the property of native CompositionEventInterface.\n        event.data = fallbackData;\n      } else {\n        var customData = getDataFromCustomEvent(nativeEvent);\n\n        if (customData !== null) {\n          event.data = customData;\n        }\n      }\n\n      EventPropagators_1.accumulateTwoPhaseDispatches(event);\n      return event;\n    }\n    /**\n     * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.\n     * @param {object} nativeEvent Native browser event.\n     * @return {?string} The string corresponding to this `beforeInput` event.\n     */\n\n\n    function getNativeBeforeInputChars(topLevelType, nativeEvent) {\n      switch (topLevelType) {\n        case 'topCompositionEnd':\n          return getDataFromCustomEvent(nativeEvent);\n\n        case 'topKeyPress':\n          /**\n           * If native `textInput` events are available, our goal is to make\n           * use of them. However, there is a special case: the spacebar key.\n           * In Webkit, preventing default on a spacebar `textInput` event\n           * cancels character insertion, but it *also* causes the browser\n           * to fall back to its default spacebar behavior of scrolling the\n           * page.\n           *\n           * Tracking at:\n           * https://code.google.com/p/chromium/issues/detail?id=355103\n           *\n           * To avoid this issue, use the keypress event as if no `textInput`\n           * event is available.\n           */\n          var which = nativeEvent.which;\n\n          if (which !== SPACEBAR_CODE) {\n            return null;\n          }\n\n          hasSpaceKeypress = true;\n          return SPACEBAR_CHAR;\n\n        case 'topTextInput':\n          // Record the characters to be added to the DOM.\n          var chars = nativeEvent.data; // If it's a spacebar character, assume that we have already handled\n          // it at the keypress level and bail immediately. Android Chrome\n          // doesn't give us keycodes, so we need to blacklist it.\n\n          if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n            return null;\n          }\n\n          return chars;\n\n        default:\n          // For other native event types, do nothing.\n          return null;\n      }\n    }\n    /**\n     * For browsers that do not provide the `textInput` event, extract the\n     * appropriate string to use for SyntheticInputEvent.\n     *\n     * @param {string} topLevelType Record from `BrowserEventConstants`.\n     * @param {object} nativeEvent Native browser event.\n     * @return {?string} The fallback string for this `beforeInput` event.\n     */\n\n\n    function getFallbackBeforeInputChars(topLevelType, nativeEvent) {\n      // If we are currently composing (IME) and using a fallback to do so,\n      // try to extract the composed characters from the fallback object.\n      // If composition event is available, we extract a string only at\n      // compositionevent, otherwise extract it at fallback events.\n      if (isComposing) {\n        if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n          var chars = FallbackCompositionState_1.getData();\n          FallbackCompositionState_1.reset();\n          isComposing = false;\n          return chars;\n        }\n\n        return null;\n      }\n\n      switch (topLevelType) {\n        case 'topPaste':\n          // If a paste event occurs after a keypress, throw out the input\n          // chars. Paste events should not lead to BeforeInput events.\n          return null;\n\n        case 'topKeyPress':\n          /**\n           * As of v27, Firefox may fire keypress events even when no character\n           * will be inserted. A few possibilities:\n           *\n           * - `which` is `0`. Arrow keys, Esc key, etc.\n           *\n           * - `which` is the pressed key code, but no char is available.\n           *   Ex: 'AltGr + d` in Polish. There is no modified character for\n           *   this key combination and no character is inserted into the\n           *   document, but FF fires the keypress for char code `100` anyway.\n           *   No `input` event will occur.\n           *\n           * - `which` is the pressed key code, but a command combination is\n           *   being used. Ex: `Cmd+C`. No character is inserted, and no\n           *   `input` event will occur.\n           */\n          if (!isKeypressCommand(nativeEvent)) {\n            // IE fires the `keypress` event when a user types an emoji via\n            // Touch keyboard of Windows.  In such a case, the `char` property\n            // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n            // is 2, the property `which` does not represent an emoji correctly.\n            // In such a case, we directly return the `char` property instead of\n            // using `which`.\n            if (nativeEvent.char && nativeEvent.char.length > 1) {\n              return nativeEvent.char;\n            } else if (nativeEvent.which) {\n              return String.fromCharCode(nativeEvent.which);\n            }\n          }\n\n          return null;\n\n        case 'topCompositionEnd':\n          return useFallbackCompositionData ? null : nativeEvent.data;\n\n        default:\n          return null;\n      }\n    }\n    /**\n     * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n     * `textInput` or fallback behavior.\n     *\n     * @return {?object} A SyntheticInputEvent.\n     */\n\n\n    function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n      var chars;\n\n      if (canUseTextInputEvent) {\n        chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n      } else {\n        chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n      } // If no characters are being inserted, no BeforeInput event should\n      // be fired.\n\n\n      if (!chars) {\n        return null;\n      }\n\n      var event = SyntheticInputEvent_1.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);\n      event.data = chars;\n      EventPropagators_1.accumulateTwoPhaseDispatches(event);\n      return event;\n    }\n    /**\n     * Create an `onBeforeInput` event to match\n     * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n     *\n     * This event plugin is based on the native `textInput` event\n     * available in Chrome, Safari, Opera, and IE. This event fires after\n     * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n     *\n     * `beforeInput` is spec'd but not implemented in any browsers, and\n     * the `input` event does not provide any useful information about what has\n     * actually been added, contrary to the spec. Thus, `textInput` is the best\n     * available event to identify the characters that have actually been inserted\n     * into the target node.\n     *\n     * This plugin is also responsible for emitting `composition` events, thus\n     * allowing us to share composition fallback code for both `beforeInput` and\n     * `composition` event types.\n     */\n\n\n    var BeforeInputEventPlugin = {\n      eventTypes: eventTypes,\n      extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];\n      }\n    };\n    var BeforeInputEventPlugin_1 = BeforeInputEventPlugin;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule isTextInputElement\n     * \n     */\n\n    /**\n     * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n     */\n\n    var supportedInputTypes = {\n      color: true,\n      date: true,\n      datetime: true,\n      'datetime-local': true,\n      email: true,\n      month: true,\n      number: true,\n      password: true,\n      range: true,\n      search: true,\n      tel: true,\n      text: true,\n      time: true,\n      url: true,\n      week: true\n    };\n\n    function isTextInputElement(elem) {\n      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n\n      if (nodeName === 'input') {\n        return !!supportedInputTypes[elem.type];\n      }\n\n      if (nodeName === 'textarea') {\n        return true;\n      }\n\n      return false;\n    }\n\n    var isTextInputElement_1 = isTextInputElement;\n    var eventTypes$1 = {\n      change: {\n        phasedRegistrationNames: {\n          bubbled: 'onChange',\n          captured: 'onChangeCapture'\n        },\n        dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']\n      }\n    };\n\n    function createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n      var event = SyntheticEvent_1.getPooled(eventTypes$1.change, inst, nativeEvent, target);\n      event.type = 'change'; // Flag this event loop as needing state restore.\n\n      ReactControlledComponent_1.enqueueStateRestore(target);\n      EventPropagators_1.accumulateTwoPhaseDispatches(event);\n      return event;\n    }\n    /**\n     * For IE shims\n     */\n\n\n    var activeElement = null;\n    var activeElementInst = null;\n    /**\n     * SECTION: handle `change` event\n     */\n\n    function shouldUseChangeEvent(elem) {\n      var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n      return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n    }\n\n    function manualDispatchChangeEvent(nativeEvent) {\n      var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget_1(nativeEvent)); // If change and propertychange bubbled, we'd just bind to it like all the\n      // other events and have it go through ReactBrowserEventEmitter. Since it\n      // doesn't, we manually listen for the events and so we have to enqueue and\n      // process the abstract event manually.\n      //\n      // Batching is necessary here in order to ensure that all event handlers run\n      // before the next rerender (including event handlers attached to ancestor\n      // elements instead of directly on the input). Without this, controlled\n      // components don't work properly in conjunction with event bubbling because\n      // the component is rerendered and the value reverted before all the event\n      // handlers can run. See https://github.com/facebook/react/issues/708.\n\n      ReactGenericBatching_1.batchedUpdates(runEventInBatch, event);\n    }\n\n    function runEventInBatch(event) {\n      EventPluginHub_1.enqueueEvents(event);\n      EventPluginHub_1.processEventQueue(false);\n    }\n\n    function getInstIfValueChanged(targetInst) {\n      var targetNode = ReactDOMComponentTree_1.getNodeFromInstance(targetInst);\n\n      if (inputValueTracking_1.updateValueIfChanged(targetNode)) {\n        return targetInst;\n      }\n    }\n\n    function getTargetInstForChangeEvent(topLevelType, targetInst) {\n      if (topLevelType === 'topChange') {\n        return targetInst;\n      }\n    }\n    /**\n     * SECTION: handle `input` event\n     */\n\n\n    var isInputEventSupported = false;\n\n    if (ExecutionEnvironment.canUseDOM) {\n      // IE9 claims to support the input event but fails to trigger it when\n      // deleting text, so we ignore its input events.\n      isInputEventSupported = isEventSupported_1('input') && (!document.documentMode || document.documentMode > 9);\n    }\n    /**\n     * (For IE <=9) Starts tracking propertychange events on the passed-in element\n     * and override the value property so that we can distinguish user events from\n     * value changes in JS.\n     */\n\n\n    function startWatchingForValueChange(target, targetInst) {\n      activeElement = target;\n      activeElementInst = targetInst;\n      activeElement.attachEvent('onpropertychange', handlePropertyChange);\n    }\n    /**\n     * (For IE <=9) Removes the event listeners from the currently-tracked element,\n     * if any exists.\n     */\n\n\n    function stopWatchingForValueChange() {\n      if (!activeElement) {\n        return;\n      }\n\n      activeElement.detachEvent('onpropertychange', handlePropertyChange);\n      activeElement = null;\n      activeElementInst = null;\n    }\n    /**\n     * (For IE <=9) Handles a propertychange event, sending a `change` event if\n     * the value of the active element has changed.\n     */\n\n\n    function handlePropertyChange(nativeEvent) {\n      if (nativeEvent.propertyName !== 'value') {\n        return;\n      }\n\n      if (getInstIfValueChanged(activeElementInst)) {\n        manualDispatchChangeEvent(nativeEvent);\n      }\n    }\n\n    function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n      if (topLevelType === 'topFocus') {\n        // In IE9, propertychange fires for most input events but is buggy and\n        // doesn't fire when text is deleted, but conveniently, selectionchange\n        // appears to fire in all of the remaining cases so we catch those and\n        // forward the event if the value has changed\n        // In either case, we don't want to call the event handler if the value\n        // is changed from JS so we redefine a setter for `.value` that updates\n        // our activeElementValue variable, allowing us to ignore those changes\n        //\n        // stopWatching() should be a noop here but we call it just in case we\n        // missed a blur event somehow.\n        stopWatchingForValueChange();\n        startWatchingForValueChange(target, targetInst);\n      } else if (topLevelType === 'topBlur') {\n        stopWatchingForValueChange();\n      }\n    } // For IE8 and IE9.\n\n\n    function getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n      if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {\n        // On the selectionchange event, the target is just document which isn't\n        // helpful for us so just check activeElement instead.\n        //\n        // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n        // propertychange on the first input event after setting `value` from a\n        // script and fires only keydown, keypress, keyup. Catching keyup usually\n        // gets it and catching keydown lets us fire an event for the first\n        // keystroke if user does a key repeat (it'll be a little delayed: right\n        // before the second keystroke). Other input methods (e.g., paste) seem to\n        // fire selectionchange normally.\n        return getInstIfValueChanged(activeElementInst);\n      }\n    }\n    /**\n     * SECTION: handle `click` event\n     */\n\n\n    function shouldUseClickEvent(elem) {\n      // Use the `click` event to detect changes to checkbox and radio inputs.\n      // This approach works across all browsers, whereas `change` does not fire\n      // until `blur` in IE8.\n      var nodeName = elem.nodeName;\n      return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n    }\n\n    function getTargetInstForClickEvent(topLevelType, targetInst) {\n      if (topLevelType === 'topClick') {\n        return getInstIfValueChanged(targetInst);\n      }\n    }\n\n    function getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {\n      if (topLevelType === 'topInput' || topLevelType === 'topChange') {\n        return getInstIfValueChanged(targetInst);\n      }\n    }\n\n    function handleControlledInputBlur(inst, node) {\n      // TODO: In IE, inst is occasionally null. Why?\n      if (inst == null) {\n        return;\n      } // Fiber and ReactDOM keep wrapper state in separate places\n\n\n      var state = inst._wrapperState || node._wrapperState;\n\n      if (!state || !state.controlled || node.type !== 'number') {\n        return;\n      } // If controlled, assign the value attribute to the current value on blur\n\n\n      var value = '' + node.value;\n\n      if (node.getAttribute('value') !== value) {\n        node.setAttribute('value', value);\n      }\n    }\n    /**\n     * This plugin creates an `onChange` event that normalizes change events\n     * across form elements. This event fires at a time when it's possible to\n     * change the element's value without seeing a flicker.\n     *\n     * Supported elements are:\n     * - input (see `isTextInputElement`)\n     * - textarea\n     * - select\n     */\n\n\n    var ChangeEventPlugin = {\n      eventTypes: eventTypes$1,\n      _isInputEventSupported: isInputEventSupported,\n      extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        var targetNode = targetInst ? ReactDOMComponentTree_1.getNodeFromInstance(targetInst) : window;\n        var getTargetInstFunc, handleEventFunc;\n\n        if (shouldUseChangeEvent(targetNode)) {\n          getTargetInstFunc = getTargetInstForChangeEvent;\n        } else if (isTextInputElement_1(targetNode)) {\n          if (isInputEventSupported) {\n            getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n          } else {\n            getTargetInstFunc = getTargetInstForInputEventPolyfill;\n            handleEventFunc = handleEventsForInputEventPolyfill;\n          }\n        } else if (shouldUseClickEvent(targetNode)) {\n          getTargetInstFunc = getTargetInstForClickEvent;\n        }\n\n        if (getTargetInstFunc) {\n          var inst = getTargetInstFunc(topLevelType, targetInst);\n\n          if (inst) {\n            var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n            return event;\n          }\n        }\n\n        if (handleEventFunc) {\n          handleEventFunc(topLevelType, targetNode, targetInst);\n        } // When blurring, set the value attribute for number inputs\n\n\n        if (topLevelType === 'topBlur') {\n          handleControlledInputBlur(targetInst, targetNode);\n        }\n      }\n    };\n    var ChangeEventPlugin_1 = ChangeEventPlugin;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule DOMEventPluginOrder\n     */\n\n    /**\n     * Module that is injectable into `EventPluginHub`, that specifies a\n     * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n     * plugins, without having to package every one of them. This is better than\n     * having plugins be ordered in the same order that they are injected because\n     * that ordering would be influenced by the packaging order.\n     * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n     * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n     */\n\n    var DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];\n    var DOMEventPluginOrder_1 = DOMEventPluginOrder;\n    /**\n     * @interface UIEvent\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n    var UIEventInterface = {\n      view: function view(event) {\n        if (event.view) {\n          return event.view;\n        }\n\n        var target = getEventTarget_1(event);\n\n        if (target.window === target) {\n          // target is a window object\n          return target;\n        }\n\n        var doc = target.ownerDocument; // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n\n        if (doc) {\n          return doc.defaultView || doc.parentWindow;\n        } else {\n          return window;\n        }\n      },\n      detail: function detail(event) {\n        return event.detail || 0;\n      }\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticEvent}\n     */\n\n    function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticEvent_1.augmentClass(SyntheticUIEvent, UIEventInterface);\n    var SyntheticUIEvent_1 = SyntheticUIEvent;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule getEventModifierState\n     */\n\n    /**\n     * Translation from modifier key to the associated property in the event.\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n     */\n\n    var modifierKeyToProp = {\n      Alt: 'altKey',\n      Control: 'ctrlKey',\n      Meta: 'metaKey',\n      Shift: 'shiftKey'\n    }; // IE8 does not implement getModifierState so we simply map it to the only\n    // modifier keys exposed by the event itself, does not support Lock-keys.\n    // Currently, all major browsers except Chrome seems to support Lock-keys.\n\n    function modifierStateGetter(keyArg) {\n      var syntheticEvent = this;\n      var nativeEvent = syntheticEvent.nativeEvent;\n\n      if (nativeEvent.getModifierState) {\n        return nativeEvent.getModifierState(keyArg);\n      }\n\n      var keyProp = modifierKeyToProp[keyArg];\n      return keyProp ? !!nativeEvent[keyProp] : false;\n    }\n\n    function getEventModifierState(nativeEvent) {\n      return modifierStateGetter;\n    }\n\n    var getEventModifierState_1 = getEventModifierState;\n    /**\n     * @interface MouseEvent\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n    var MouseEventInterface = {\n      screenX: null,\n      screenY: null,\n      clientX: null,\n      clientY: null,\n      pageX: null,\n      pageY: null,\n      ctrlKey: null,\n      shiftKey: null,\n      altKey: null,\n      metaKey: null,\n      getModifierState: getEventModifierState_1,\n      button: null,\n      buttons: null,\n      relatedTarget: function relatedTarget(event) {\n        return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);\n      }\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticUIEvent}\n     */\n\n    function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticUIEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticUIEvent_1.augmentClass(SyntheticMouseEvent, MouseEventInterface);\n    var SyntheticMouseEvent_1 = SyntheticMouseEvent;\n    var eventTypes$2 = {\n      mouseEnter: {\n        registrationName: 'onMouseEnter',\n        dependencies: ['topMouseOut', 'topMouseOver']\n      },\n      mouseLeave: {\n        registrationName: 'onMouseLeave',\n        dependencies: ['topMouseOut', 'topMouseOver']\n      }\n    };\n    var EnterLeaveEventPlugin = {\n      eventTypes: eventTypes$2,\n\n      /**\n       * For almost every interaction we care about, there will be both a top-level\n       * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n       * we do not extract duplicate events. However, moving the mouse into the\n       * browser from outside will not fire a `mouseout` event. In this case, we use\n       * the `mouseover` top-level event.\n       */\n      extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n          return null;\n        }\n\n        if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {\n          // Must not be a mouse in or mouse out - ignoring.\n          return null;\n        }\n\n        var win;\n\n        if (nativeEventTarget.window === nativeEventTarget) {\n          // `nativeEventTarget` is probably a window object.\n          win = nativeEventTarget;\n        } else {\n          // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n          var doc = nativeEventTarget.ownerDocument;\n\n          if (doc) {\n            win = doc.defaultView || doc.parentWindow;\n          } else {\n            win = window;\n          }\n        }\n\n        var from;\n        var to;\n\n        if (topLevelType === 'topMouseOut') {\n          from = targetInst;\n          var related = nativeEvent.relatedTarget || nativeEvent.toElement;\n          to = related ? ReactDOMComponentTree_1.getClosestInstanceFromNode(related) : null;\n        } else {\n          // Moving to a node from outside the window.\n          from = null;\n          to = targetInst;\n        }\n\n        if (from === to) {\n          // Nothing pertains to our managed components.\n          return null;\n        }\n\n        var fromNode = from == null ? win : ReactDOMComponentTree_1.getNodeFromInstance(from);\n        var toNode = to == null ? win : ReactDOMComponentTree_1.getNodeFromInstance(to);\n        var leave = SyntheticMouseEvent_1.getPooled(eventTypes$2.mouseLeave, from, nativeEvent, nativeEventTarget);\n        leave.type = 'mouseleave';\n        leave.target = fromNode;\n        leave.relatedTarget = toNode;\n        var enter = SyntheticMouseEvent_1.getPooled(eventTypes$2.mouseEnter, to, nativeEvent, nativeEventTarget);\n        enter.type = 'mouseenter';\n        enter.target = toNode;\n        enter.relatedTarget = fromNode;\n        EventPropagators_1.accumulateEnterLeaveDispatches(leave, enter, from, to);\n        return [leave, enter];\n      }\n    };\n    var EnterLeaveEventPlugin_1 = EnterLeaveEventPlugin;\n    var DOCUMENT_NODE$2 = HTMLNodeType_1.DOCUMENT_NODE;\n    var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n    var eventTypes$3 = {\n      select: {\n        phasedRegistrationNames: {\n          bubbled: 'onSelect',\n          captured: 'onSelectCapture'\n        },\n        dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']\n      }\n    };\n    var activeElement$1 = null;\n    var activeElementInst$1 = null;\n    var lastSelection = null;\n    var mouseDown = false; // Track whether all listeners exists for this plugin. If none exist, we do\n    // not extract events. See #3639.\n\n    var isListeningToAllDependencies = ReactBrowserEventEmitter_1.isListeningToAllDependencies;\n    /**\n     * Get an object which is a unique representation of the current selection.\n     *\n     * The return value will not be consistent across nodes or browsers, but\n     * two identical selections on the same node will return identical objects.\n     *\n     * @param {DOMElement} node\n     * @return {object}\n     */\n\n    function getSelection(node) {\n      if ('selectionStart' in node && ReactInputSelection_1.hasSelectionCapabilities(node)) {\n        return {\n          start: node.selectionStart,\n          end: node.selectionEnd\n        };\n      } else if (window.getSelection) {\n        var selection = window.getSelection();\n        return {\n          anchorNode: selection.anchorNode,\n          anchorOffset: selection.anchorOffset,\n          focusNode: selection.focusNode,\n          focusOffset: selection.focusOffset\n        };\n      }\n    }\n    /**\n     * Poll selection to see whether it's changed.\n     *\n     * @param {object} nativeEvent\n     * @return {?SyntheticEvent}\n     */\n\n\n    function constructSelectEvent(nativeEvent, nativeEventTarget) {\n      // Ensure we have the right element, and that the user is not dragging a\n      // selection (this matches native `select` event behavior). In HTML5, select\n      // fires only on input and textarea thus if there's no focused element we\n      // won't dispatch.\n      if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement()) {\n        return null;\n      } // Only fire when selection has actually changed.\n\n\n      var currentSelection = getSelection(activeElement$1);\n\n      if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n        lastSelection = currentSelection;\n        var syntheticEvent = SyntheticEvent_1.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);\n        syntheticEvent.type = 'select';\n        syntheticEvent.target = activeElement$1;\n        EventPropagators_1.accumulateTwoPhaseDispatches(syntheticEvent);\n        return syntheticEvent;\n      }\n\n      return null;\n    }\n    /**\n     * This plugin creates an `onSelect` event that normalizes select events\n     * across form elements.\n     *\n     * Supported elements are:\n     * - input (see `isTextInputElement`)\n     * - textarea\n     * - contentEditable\n     *\n     * This differs from native browser implementations in the following ways:\n     * - Fires on contentEditable fields as well as inputs.\n     * - Fires for collapsed selection.\n     * - Fires after user input.\n     */\n\n\n    var SelectEventPlugin = {\n      eventTypes: eventTypes$3,\n      extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : nativeEventTarget.nodeType === DOCUMENT_NODE$2 ? nativeEventTarget : nativeEventTarget.ownerDocument;\n\n        if (!doc || !isListeningToAllDependencies('onSelect', doc)) {\n          return null;\n        }\n\n        var targetNode = targetInst ? ReactDOMComponentTree_1.getNodeFromInstance(targetInst) : window;\n\n        switch (topLevelType) {\n          // Track the input node that has focus.\n          case 'topFocus':\n            if (isTextInputElement_1(targetNode) || targetNode.contentEditable === 'true') {\n              activeElement$1 = targetNode;\n              activeElementInst$1 = targetInst;\n              lastSelection = null;\n            }\n\n            break;\n\n          case 'topBlur':\n            activeElement$1 = null;\n            activeElementInst$1 = null;\n            lastSelection = null;\n            break;\n          // Don't fire the event while the user is dragging. This matches the\n          // semantics of the native select event.\n\n          case 'topMouseDown':\n            mouseDown = true;\n            break;\n\n          case 'topContextMenu':\n          case 'topMouseUp':\n            mouseDown = false;\n            return constructSelectEvent(nativeEvent, nativeEventTarget);\n          // Chrome and IE fire non-standard event when selection is changed (and\n          // sometimes when it hasn't). IE's event fires out of order with respect\n          // to key and input events on deletion, so we discard it.\n          //\n          // Firefox doesn't support selectionchange, so check selection status\n          // after each key entry. The selection changes after keydown and before\n          // keyup, but we check on keydown as well in the case of holding down a\n          // key, when multiple keydown events are fired but only one keyup is.\n          // This is also our approach for IE handling, for the reason above.\n\n          case 'topSelectionChange':\n            if (skipSelectionChangeEvent) {\n              break;\n            }\n\n          // falls through\n\n          case 'topKeyDown':\n          case 'topKeyUp':\n            return constructSelectEvent(nativeEvent, nativeEventTarget);\n        }\n\n        return null;\n      }\n    };\n    var SelectEventPlugin_1 = SelectEventPlugin;\n    /**\n     * @interface Event\n     * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n     */\n\n    var AnimationEventInterface = {\n      animationName: null,\n      elapsedTime: null,\n      pseudoElement: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticEvent}\n     */\n\n    function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticEvent_1.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);\n    var SyntheticAnimationEvent_1 = SyntheticAnimationEvent;\n    /**\n     * @interface Event\n     * @see http://www.w3.org/TR/clipboard-apis/\n     */\n\n    var ClipboardEventInterface = {\n      clipboardData: function clipboardData(event) {\n        return 'clipboardData' in event ? event.clipboardData : window.clipboardData;\n      }\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticUIEvent}\n     */\n\n    function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticEvent_1.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);\n    var SyntheticClipboardEvent_1 = SyntheticClipboardEvent;\n    /**\n     * @interface FocusEvent\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n    var FocusEventInterface = {\n      relatedTarget: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticUIEvent}\n     */\n\n    function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticUIEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticUIEvent_1.augmentClass(SyntheticFocusEvent, FocusEventInterface);\n    var SyntheticFocusEvent_1 = SyntheticFocusEvent;\n    /**\n     * Copyright (c) 2013-present, Facebook, Inc.\n     *\n     * This source code is licensed under the MIT license found in the\n     * LICENSE file in the root directory of this source tree.\n     *\n     * @providesModule getEventCharCode\n     */\n\n    /**\n     * `charCode` represents the actual \"character code\" and is safe to use with\n     * `String.fromCharCode`. As such, only keys that correspond to printable\n     * characters produce a valid `charCode`, the only exception to this is Enter.\n     * The Tab-key is considered non-printable and does not have a `charCode`,\n     * presumably because it does not produce a tab-character in browsers.\n     *\n     * @param {object} nativeEvent Native browser event.\n     * @return {number} Normalized `charCode` property.\n     */\n\n    function getEventCharCode(nativeEvent) {\n      var charCode;\n      var keyCode = nativeEvent.keyCode;\n\n      if ('charCode' in nativeEvent) {\n        charCode = nativeEvent.charCode; // FF does not set `charCode` for the Enter-key, check against `keyCode`.\n\n        if (charCode === 0 && keyCode === 13) {\n          charCode = 13;\n        }\n      } else {\n        // IE8 does not implement `charCode`, but `keyCode` has the correct value.\n        charCode = keyCode;\n      } // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n      // Must not discard the (non-)printable Enter-key.\n\n\n      if (charCode >= 32 || charCode === 13) {\n        return charCode;\n      }\n\n      return 0;\n    }\n\n    var getEventCharCode_1 = getEventCharCode;\n    /**\n     * Normalization of deprecated HTML5 `key` values\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n     */\n\n    var normalizeKey = {\n      Esc: 'Escape',\n      Spacebar: ' ',\n      Left: 'ArrowLeft',\n      Up: 'ArrowUp',\n      Right: 'ArrowRight',\n      Down: 'ArrowDown',\n      Del: 'Delete',\n      Win: 'OS',\n      Menu: 'ContextMenu',\n      Apps: 'ContextMenu',\n      Scroll: 'ScrollLock',\n      MozPrintableKey: 'Unidentified'\n    };\n    /**\n     * Translation from legacy `keyCode` to HTML5 `key`\n     * Only special keys supported, all others depend on keyboard layout or browser\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n     */\n\n    var translateToKey = {\n      8: 'Backspace',\n      9: 'Tab',\n      12: 'Clear',\n      13: 'Enter',\n      16: 'Shift',\n      17: 'Control',\n      18: 'Alt',\n      19: 'Pause',\n      20: 'CapsLock',\n      27: 'Escape',\n      32: ' ',\n      33: 'PageUp',\n      34: 'PageDown',\n      35: 'End',\n      36: 'Home',\n      37: 'ArrowLeft',\n      38: 'ArrowUp',\n      39: 'ArrowRight',\n      40: 'ArrowDown',\n      45: 'Insert',\n      46: 'Delete',\n      112: 'F1',\n      113: 'F2',\n      114: 'F3',\n      115: 'F4',\n      116: 'F5',\n      117: 'F6',\n      118: 'F7',\n      119: 'F8',\n      120: 'F9',\n      121: 'F10',\n      122: 'F11',\n      123: 'F12',\n      144: 'NumLock',\n      145: 'ScrollLock',\n      224: 'Meta'\n    };\n    /**\n     * @param {object} nativeEvent Native browser event.\n     * @return {string} Normalized `key` property.\n     */\n\n    function getEventKey(nativeEvent) {\n      if (nativeEvent.key) {\n        // Normalize inconsistent values reported by browsers due to\n        // implementations of a working draft specification.\n        // FireFox implements `key` but returns `MozPrintableKey` for all\n        // printable characters (normalized to `Unidentified`), ignore it.\n        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n\n        if (key !== 'Unidentified') {\n          return key;\n        }\n      } // Browser does not implement `key`, polyfill as much of it as we can.\n\n\n      if (nativeEvent.type === 'keypress') {\n        var charCode = getEventCharCode_1(nativeEvent); // The enter-key is technically both printable and non-printable and can\n        // thus be captured by `keypress`, no other non-printable key should.\n\n        return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n      }\n\n      if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\n        // While user keyboard layout determines the actual meaning of each\n        // `keyCode` value, almost all function keys have a universal value.\n        return translateToKey[nativeEvent.keyCode] || 'Unidentified';\n      }\n\n      return '';\n    }\n\n    var getEventKey_1 = getEventKey;\n    /**\n     * @interface KeyboardEvent\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n    var KeyboardEventInterface = {\n      key: getEventKey_1,\n      location: null,\n      ctrlKey: null,\n      shiftKey: null,\n      altKey: null,\n      metaKey: null,\n      repeat: null,\n      locale: null,\n      getModifierState: getEventModifierState_1,\n      // Legacy Interface\n      charCode: function charCode(event) {\n        // `charCode` is the result of a KeyPress event and represents the value of\n        // the actual printable character.\n        // KeyPress is deprecated, but its replacement is not yet final and not\n        // implemented in any major browser. Only KeyPress has charCode.\n        if (event.type === 'keypress') {\n          return getEventCharCode_1(event);\n        }\n\n        return 0;\n      },\n      keyCode: function keyCode(event) {\n        // `keyCode` is the result of a KeyDown/Up event and represents the value of\n        // physical keyboard key.\n        // The actual meaning of the value depends on the users' keyboard layout\n        // which cannot be detected. Assuming that it is a US keyboard layout\n        // provides a surprisingly accurate mapping for US and European users.\n        // Due to this, it is left to the user to implement at this time.\n        if (event.type === 'keydown' || event.type === 'keyup') {\n          return event.keyCode;\n        }\n\n        return 0;\n      },\n      which: function which(event) {\n        // `which` is an alias for either `keyCode` or `charCode` depending on the\n        // type of the event.\n        if (event.type === 'keypress') {\n          return getEventCharCode_1(event);\n        }\n\n        if (event.type === 'keydown' || event.type === 'keyup') {\n          return event.keyCode;\n        }\n\n        return 0;\n      }\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticUIEvent}\n     */\n\n    function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticUIEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticUIEvent_1.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);\n    var SyntheticKeyboardEvent_1 = SyntheticKeyboardEvent;\n    /**\n     * @interface DragEvent\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n    var DragEventInterface = {\n      dataTransfer: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticUIEvent}\n     */\n\n    function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticMouseEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticMouseEvent_1.augmentClass(SyntheticDragEvent, DragEventInterface);\n    var SyntheticDragEvent_1 = SyntheticDragEvent;\n    /**\n     * @interface TouchEvent\n     * @see http://www.w3.org/TR/touch-events/\n     */\n\n    var TouchEventInterface = {\n      touches: null,\n      targetTouches: null,\n      changedTouches: null,\n      altKey: null,\n      metaKey: null,\n      ctrlKey: null,\n      shiftKey: null,\n      getModifierState: getEventModifierState_1\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticUIEvent}\n     */\n\n    function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticUIEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticUIEvent_1.augmentClass(SyntheticTouchEvent, TouchEventInterface);\n    var SyntheticTouchEvent_1 = SyntheticTouchEvent;\n    /**\n     * @interface Event\n     * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n     */\n\n    var TransitionEventInterface = {\n      propertyName: null,\n      elapsedTime: null,\n      pseudoElement: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticEvent}\n     */\n\n    function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticEvent_1.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);\n    var SyntheticTransitionEvent_1 = SyntheticTransitionEvent;\n    /**\n     * @interface WheelEvent\n     * @see http://www.w3.org/TR/DOM-Level-3-Events/\n     */\n\n    var WheelEventInterface = {\n      deltaX: function deltaX(event) {\n        return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n        'wheelDeltaX' in event ? -event.wheelDeltaX : 0;\n      },\n      deltaY: function deltaY(event) {\n        return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n        'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n        'wheelDelta' in event ? -event.wheelDelta : 0;\n      },\n      deltaZ: null,\n      // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n      // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n      deltaMode: null\n    };\n    /**\n     * @param {object} dispatchConfig Configuration used to dispatch this event.\n     * @param {string} dispatchMarker Marker identifying the event target.\n     * @param {object} nativeEvent Native browser event.\n     * @extends {SyntheticMouseEvent}\n     */\n\n    function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n      return SyntheticMouseEvent_1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n    }\n\n    SyntheticMouseEvent_1.augmentClass(SyntheticWheelEvent, WheelEventInterface);\n    var SyntheticWheelEvent_1 = SyntheticWheelEvent;\n    /**\n     * Turns\n     * ['abort', ...]\n     * into\n     * eventTypes = {\n     *   'abort': {\n     *     phasedRegistrationNames: {\n     *       bubbled: 'onAbort',\n     *       captured: 'onAbortCapture',\n     *     },\n     *     dependencies: ['topAbort'],\n     *   },\n     *   ...\n     * };\n     * topLevelEventsToDispatchConfig = {\n     *   'topAbort': { sameConfig }\n     * };\n     */\n\n    var eventTypes$4 = {};\n    var topLevelEventsToDispatchConfig = {};\n    ['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'cancel', 'canPlay', 'canPlayThrough', 'click', 'close', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'toggle', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {\n      var capitalizedEvent = event[0].toUpperCase() + event.slice(1);\n      var onEvent = 'on' + capitalizedEvent;\n      var topEvent = 'top' + capitalizedEvent;\n      var type = {\n        phasedRegistrationNames: {\n          bubbled: onEvent,\n          captured: onEvent + 'Capture'\n        },\n        dependencies: [topEvent]\n      };\n      eventTypes$4[event] = type;\n      topLevelEventsToDispatchConfig[topEvent] = type;\n    });\n    var SimpleEventPlugin = {\n      eventTypes: eventTypes$4,\n      extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n        var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n\n        if (!dispatchConfig) {\n          return null;\n        }\n\n        var EventConstructor;\n\n        switch (topLevelType) {\n          case 'topAbort':\n          case 'topCancel':\n          case 'topCanPlay':\n          case 'topCanPlayThrough':\n          case 'topClose':\n          case 'topDurationChange':\n          case 'topEmptied':\n          case 'topEncrypted':\n          case 'topEnded':\n          case 'topError':\n          case 'topInput':\n          case 'topInvalid':\n          case 'topLoad':\n          case 'topLoadedData':\n          case 'topLoadedMetadata':\n          case 'topLoadStart':\n          case 'topPause':\n          case 'topPlay':\n          case 'topPlaying':\n          case 'topProgress':\n          case 'topRateChange':\n          case 'topReset':\n          case 'topSeeked':\n          case 'topSeeking':\n          case 'topStalled':\n          case 'topSubmit':\n          case 'topSuspend':\n          case 'topTimeUpdate':\n          case 'topToggle':\n          case 'topVolumeChange':\n          case 'topWaiting':\n            // HTML Events\n            // @see http://www.w3.org/TR/html5/index.html#events-0\n            EventConstructor = SyntheticEvent_1;\n            break;\n\n          case 'topKeyPress':\n            // Firefox creates a keypress event for function keys too. This removes\n            // the unwanted keypress events. Enter is however both printable and\n            // non-printable. One would expect Tab to be as well (but it isn't).\n            if (getEventCharCode_1(nativeEvent) === 0) {\n              return null;\n            }\n\n          /* falls through */\n\n          case 'topKeyDown':\n          case 'topKeyUp':\n            EventConstructor = SyntheticKeyboardEvent_1;\n            break;\n\n          case 'topBlur':\n          case 'topFocus':\n            EventConstructor = SyntheticFocusEvent_1;\n            break;\n\n          case 'topClick':\n            // Firefox creates a click event on right mouse clicks. This removes the\n            // unwanted click events.\n            if (nativeEvent.button === 2) {\n              return null;\n            }\n\n          /* falls through */\n\n          case 'topDoubleClick':\n          case 'topMouseDown':\n          case 'topMouseMove':\n          case 'topMouseUp': // TODO: Disabled elements should not respond to mouse events\n\n          /* falls through */\n\n          case 'topMouseOut':\n          case 'topMouseOver':\n          case 'topContextMenu':\n            EventConstructor = SyntheticMouseEvent_1;\n            break;\n\n          case 'topDrag':\n          case 'topDragEnd':\n          case 'topDragEnter':\n          case 'topDragExit':\n          case 'topDragLeave':\n          case 'topDragOver':\n          case 'topDragStart':\n          case 'topDrop':\n            EventConstructor = SyntheticDragEvent_1;\n            break;\n\n          case 'topTouchCancel':\n          case 'topTouchEnd':\n          case 'topTouchMove':\n          case 'topTouchStart':\n            EventConstructor = SyntheticTouchEvent_1;\n            break;\n\n          case 'topAnimationEnd':\n          case 'topAnimationIteration':\n          case 'topAnimationStart':\n            EventConstructor = SyntheticAnimationEvent_1;\n            break;\n\n          case 'topTransitionEnd':\n            EventConstructor = SyntheticTransitionEvent_1;\n            break;\n\n          case 'topScroll':\n            EventConstructor = SyntheticUIEvent_1;\n            break;\n\n          case 'topWheel':\n            EventConstructor = SyntheticWheelEvent_1;\n            break;\n\n          case 'topCopy':\n          case 'topCut':\n          case 'topPaste':\n            EventConstructor = SyntheticClipboardEvent_1;\n            break;\n        }\n\n        !EventConstructor ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : void 0;\n        var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);\n        EventPropagators_1.accumulateTwoPhaseDispatches(event);\n        return event;\n      }\n    };\n    var SimpleEventPlugin_1 = SimpleEventPlugin;\n    ReactDOMEventListener_1.setHandleTopLevel(ReactBrowserEventEmitter_1.handleTopLevel);\n    /**\n     * Inject modules for resolving DOM hierarchy and plugin ordering.\n     */\n\n    EventPluginHub_1.injection.injectEventPluginOrder(DOMEventPluginOrder_1);\n    EventPluginUtils_1.injection.injectComponentTree(ReactDOMComponentTree_1);\n    /**\n     * Some important event plugins included by default (without having to require\n     * them).\n     */\n\n    EventPluginHub_1.injection.injectEventPluginsByName({\n      SimpleEventPlugin: SimpleEventPlugin_1,\n      EnterLeaveEventPlugin: EnterLeaveEventPlugin_1,\n      ChangeEventPlugin: ChangeEventPlugin_1,\n      SelectEventPlugin: SelectEventPlugin_1,\n      BeforeInputEventPlugin: BeforeInputEventPlugin_1\n    });\n    var MUST_USE_PROPERTY = DOMProperty_1.injection.MUST_USE_PROPERTY;\n    var HAS_BOOLEAN_VALUE = DOMProperty_1.injection.HAS_BOOLEAN_VALUE;\n    var HAS_NUMERIC_VALUE = DOMProperty_1.injection.HAS_NUMERIC_VALUE;\n    var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty_1.injection.HAS_POSITIVE_NUMERIC_VALUE;\n    var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty_1.injection.HAS_OVERLOADED_BOOLEAN_VALUE;\n    var HAS_STRING_BOOLEAN_VALUE = DOMProperty_1.injection.HAS_STRING_BOOLEAN_VALUE;\n    var HTMLDOMPropertyConfig = {\n      // When adding attributes to this list, be sure to also add them to\n      // the `possibleStandardNames` module to ensure casing and incorrect\n      // name warnings.\n      Properties: {\n        allowFullScreen: HAS_BOOLEAN_VALUE,\n        // IE only true/false iFrame attribute\n        // https://msdn.microsoft.com/en-us/library/ms533072(v=vs.85).aspx\n        allowTransparency: HAS_STRING_BOOLEAN_VALUE,\n        // specifies target context for links with `preload` type\n        async: HAS_BOOLEAN_VALUE,\n        // autoFocus is polyfilled/normalized by AutoFocusUtils\n        // autoFocus: HAS_BOOLEAN_VALUE,\n        autoPlay: HAS_BOOLEAN_VALUE,\n        capture: HAS_BOOLEAN_VALUE,\n        checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n        cols: HAS_POSITIVE_NUMERIC_VALUE,\n        contentEditable: HAS_STRING_BOOLEAN_VALUE,\n        controls: HAS_BOOLEAN_VALUE,\n        'default': HAS_BOOLEAN_VALUE,\n        defer: HAS_BOOLEAN_VALUE,\n        disabled: HAS_BOOLEAN_VALUE,\n        download: HAS_OVERLOADED_BOOLEAN_VALUE,\n        draggable: HAS_STRING_BOOLEAN_VALUE,\n        formNoValidate: HAS_BOOLEAN_VALUE,\n        hidden: HAS_BOOLEAN_VALUE,\n        loop: HAS_BOOLEAN_VALUE,\n        // Caution; `option.selected` is not updated if `select.multiple` is\n        // disabled with `removeAttribute`.\n        multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n        muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n        noValidate: HAS_BOOLEAN_VALUE,\n        open: HAS_BOOLEAN_VALUE,\n        playsInline: HAS_BOOLEAN_VALUE,\n        readOnly: HAS_BOOLEAN_VALUE,\n        required: HAS_BOOLEAN_VALUE,\n        reversed: HAS_BOOLEAN_VALUE,\n        rows: HAS_POSITIVE_NUMERIC_VALUE,\n        rowSpan: HAS_NUMERIC_VALUE,\n        scoped: HAS_BOOLEAN_VALUE,\n        seamless: HAS_BOOLEAN_VALUE,\n        selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,\n        size: HAS_POSITIVE_NUMERIC_VALUE,\n        start: HAS_NUMERIC_VALUE,\n        // support for projecting regular DOM Elements via V1 named slots ( shadow dom )\n        span: HAS_POSITIVE_NUMERIC_VALUE,\n        spellCheck: HAS_STRING_BOOLEAN_VALUE,\n        // Style must be explicitly set in the attribute list. React components\n        // expect a style object\n        style: 0,\n        // itemScope is for for Microdata support.\n        // See http://schema.org/docs/gs.html\n        itemScope: HAS_BOOLEAN_VALUE,\n        // These attributes must stay in the white-list because they have\n        // different attribute names (see DOMAttributeNames below)\n        acceptCharset: 0,\n        className: 0,\n        htmlFor: 0,\n        httpEquiv: 0,\n        // Attributes with mutation methods must be specified in the whitelist\n        // Set the string boolean flag to allow the behavior\n        value: HAS_STRING_BOOLEAN_VALUE\n      },\n      DOMAttributeNames: {\n        acceptCharset: 'accept-charset',\n        className: 'class',\n        htmlFor: 'for',\n        httpEquiv: 'http-equiv'\n      },\n      DOMMutationMethods: {\n        value: function value(node, _value) {\n          if (_value == null) {\n            return node.removeAttribute('value');\n          } // Number inputs get special treatment due to some edge cases in\n          // Chrome. Let everything else assign the value attribute as normal.\n          // https://github.com/facebook/react/issues/7253#issuecomment-236074326\n\n\n          if (node.type !== 'number' || node.hasAttribute('value') === false) {\n            node.setAttribute('value', '' + _value);\n          } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {\n            // Don't assign an attribute if validation reports bad\n            // input. Chrome will clear the value. Additionally, don't\n            // operate on inputs that have focus, otherwise Chrome might\n            // strip off trailing decimal places and cause the user's\n            // cursor position to jump to the beginning of the input.\n            //\n            // In ReactDOMInput, we have an onBlur event that will trigger\n            // this function again when focus is lost.\n            node.setAttribute('value', '' + _value);\n          }\n        }\n      }\n    };\n    var HTMLDOMPropertyConfig_1 = HTMLDOMPropertyConfig;\n    var HAS_STRING_BOOLEAN_VALUE$1 = DOMProperty_1.injection.HAS_STRING_BOOLEAN_VALUE;\n    var NS = {\n      xlink: 'http://www.w3.org/1999/xlink',\n      xml: 'http://www.w3.org/XML/1998/namespace'\n    };\n    /**\n     * This is a list of all SVG attributes that need special casing,\n     * namespacing, or boolean value assignment.\n     *\n     * When adding attributes to this list, be sure to also add them to\n     * the `possibleStandardNames` module to ensure casing and incorrect\n     * name warnings.\n     *\n     * SVG Attributes List:\n     * https://www.w3.org/TR/SVG/attindex.html\n     * SMIL Spec:\n     * https://www.w3.org/TR/smil\n     */\n\n    var ATTRS = ['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'x-height', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xmlns:xlink', 'xml:lang', 'xml:space'];\n    var SVGDOMPropertyConfig = {\n      Properties: {\n        autoReverse: HAS_STRING_BOOLEAN_VALUE$1,\n        externalResourcesRequired: HAS_STRING_BOOLEAN_VALUE$1,\n        preserveAlpha: HAS_STRING_BOOLEAN_VALUE$1\n      },\n      DOMAttributeNames: {\n        autoReverse: 'autoReverse',\n        externalResourcesRequired: 'externalResourcesRequired',\n        preserveAlpha: 'preserveAlpha'\n      },\n      DOMAttributeNamespaces: {\n        xlinkActuate: NS.xlink,\n        xlinkArcrole: NS.xlink,\n        xlinkHref: NS.xlink,\n        xlinkRole: NS.xlink,\n        xlinkShow: NS.xlink,\n        xlinkTitle: NS.xlink,\n        xlinkType: NS.xlink,\n        xmlBase: NS.xml,\n        xmlLang: NS.xml,\n        xmlSpace: NS.xml\n      }\n    };\n    var CAMELIZE = /[\\-\\:]([a-z])/g;\n\n    var capitalize = function capitalize(token) {\n      return token[1].toUpperCase();\n    };\n\n    ATTRS.forEach(function (original) {\n      var reactName = original.replace(CAMELIZE, capitalize);\n      SVGDOMPropertyConfig.Properties[reactName] = 0;\n      SVGDOMPropertyConfig.DOMAttributeNames[reactName] = original;\n    });\n    var SVGDOMPropertyConfig_1 = SVGDOMPropertyConfig;\n    DOMProperty_1.injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig_1);\n    DOMProperty_1.injection.injectDOMPropertyConfig(SVGDOMPropertyConfig_1);\n    var injectInternals = ReactFiberDevToolsHook.injectInternals;\n    var ELEMENT_NODE = HTMLNodeType_1.ELEMENT_NODE;\n    var TEXT_NODE = HTMLNodeType_1.TEXT_NODE;\n    var COMMENT_NODE = HTMLNodeType_1.COMMENT_NODE;\n    var DOCUMENT_NODE = HTMLNodeType_1.DOCUMENT_NODE;\n    var DOCUMENT_FRAGMENT_NODE = HTMLNodeType_1.DOCUMENT_FRAGMENT_NODE;\n    var ROOT_ATTRIBUTE_NAME = DOMProperty_1.ROOT_ATTRIBUTE_NAME;\n    var getChildNamespace = DOMNamespaces.getChildNamespace;\n    var createElement = ReactDOMFiberComponent_1.createElement;\n    var createTextNode = ReactDOMFiberComponent_1.createTextNode;\n    var setInitialProperties = ReactDOMFiberComponent_1.setInitialProperties;\n    var diffProperties = ReactDOMFiberComponent_1.diffProperties;\n    var updateProperties = ReactDOMFiberComponent_1.updateProperties;\n    var diffHydratedProperties = ReactDOMFiberComponent_1.diffHydratedProperties;\n    var diffHydratedText = ReactDOMFiberComponent_1.diffHydratedText;\n    var warnForDeletedHydratableElement = ReactDOMFiberComponent_1.warnForDeletedHydratableElement;\n    var warnForDeletedHydratableText = ReactDOMFiberComponent_1.warnForDeletedHydratableText;\n    var warnForInsertedHydratedElement = ReactDOMFiberComponent_1.warnForInsertedHydratedElement;\n    var warnForInsertedHydratedText = ReactDOMFiberComponent_1.warnForInsertedHydratedText;\n    var precacheFiberNode = ReactDOMComponentTree_1.precacheFiberNode;\n    var updateFiberProps = ReactDOMComponentTree_1.updateFiberProps;\n    {\n      var lowPriorityWarning = lowPriorityWarning_1;\n      var warning = require$$0;\n      var validateDOMNesting = validateDOMNesting_1;\n      var updatedAncestorInfo = validateDOMNesting.updatedAncestorInfo;\n\n      if (typeof Map !== 'function' || Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' || Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {\n        warning(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. http://fb.me/react-polyfills');\n      }\n    }\n    ReactControlledComponent_1.injection.injectFiberControlledHostComponent(ReactDOMFiberComponent_1);\n\n    findDOMNode_1._injectFiber(function (fiber) {\n      return DOMRenderer.findHostInstance(fiber);\n    });\n\n    var eventsEnabled = null;\n    var selectionInformation = null;\n    /**\n     * True if the supplied DOM node is a valid node element.\n     *\n     * @param {?DOMElement} node The candidate DOM node.\n     * @return {boolean} True if the DOM is a valid DOM node.\n     * @internal\n     */\n\n    function isValidContainer(node) {\n      return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));\n    }\n\n    function getReactRootElementInContainer(container) {\n      if (!container) {\n        return null;\n      }\n\n      if (container.nodeType === DOCUMENT_NODE) {\n        return container.documentElement;\n      } else {\n        return container.firstChild;\n      }\n    }\n\n    function shouldHydrateDueToLegacyHeuristic(container) {\n      var rootElement = getReactRootElementInContainer(container);\n      return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));\n    }\n\n    function shouldAutoFocusHostComponent(type, props) {\n      switch (type) {\n        case 'button':\n        case 'input':\n        case 'select':\n        case 'textarea':\n          return !!props.autoFocus;\n      }\n\n      return false;\n    }\n\n    var DOMRenderer = ReactFiberReconciler({\n      getRootHostContext: function getRootHostContext(rootContainerInstance) {\n        var type = void 0;\n        var namespace = void 0;\n\n        if (rootContainerInstance.nodeType === DOCUMENT_NODE) {\n          type = '#document';\n          var root = rootContainerInstance.documentElement;\n          namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n        } else {\n          var container = rootContainerInstance.nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n          var ownNamespace = container.namespaceURI || null;\n          type = container.tagName;\n          namespace = getChildNamespace(ownNamespace, type);\n        }\n\n        {\n          var validatedTag = type.toLowerCase();\n\n          var _ancestorInfo = updatedAncestorInfo(null, validatedTag, null);\n\n          return {\n            namespace: namespace,\n            ancestorInfo: _ancestorInfo\n          };\n        }\n        return namespace;\n      },\n      getChildHostContext: function getChildHostContext(parentHostContext, type) {\n        {\n          var parentHostContextDev = parentHostContext;\n\n          var _namespace = getChildNamespace(parentHostContextDev.namespace, type);\n\n          var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type, null);\n\n          return {\n            namespace: _namespace,\n            ancestorInfo: _ancestorInfo2\n          };\n        }\n        var parentNamespace = parentHostContext;\n        return getChildNamespace(parentNamespace, type);\n      },\n      getPublicInstance: function getPublicInstance(instance) {\n        return instance;\n      },\n      prepareForCommit: function prepareForCommit() {\n        eventsEnabled = ReactBrowserEventEmitter_1.isEnabled();\n        selectionInformation = ReactInputSelection_1.getSelectionInformation();\n        ReactBrowserEventEmitter_1.setEnabled(false);\n      },\n      resetAfterCommit: function resetAfterCommit() {\n        ReactInputSelection_1.restoreSelection(selectionInformation);\n        selectionInformation = null;\n        ReactBrowserEventEmitter_1.setEnabled(eventsEnabled);\n        eventsEnabled = null;\n      },\n      createInstance: function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n        var parentNamespace = void 0;\n        {\n          // TODO: take namespace into account when validating.\n          var hostContextDev = hostContext;\n          validateDOMNesting(type, null, null, hostContextDev.ancestorInfo);\n\n          if (typeof props.children === 'string' || typeof props.children === 'number') {\n            var string = '' + props.children;\n            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n            validateDOMNesting(null, string, null, ownAncestorInfo);\n          }\n\n          parentNamespace = hostContextDev.namespace;\n        }\n        var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n        precacheFiberNode(internalInstanceHandle, domElement);\n        updateFiberProps(domElement, props);\n        return domElement;\n      },\n      appendInitialChild: function appendInitialChild(parentInstance, child) {\n        parentInstance.appendChild(child);\n      },\n      finalizeInitialChildren: function finalizeInitialChildren(domElement, type, props, rootContainerInstance) {\n        setInitialProperties(domElement, type, props, rootContainerInstance);\n        return shouldAutoFocusHostComponent(type, props);\n      },\n      prepareUpdate: function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n        {\n          var hostContextDev = hostContext;\n\n          if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n            var string = '' + newProps.children;\n            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);\n            validateDOMNesting(null, string, null, ownAncestorInfo);\n          }\n        }\n        return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n      },\n      commitMount: function commitMount(domElement, type, newProps, internalInstanceHandle) {\n        domElement.focus();\n      },\n      commitUpdate: function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n        // Update the props handle so that we know which props are the ones with\n        // with current event handlers.\n        updateFiberProps(domElement, newProps); // Apply the diff to the DOM node.\n\n        updateProperties(domElement, updatePayload, type, oldProps, newProps);\n      },\n      shouldSetTextContent: function shouldSetTextContent(type, props) {\n        return type === 'textarea' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && typeof props.dangerouslySetInnerHTML.__html === 'string';\n      },\n      resetTextContent: function resetTextContent(domElement) {\n        domElement.textContent = '';\n      },\n      shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree(type, props) {\n        return !!props.hidden;\n      },\n      createTextInstance: function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\n        {\n          var hostContextDev = hostContext;\n          validateDOMNesting(null, text, null, hostContextDev.ancestorInfo);\n        }\n        var textNode = createTextNode(text, rootContainerInstance);\n        precacheFiberNode(internalInstanceHandle, textNode);\n        return textNode;\n      },\n      commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {\n        textInstance.nodeValue = newText;\n      },\n      appendChild: function appendChild(parentInstance, child) {\n        parentInstance.appendChild(child);\n      },\n      appendChildToContainer: function appendChildToContainer(container, child) {\n        if (container.nodeType === COMMENT_NODE) {\n          container.parentNode.insertBefore(child, container);\n        } else {\n          container.appendChild(child);\n        }\n      },\n      insertBefore: function insertBefore(parentInstance, child, beforeChild) {\n        parentInstance.insertBefore(child, beforeChild);\n      },\n      insertInContainerBefore: function insertInContainerBefore(container, child, beforeChild) {\n        if (container.nodeType === COMMENT_NODE) {\n          container.parentNode.insertBefore(child, beforeChild);\n        } else {\n          container.insertBefore(child, beforeChild);\n        }\n      },\n      removeChild: function removeChild(parentInstance, child) {\n        parentInstance.removeChild(child);\n      },\n      removeChildFromContainer: function removeChildFromContainer(container, child) {\n        if (container.nodeType === COMMENT_NODE) {\n          container.parentNode.removeChild(child);\n        } else {\n          container.removeChild(child);\n        }\n      },\n      canHydrateInstance: function canHydrateInstance(instance, type, props) {\n        return instance.nodeType === ELEMENT_NODE && type === instance.nodeName.toLowerCase();\n      },\n      canHydrateTextInstance: function canHydrateTextInstance(instance, text) {\n        if (text === '') {\n          // Empty strings are not parsed by HTML so there won't be a correct match here.\n          return false;\n        }\n\n        return instance.nodeType === TEXT_NODE;\n      },\n      getNextHydratableSibling: function getNextHydratableSibling(instance) {\n        var node = instance.nextSibling; // Skip non-hydratable nodes.\n\n        while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {\n          node = node.nextSibling;\n        }\n\n        return node;\n      },\n      getFirstHydratableChild: function getFirstHydratableChild(parentInstance) {\n        var next = parentInstance.firstChild; // Skip non-hydratable nodes.\n\n        while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {\n          next = next.nextSibling;\n        }\n\n        return next;\n      },\n      hydrateInstance: function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n        precacheFiberNode(internalInstanceHandle, instance); // TODO: Possibly defer this until the commit phase where all the events\n        // get attached.\n\n        updateFiberProps(instance, props);\n        var parentNamespace = void 0;\n        {\n          var hostContextDev = hostContext;\n          parentNamespace = hostContextDev.namespace;\n        }\n        return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\n      },\n      hydrateTextInstance: function hydrateTextInstance(textInstance, text, internalInstanceHandle) {\n        precacheFiberNode(internalInstanceHandle, textInstance);\n        return diffHydratedText(textInstance, text);\n      },\n      didNotHydrateInstance: function didNotHydrateInstance(parentInstance, instance) {\n        if (instance.nodeType === 1) {\n          warnForDeletedHydratableElement(parentInstance, instance);\n        } else {\n          warnForDeletedHydratableText(parentInstance, instance);\n        }\n      },\n      didNotFindHydratableInstance: function didNotFindHydratableInstance(parentInstance, type, props) {\n        warnForInsertedHydratedElement(parentInstance, type, props);\n      },\n      didNotFindHydratableTextInstance: function didNotFindHydratableTextInstance(parentInstance, text) {\n        warnForInsertedHydratedText(parentInstance, text);\n      },\n      scheduleDeferredCallback: ReactDOMFrameScheduling.rIC,\n      useSyncScheduling: !ReactDOMFeatureFlags_1.fiberAsyncScheduling\n    });\n    ReactGenericBatching_1.injection.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);\n    var warnedAboutHydrateAPI = false;\n\n    function renderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n      !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n      {\n        if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n          var hostInstance = DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);\n\n          if (hostInstance) {\n            warning(hostInstance.parentNode === container, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.');\n          }\n        }\n\n        var isRootRenderedBySomeReact = !!container._reactRootContainer;\n        var rootEl = getReactRootElementInContainer(container);\n        var hasNonRootReactChild = !!(rootEl && ReactDOMComponentTree_1.getInstanceFromNode(rootEl));\n        warning(!hasNonRootReactChild || isRootRenderedBySomeReact, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.');\n        warning(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.');\n      }\n      var root = container._reactRootContainer;\n\n      if (!root) {\n        var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // First clear any existing content.\n\n        if (!shouldHydrate) {\n          var warned = false;\n          var rootSibling = void 0;\n\n          while (rootSibling = container.lastChild) {\n            {\n              if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {\n                warned = true;\n                warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');\n              }\n            }\n            container.removeChild(rootSibling);\n          }\n        }\n\n        {\n          if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n            warnedAboutHydrateAPI = true;\n            lowPriorityWarning(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');\n          }\n        }\n        var newRoot = DOMRenderer.createContainer(container);\n        root = container._reactRootContainer = newRoot; // Initial mount should not be batched.\n\n        DOMRenderer.unbatchedUpdates(function () {\n          DOMRenderer.updateContainer(children, newRoot, parentComponent, callback);\n        });\n      } else {\n        DOMRenderer.updateContainer(children, root, parentComponent, callback);\n      }\n\n      return DOMRenderer.getPublicRootInstance(root);\n    }\n\n    function createPortal(children, container) {\n      var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0; // TODO: pass ReactDOM portal implementation as third argument\n\n      return ReactPortal.createPortal(children, container, null, key);\n    }\n\n    var ReactDOMFiber = {\n      createPortal: createPortal,\n      hydrate: function hydrate(element, container, callback) {\n        // TODO: throw or warn if we couldn't hydrate?\n        return renderSubtreeIntoContainer(null, element, container, true, callback);\n      },\n      render: function render(element, container, callback) {\n        return renderSubtreeIntoContainer(null, element, container, false, callback);\n      },\n      unstable_renderSubtreeIntoContainer: function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {\n        !(parentComponent != null && ReactInstanceMap_1.has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;\n        return renderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n      },\n      unmountComponentAtNode: function unmountComponentAtNode(container) {\n        !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;\n\n        if (container._reactRootContainer) {\n          {\n            var rootEl = getReactRootElementInContainer(container);\n            var renderedByDifferentReact = rootEl && !ReactDOMComponentTree_1.getInstanceFromNode(rootEl);\n            warning(!renderedByDifferentReact, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.');\n          } // Unmount should not be batched.\n\n          DOMRenderer.unbatchedUpdates(function () {\n            renderSubtreeIntoContainer(null, null, container, false, function () {\n              container._reactRootContainer = null;\n            });\n          }); // If you call unmountComponentAtNode twice in quick succession, you'll\n          // get `true` twice. That's probably fine?\n\n          return true;\n        } else {\n          {\n            var _rootEl = getReactRootElementInContainer(container);\n\n            var hasNonRootReactChild = !!(_rootEl && ReactDOMComponentTree_1.getInstanceFromNode(_rootEl)); // Check if the container itself is a React root node.\n\n            var isContainerReactRoot = container.nodeType === 1 && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;\n            warning(!hasNonRootReactChild, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.');\n          }\n          return false;\n        }\n      },\n      findDOMNode: findDOMNode_1,\n      // Temporary alias since we already shipped React 16 RC with it.\n      // TODO: remove in React 17.\n      unstable_createPortal: createPortal,\n      unstable_batchedUpdates: ReactGenericBatching_1.batchedUpdates,\n      unstable_deferredUpdates: DOMRenderer.deferredUpdates,\n      flushSync: DOMRenderer.flushSync,\n      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n        // For TapEventPlugin which is popular in open source\n        EventPluginHub: EventPluginHub_1,\n        // Used by test-utils\n        EventPluginRegistry: EventPluginRegistry_1,\n        EventPropagators: EventPropagators_1,\n        ReactControlledComponent: ReactControlledComponent_1,\n        ReactDOMComponentTree: ReactDOMComponentTree_1,\n        ReactDOMEventListener: ReactDOMEventListener_1\n      }\n    };\n    var foundDevTools = injectInternals({\n      findFiberByHostInstance: ReactDOMComponentTree_1.getClosestInstanceFromNode,\n      findHostInstanceByFiber: DOMRenderer.findHostInstance,\n      // This is an enum because we may add more (e.g. profiler build)\n      bundleType: 1,\n      version: ReactVersion,\n      rendererPackageName: 'react-dom'\n    });\n    {\n      if (!foundDevTools && ExecutionEnvironment.canUseDOM && window.top === window.self) {\n        // If we're in Chrome or Firefox, provide a download link if not installed.\n        if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {\n          var protocol = window.location.protocol; // Don't warn in exotic cases like chrome-extension://.\n\n          if (/^(https?|file):$/.test(protocol)) {\n            console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');\n          }\n        }\n      }\n    }\n    var ReactDOMFiberEntry = ReactDOMFiber;\n    module.exports = ReactDOMFiberEntry;\n  })();\n}","map":null,"metadata":{},"sourceType":"script"}